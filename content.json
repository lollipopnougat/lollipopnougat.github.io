{"meta":{"title":"LNP","subtitle":"","description":"","author":"lollipopnougat","url":"https://www.lollipopnougat.top","root":"/"},"pages":[{"title":"","date":"2021-04-26T07:15:05.767Z","updated":"2021-04-26T07:15:05.767Z","comments":true,"path":"404.html","permalink":"https://www.lollipopnougat.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-04-26T08:43:32.748Z","updated":"2021-04-26T08:43:32.748Z","comments":true,"path":"about/index.html","permalink":"https://www.lollipopnougat.top/about/index.html","excerpt":"","text":"博客信息Lnp Lollipopnougat Popsicle 这是 lollipopnougat 的博客 此博客于2018年12月建站 查看作者Github信息 本站相关 博客框架 博客主题 Hexo A fast simple & powerful blog framework Volantis A Wonderful Theme for Hexo 有什么想说的话 啊咧，这个小地方居然存在这么久了？太好了，为了感谢各位我决定 摸了"},{"title":"所有分类","date":"2021-04-26T07:14:17.943Z","updated":"2021-04-26T07:14:17.943Z","comments":true,"path":"categories/index.html","permalink":"https://www.lollipopnougat.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-25T09:18:11.138Z","updated":"2021-04-25T09:18:11.138Z","comments":false,"path":"artitalk/index.html","permalink":"https://www.lollipopnougat.top/artitalk/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2021-04-26T07:14:44.283Z","updated":"2021-04-26T07:14:44.283Z","comments":true,"path":"friends/index.html","permalink":"https://www.lollipopnougat.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2021-04-25T08:37:39.723Z","updated":"2021-04-25T08:37:39.723Z","comments":true,"path":"mylist/index.html","permalink":"https://www.lollipopnougat.top/mylist/index.html","excerpt":"","text":""},{"title":"精选项目","date":"2023-03-06T15:33:29.263Z","updated":"2023-03-06T15:33:29.263Z","comments":true,"path":"projects/index.html","permalink":"https://www.lollipopnougat.top/projects/index.html","excerpt":"","text":"自己觉得还可以的项目 算法学习项目地址 春节贺卡项目项目地址 WPF桌面弹幕发射器项目地址 pip换源工具项目地址, pip仓库中的pimm包 明日方舟模拟寻访项目地址 网络安全协会主页项目地址 看起来没有多少项目的亚子"},{"title":"所有标签","date":"2021-04-26T07:15:50.044Z","updated":"2021-04-26T07:15:50.044Z","comments":true,"path":"tags/index.html","permalink":"https://www.lollipopnougat.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"机械硬盘的坏扇区和磁记录方式","slug":"机械硬盘的坏扇区和磁记录方式","date":"2022-11-12T13:41:00.000Z","updated":"2023-05-21T02:26:46.551Z","comments":true,"path":"2022/11/12/机械硬盘的坏扇区和磁记录方式/","link":"","permalink":"https://www.lollipopnougat.top/2022/11/12/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E7%9A%84%E5%9D%8F%E6%89%87%E5%8C%BA%E5%92%8C%E7%A3%81%E8%AE%B0%E5%BD%95%E6%96%B9%E5%BC%8F/","excerpt":"机械硬盘的坏扇区、磁记录方式10月初室友的笔记本电脑开机提示S.M.A.R.T.(Self-Monitoring Analysis and Reporting，是一种嵌入硬盘、固态硬盘和eMMC存储上的硬盘监控系统)有问题，笔者使用CrystalDiskInfo检测，发现机械硬盘的 重新分配扇区计数 出现了警告。重新分配扇区计数值在一段时间内显著增加，说明这个硬盘快要挂掉了。昨天室友的笔记本电脑蓝屏了好几次，并时不时出现掉盘的现象，虽然系统盘并非那块机械，但是蓝屏错误大概率与那个要坏掉的机械硬盘有关，比如如果在访问虚拟内存时发生掉盘，就有可能出现各种意想不到的问题。深夜那块硬盘在最后回光返照了一下以后，再也识别不到了(悲)。还好在昨天发觉不对劲之时已经抢救了一部分数据，造成的损失倒没有多少，可能就是需要买一块新的硬盘，然后把之前的软件和游戏重新安装……总之很麻烦就是了。","text":"机械硬盘的坏扇区、磁记录方式10月初室友的笔记本电脑开机提示S.M.A.R.T.(Self-Monitoring Analysis and Reporting，是一种嵌入硬盘、固态硬盘和eMMC存储上的硬盘监控系统)有问题，笔者使用CrystalDiskInfo检测，发现机械硬盘的 重新分配扇区计数 出现了警告。重新分配扇区计数值在一段时间内显著增加，说明这个硬盘快要挂掉了。昨天室友的笔记本电脑蓝屏了好几次，并时不时出现掉盘的现象，虽然系统盘并非那块机械，但是蓝屏错误大概率与那个要坏掉的机械硬盘有关，比如如果在访问虚拟内存时发生掉盘，就有可能出现各种意想不到的问题。深夜那块硬盘在最后回光返照了一下以后，再也识别不到了(悲)。还好在昨天发觉不对劲之时已经抢救了一部分数据，造成的损失倒没有多少，可能就是需要买一块新的硬盘，然后把之前的软件和游戏重新安装……总之很麻烦就是了。 除了用一个新磁盘直接克隆受影响的磁盘外，对重新分配的扇区计数警告无法修复。然而，带有重新分配扇区计数警告的驱动器并不意味着该驱动器不能工作。只要驱动器运行，就可以继续使用它，但风险由用户自行承担，其实这也就是说明你还可以用，但是硬盘不能保证数据的可靠性了，而且未来有可能还会恶化，所以基本看到重新分配的扇区计数就得考虑购买新的磁盘准备替换了。 机械硬盘的坏扇区从本质上讲，重新分配的扇区(也称为坏扇区或坏块或坏道)是磁盘上不再安全存储数据的区域，通俗来说就是硬盘上永久损坏一个地方，该部分中保存的所有信息都将丢失。 坏扇区分类坏扇区一般分为两种类型：硬坏扇区（也称为物理坏道）和软坏扇区（也称为逻辑坏道）。 硬坏扇区硬坏扇区主要是由物理损坏引起的，例如制造中出现问题、硬盘盘片受到物理划伤等； 软坏扇区软坏扇区通常与软件问题有关，例如对硬盘的不当操作、文件系统错误等 当系统无法读取、写入或验证存储在特定扇区的数据时，它将该扇区标记为坏扇区，并将存储的数据重新分配或映射到硬盘上的预留区域(空闲区域)。。预留区域是磁盘预留出来的区域，用于磁盘的正常运行，并防止由于坏道导致数据立即丢失。一般厂商都会留有一定量的冗余扇区作为备份，如果坏扇区的数量低于冗余的数量，那么这个磁盘暂时还是不太受影响；如果损坏继续扩大，超过了冗余，那么就是正常的数据受损了。 造成坏扇区的原因 硬盘原本的质量瑕疵受技术所限，现在的机械硬盘在生产时无法达到100%无坏扇区，往往会有一些物理坏道在硬盘盘的碟片上。厂商会将此类坏道列入工厂坏道表中，且完全隔离，不再使用。此类坏道被称为工厂坏扇区。 个人使用习惯不良例如频繁读写资料、计算机不当关机、强制断电等等都可能会使硬盘产生坏道。 电压不稳硬盘运作时，是依靠电流使盘片高速旋转，再用电流驱使磁头移动到盘片上产生磁场来达到读取及写入资料，若是电压不稳则会破坏盘片及磁头运作，导致坏道。 温度过高硬盘运作温度过高，造成控制电路过热，会损害硬盘正常工作。 物理损坏例如硬盘碰撞、震动、进水等，都可能会对硬盘产生损坏。 磁记录方式既然上文提到了磁盘坏扇区可能需要准备购买新的磁盘替换，如何选择磁盘又成了问题，并且近年来对存储性能要求的不断增加，使得大家意识到了机械硬盘的磁记录方式对存储性能的影响。最近几年，选购机械硬盘，常常会看到网上文章说 “千万不要选叠瓦盘” “性能差、易损坏” ，诸如此类说法。下面就简单介绍一下。 水平磁记录方式(LMR)机械硬盘的主要构造有马达、磁盘、磁头臂、磁头，硬盘运行的时候磁头悬浮在磁盘上方几纳米。水平磁记录的磁盘，磁性记录颗粒的易磁化方向相对于碟片是平行的，如下图所示。颗粒沿着碟片圆周以端对端排列，所以便有机会出现SS（南）和NN（北）的互斥排列。磁头上的读取磁头可以读取磁盘上磁粒的极性，磁粒极性向右的时候为1，极性向左的时候为0，这样来达到读取数据的目的。写碰头可以改变磁粒的极性，达到改写或定入数据的目的。 由于现今硬盘的资料记录区块大小已经发展到宽度只有30纳米左右，而磁性记录颗粒的尺寸不断下降，但硬盘容量倍数上升，导致出现电磁学上的超顺磁效应（超顺磁性），在室温的情况下颗粒便会对随机的热运动异常敏感，失去稳定性，导致出现比特（0和1）翻转的现象，记录的数据因此被破坏，大大降低了硬盘的容量提升潜力。 垂直磁记录方式(PMR)随着制造工艺的升级，写入磁头做的更小，出现了垂直磁记录，碰粒极性由原来的水平改为了垂直，极性向上为1，向下为0。垂直磁记录技术中的磁性记录颗粒的易磁化方向相对于碟片是垂直的，因此允许使用单极磁头配合磁记录介质下的软磁层对其所产生的镜像效应所产生的“间隙磁场”来将信息写入磁记录介质中，而纵向写入技术采用环形磁头在间隙处产生的杂散场来将信息写入，因此，采用具有相同饱和磁化强度的材料所制备的垂直写入磁头，能产生两倍于纵向写入磁头所能产生的磁场。更大的写入磁场允许我们使用具有更高磁各向异性的材料来制备磁记录介质，而磁各向异性越强，出现超顺磁性效应的临界体积就越小，因此，碟片中的存储密度可以在一定程度内得到进一步的提高。比如LMR水平磁记录磁盘的存储密度仅有133GB/平方英寸，而PMR垂直磁记录磁盘可以达到1108GB/平方英寸， 传统垂直磁记录(CMR)这种方式保留了以前PMR替代LMR时的传统技术，为了区别于叠瓦磁记录，这类磁记录方式被命名为CMR。 叠瓦磁记录(SMR)这几年在PMR磁盘下又出现了一个新的分支，那就是SMR瓦楞式堆叠(叠瓦磁记录)，利用了叠瓦磁道的原理，相对PMR可提高存储密度和每个驱动器的整体存储容量，但是写入性能却下降了。 为什么SMR磁盘性能比CMR磁盘性能下降了呢？在此之前需要先说明磁盘是如何工作的。 磁盘先验知识为了能精准的定位数据在磁盘的具体位置，磁盘被划分了无数个磁道，磁道又被划分成多个扇区。在读取数据的时候先定位数据所在的扇区的磁道的位置，磁头先摆动到数据所在的磁道的上方，然后等待着数据所在的扇区转过来，就可以读取数据了，这就是机械硬盘的寻道和寻址功能。 CMR工作原理由于物理原因，写磁头比读磁头宽，所以写磁头写入数据后再用读磁头读取数据时，只有读磁头扫过的中间部分是有效的。读磁头只需要窄窄数据带就可以读取数据了，但写入磁头无法做的再小了，所以磁道的上下方的空余部分其实是没用的。CMR磁盘为了保证写磁头不干扰到相邻磁道，通过写入彼此平行而不重叠的磁道来记录数据，如下图所示，磁道与磁道之间留出了一定的间隔，不过导致了数据密度变的低了，很多空间就被浪费了。 SMR工作原理而叠瓦磁记录技术的硬盘写入的新磁道则与先前写入的磁道部分重叠，从而使先前的磁道更窄，因此能拥有更高的磁道密度。由此可以看出，使用叠瓦磁技术的磁道相互重叠，与用作屋顶的瓦片堆叠方式类似。 因为读取头较小，因此SMR磁盘的读取与一般的PMR磁盘并无不同，但是写入就有很大区别了，由于叠瓦磁盘的磁道是堆叠在一起的，写磁头比较宽，所以写入数据的时候会把下面的磁道也一起写入，下一个磁道写入的时候覆盖了上一个磁道重复写入的数据的同时又把下一个磁道又重复写入了。依此类推把数据全部写入磁道。这样一来，改写某一磁道的数据势必会影响下一个磁道的数据，所以必须要有一个缓冲区先把下一磁盘的数据放入缓冲区，改写完目标数据后，再从把缓冲区把数据重新填回来，这样可能会写到下面的磁道中，这样一来需要重复刚才的动作，直到把所有覆盖的部分处理好。可以看到本来在CMR中写一次就可以完成的任务，放在SMR磁盘身上可能要写很多次，并且需要一个较大的缓存支持(一般SMR磁盘的缓存都是在256MB左右，CMR磁盘的缓存在64MB左右)。 当然要改写某一磁道的数据时并不是要把它后面所有的磁道都挨个重写，要不然如果是改写最外圈的磁道岂不是要把整个碟片全部重写！那样的话实在是太麻烦了。所以整个磁盘并不是从头到尾全部采用叠瓦技术的，而是以扇区为最大单位，每个扇区内的磁道都是叠瓦，各个扇区之间留有间隔、互不干扰。改写某一磁道数据只会影响所在扇区内的磁道，其它扇区不受影响。 SMR磁盘的优点及缺点优点： 体积减小。SMR瓦楞式堆叠磁盘由于采用了磁道堆叠技术，使得数据存储密度更高，同等容量的磁盘碟片数量更少，磁盘的体积会更小，更轻便。 价格便宜。因同等容量的磁盘碟片数量更少，也就大大减少了成本，所以价格上也会比CMR磁盘更便宜。 缺点： 随机写入慢。因改写磁道中间数据时会影响其它磁道的数据，改写一条磁道的数据需操作多次才能完成，大大增加了工作量，所以在改写数据时比CMR磁盘性能上有很大的差距，特别是剩余空间越少时读写越慢，慢到令人发指，而且在写入大文件超过缓存大小时，还会出现速度“断崖式”下降。 磁盘寿命短。磁盘读写的次数与其寿命是有关的，叠瓦盘在改写数据时进行的读写次数远超CMR磁盘，所以它的寿命相比CMR磁盘更短。 转速低导致读写都慢，CMR磁盘普遍是7200转，而到了叠瓦盘则变成了5400转，因为叠瓦盘数据密度变大，转速务必要降低，而转速直接影响读写速度，所以即便数据密度变大了由于转速的降低使其读写性能不增反降。 如何辨别CMR和SMR？至于怎么分辨SMR也很简单，选购机械硬盘的时候尽量选择7200转64MB缓存的，不要选5400转256缓存的就可以了。一般来说1TB内的硬盘都是CMR机械硬盘，2TB以上基本都是SMR叠瓦盘。 本应用在高容量HDD上的SMR技术近年来逐渐向1T、2T这种较低容量的硬盘靠近。而硬盘厂商们却对此闭口不提，消费者对此也不知情。西部数据(WD)、希捷(ST)、东芝(TOSHIBA)都曾在或仍在未标明磁盘是否使用 SMR 技术的情况下出售硬盘。这导致了很大的争议。而被曝出混用也是有用户因为在NAS中组RAID报错，经过挖掘之后才发现的，导致消费者投诉，主要硬盘品牌最终公布了使用 SMR 技术的硬盘产品型号并保证特定系列型号不使用 SMR 技术，其公布信息可以去品牌官网查询，或参考链接。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/"},{"name":"没啥用知识","slug":"杂谈/没啥用知识","permalink":"https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"没啥用知识","slug":"没啥用知识","permalink":"https://www.lollipopnougat.top/tags/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.lollipopnougat.top/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"快充协议如何工作","slug":"快充协议如何工作","date":"2022-11-10T16:34:00.000Z","updated":"2023-05-21T02:26:37.766Z","comments":true,"path":"2022/11/11/快充协议如何工作/","link":"","permalink":"https://www.lollipopnougat.top/2022/11/11/%E5%BF%AB%E5%85%85%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/","excerpt":"快充协议如何工作前几天跟朋友聊天谈到了网上有人使用非官方数据线和充电器给使用 USB Type-C 口的 iPad Pro 充电，结果导致 iPad 损坏的情况。联想到快充的方法无非是提高电压或提高电流，我们猜测与快充协议有关，于是去查了一下，找到一篇写得不错的文章，我们看完以后，感觉的确不应该随便混用不同品牌的充电头和充电线，如果错误使用可能会发生意想不到的事情。","text":"快充协议如何工作前几天跟朋友聊天谈到了网上有人使用非官方数据线和充电器给使用 USB Type-C 口的 iPad Pro 充电，结果导致 iPad 损坏的情况。联想到快充的方法无非是提高电压或提高电流，我们猜测与快充协议有关，于是去查了一下，找到一篇写得不错的文章，我们看完以后，感觉的确不应该随便混用不同品牌的充电头和充电线，如果错误使用可能会发生意想不到的事情。 鉴于我们并不是微电子行业的从业人员(计算机专业的学生而已)，这种知识可能也就是所谓“没啥用”知识了(以下省略“没啥用的知识又增加了.jpg”图)，不过感觉既然看到了，还是记录一下，或者干脆搞个“没啥用知识”系列，写点冷知识，感觉还不错？ 说干就干，下面转载这篇文章，作为没啥用知识系列的第一篇。 快充协议是如何工作的快充协议是充电器与设备沟通握手所需的“语言”，只有正确“对话”后，才可以“握手”成功，进行快速充电。我们一步一步来看不同的快充协议是怎样工作的。 旧式快充协议几年前快充协议十分简单，简单到类似交通信号灯，幼儿园小朋友都可以通过颜色判断信号含义。设备与充电器不需要很“聪明”就可以读懂双方的需求，不管是研发难度还是物料成本都简单便宜。而快充协议的红绿灯，则是采用D+D-电压进行信息传输。旧式快充协议都是使用USB2.0通讯接口，常见于USB-A接口。图片中是一个在移动电源上的USB-A输出母座，可以看到他与主板连接的只有四个引脚，其中两侧是用于传输电流的VCC、GND引脚，中间的是用于传输数据的D+、D-引脚。D+D-的“D”是数据Data的意思，充电端与接受电力的设备之间通过D+D-进行数据通讯，进而握手快充协议。 再来看看数据线，一般来说USB2.0数据线USB-A接口上只有4个触点，与USB-A母座定义相同，最外面两个是用来传输电流的，中间两个是用来传输数据的。VCC、GND较长，D+D-较短，那是故意设计，为了拔出时先断开数据连接，后断开电力供给。 APPLE 2.4A 在大家都是5V充电的年代，iPhone直接充电只有5W，需要充电器有特殊的识别电阻才可以获得更大充电功率。 图中PCB左边是两个USB-A输出口的焊盘，共用了一颗支持双路智能识别的协议芯片，iPhone插入后，协议芯片调整USB-A接口的D+D-电压为2.7V/2.7V，提供APPLE 2.4A的识别。而最右边的USB-A接口，则是简单地将D+D-直接连起来短接，提供DCP 5V1.5A的输出识别。 通过POWER-Z测试仪监测iPhone 8 Plus的充电，可以发现当前D+D-电压为2.66V/2.65V，接近APPLE2.4A识别协议的2.7V/2.7V，iPhone 8 Plus进入APPLE2.4A充电模式，功率达到12W。 QC2.0 进入QC2.0高压快充年代后，USB-A接口不再是简单的5V输出，而是可以升压至9V甚至12V电压获取大功率电力传输，这存在一定危险，什么情况才需要升压而不会烧坏设备？所以QC年代智能识别芯片做出了较大的进化，包含了多种不同快充协议，QC、FCP、AFC等等，同样是通过控制D+D-电压来进行轮询判断。例如QC2.0快充需要输出9V的话，D+D-电压就是3.3V/0.5V，需要输出12V的话，D+D-电压就调节为0.5v/0.5v，没有反馈就不进行升压，保持5V输出确保安全。 MTK PE 如果说QC2.0基于D+D-电压进行通讯的方式类似红绿灯的话，魅族手机采用的MTK PE快充则是类似打电报的摩尔密码，嘀——嘀嘀嘀——嘀嘀——嘀嘀嘀——嘀——嘀——这样进行通讯。PE快充不需要D+D-数据传输，甚至只有VCC GND的两芯数据线都可以成功使用并触发PE快充，并且PE的电流脉冲信号近乎于无损数字传输，不会像D+D-那样出现电压值误差无法触发快充的情况。 图中是POWER-Z USB测试仪抓取到魅族触发PE快充时的电流脉冲，可以看到电流的通断与间隔就像打电报一样进行信息传递，信息传递握手正确后，充电器输出电压从5V跳至7V再跳至9V。但PE快充太少众，市场占有率低没有话语权，配件选择面也少，甚至现在连魅族新机型都不再支持PE快充，这就是题外话了。 USB PD高级通讯协议在进入USB PD快充时代后，充电器与数码产品的物理接口从USB-A口全面过渡到USB-C接口，USB-C接口拥有更多的Pin脚，支持更高的电力传输上限，并且完全不同于以往简单的D+D-识别，而是智慧式数据包双向沟通的手段进行更加复杂的通讯。如果说旧式快充协议是幼儿园学生看红绿灯过马路的话，USB PD快充协议就是两个成年人在进行微信聊天这种复杂程度。 我们来先看看接口的区别，USB-C物理接口满pin形态高达24个针脚，但用于充电不管多大功率，都只要USB2.0形态的12个针脚就足够了，满pin多出来的针脚是用于跑USB3.0/3.1/3.2/雷电等高速数据的，与充电无关，下面我们重点介绍一下USB2.0标准pin脚的USB-C接口。 可以看到USB-C用于电力传输的VBUS、GND一共有两对也就是4根针脚，除了支持正反面盲插外，多了一倍的针脚让他可以支撑更大功率的电力传输。在接口的中间可以看到D+D-这两个USB-A标准上的针脚，所以USB-C可以向下兼容数据通讯。而USB PD最关键的是CC针脚，CC线是USB PD快速充电标准用于信息交换的通道，没有CC针脚的话就无法进行PD快充。一些魔改USB-A口，虽然形态是A口，但中间新增了一根针脚CC线，所以可以在A口上跑USB PD协议。 USB-C通讯采用可编程语言进行双向通讯，需要用到高性能USB PD控制器，芯片体积、针脚数量、复杂程度都远超QC年代的协议芯片。下面我们通过POWER-Z USB测试仪抓取充电器与手机之间的通讯包，看看在充电过程中发生了什么事情。 PD2.0 USB PD快速充电标准现在已经发展到PD 3.0，数字越大的版本所支持的功能越多，我们先看看PD2.0。PD2.0快充支持固定电压档切换，可以根据充电器广播选择需要的固定电压。POWER-Z USB测试仪上可以看到，设备与充电器通讯后从5V3A跳转到了9V3A这个电压档进行充电。 我们再通过POWER-Z电脑端APP抓包看看，信息端口栏目分别是两个方向的传输，Source—&gt;Sink、Source&lt;—Sink。其中Source—&gt;Sink是代表发射端向接收端发出的通讯，例如充电器对手机，Source&lt;—Sink是接收端反馈信息给发射端，例如手机对充电器，搞懂了方向那我们接下来就能看懂他们之间的通讯方式。 USB PD通讯流程我们以PD 2.0充电器作为举例，线缆插上后供电端与设备并不是立刻开始充电，而是先打招呼，充电器进行广播PDO电压，充电器告诉手机，我支持5V2.4A / 9V3A / 15V3A / 20V2.25A四个固定电压输出。 手机接收到PDO广播信息后，先是反馈给充电器，告知需要5V2.4A这个电压档，充电器收到反馈后回复手机，电力已经调整至5V2.4A。之后手机充电器再互相通讯，手机请求调整输出电压至9V2A，充电器告知请求已经收到，正在调整至9V2A，这样完成一个通讯阶段。 PD 3.0 PPS PD3.0 PPS与PD2.0相比原理接近，多了PPS电压子集。PPS电压子集是一组以0.02V跨度为调整幅度的供电电压集，可以精细地进行电压微调，让电荷泵快充、直充变成可能。 PD 3.0 PPS插入线缆后，充电器向手机发出一个数据包（PDO广播），告诉手机我是一个充电器，拥有5V3A / 9V3A / 12V3A / 15V3A / 20V2.25A四个固定PDO与5-11V3A / 5-16V3A两组PPS。手机接收到这个广播后，对充电器反馈信息，请求输出5V3A电压。充电器接受到电压调整请求，并告知手机已经调整OK，手机反馈说已经做好充电准备，开始5V3A进行充电。 在充电的途中，手机发出信息告知充电器，我需要调整电压，请求将输出电压调整至8.66V3A，充电器接收到电压调整请求，将输出从5V3A调整至8.66V3A。之后手机每秒发送多次调整电压指令，每次都告知充电器将电压下调0.02V，充电器也如实进行调整。 在经过了五百多次的通讯进行电压微调后，最终稳定在了7V3A这一个电压进行充电，以达到充的快温升低的目的，这就是PPS快充协议的通讯过程。 私有协议 全私有协议 某些厂家会对部分设备开发私有快充协议，在通讯过程中加密了信息流，用户想要获得最佳充电体验只能使用原厂配件。这种做法一来是因为目前的标准无法满足厂家需求，例如USB PD上限只有20V5A 100W，二来可以建设私有配件生态圈，足够的利润支撑技术研发达到良性发展，这么做无可厚非。 半私有协议 部分厂商则是采用半私有协议，例如三星45W AFC快充，基于PD3.0 PPS开发的快速充电协议进行微调修改，因为未进行加密，所以市面上部分第三方配件也可以通用，用户选择配件范围较大。 USB-C接口统一对快充的好处多年前接口未统一时，存在Micro USB、Mini USB、异形排针、DC圆口等多种不同接口，就连供电电压都存在差异，混沌的乱象阻碍着发展。USB-C好比灯泡卡座，淘汰其他接口大统一为USB-C接口标准，让万千设备均处以相同标准下运行，相同的物理接口，相同的通讯标准。生产商技术研发不再需要为各种标准而设计不同规格产品，快充技术得到飞速发展，用户作为消费者也在享受USB-C大统一的便利。 USB-C是灯泡卡座的话，充电器就好比灯泡，基于USB-C标准而制造的充电器诞生出18Ｗ、30Ｗ、45Ｗ、65Ｗ、100Ｗ以及未来更大功率，用户可以根据自己需求选择不同功率的产品使用，无需担心接口问题。 总结对于手机、笔记本等设备来说，快充协议必不可少，没有快充协议支撑的话充电功率会受限在非常低的功率，得益于USB-C统一标准让快充全面普及，不管是入门机型还是旗舰产品都支持快充，不同消费层用户都可以享受快充带来的乐趣。","categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/"},{"name":"没啥用知识","slug":"杂谈/没啥用知识","permalink":"https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"没啥用知识","slug":"没啥用知识","permalink":"https://www.lollipopnougat.top/tags/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.lollipopnougat.top/tags/%E6%9D%82%E8%B0%88/"}]},{"title":"Windows注册表的字段类型","slug":"Windows注册表的数据类型","date":"2021-06-14T03:46:51.000Z","updated":"2021-08-14T11:28:45.894Z","comments":true,"path":"2021/06/14/Windows注册表的数据类型/","link":"","permalink":"https://www.lollipopnougat.top/2021/06/14/Windows%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"介绍一下windows注册表的数据类型","text":"介绍一下windows注册表的数据类型 数据类型主要有6种(其实还有更多，但常用就6种吧) 二进制(REG_BINARY)在注册表中，二进制是没有长度限制的，可以是任意个字节的长度。 DWORD值(REG_DWORD)DWORD值是一个32位（4个字节，即双字）长度的数值。在注册表编辑器中，系统以十六进制的方式显示DWORD值。 字符串值(REG_SZ)在注册表中，字符串值一般用来表示文件的描述、硬件的标识等，通常它是以空字符(‘\\0’)结尾的字符串。 QWORD值(REG_QWORD)QWORD值是一个64位（8个字节，即四字）长度的数值。在注册表编辑器中，系统以十六进制的方式显示QWORD值。 多字符串值(REG_MULTI_SZ)由两个空字符终止的空终止字符串数组。 可扩充字符串值(REG_EXPAND_SZ)包含对环境变量的未扩展引用的空终止字符串（例如，“%PATH%”）。 代码相关这个其实是写上次那个jdk部署工具的过程中遇到的问题， 一般的方法取可扩充字符串的值结果都会自动填写环境变量实际的值，而想要的功能是注册表的可扩充字符串值如何不自动扩展环境变量 由于 .net 封装的注册表未提供此方面的方法，因此采用 C# 调 winapi 的方法解决 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 读取注册表值[DllImport(&quot;advapi32.dll&quot;, SetLastError = true)]static extern uint RegQueryValueEx( UIntPtr hKey, string lpValueName, int lpReserved, ref RegistryValueKind lpType, IntPtr lpData, ref int lpcbData);// 打开注册表键[DllImport(&quot;advapi32.dll&quot;, CharSet = CharSet.Auto)]public static extern int RegOpenKeyEx( UIntPtr hKey, string subKey, int ulOptions, int samDesired, out UIntPtr hkResult);// 关闭注册表键 因为是非托管内存，GC不会自动回收，一定需要手动释放掉注打开册表键的句柄[DllImport(&quot;advapi32.dll&quot;, SetLastError = true)]public static extern int RegCloseKey(UIntPtr hKey);private static readonly UIntPtr HKEY_LOCAL_MACHINE = new UIntPtr(0x80000002u);private static readonly int READ_FLAG_MASK = 0x20019;public string GetLMNamedValue(string valName, string regPath) &#123; UIntPtr hKey = UIntPtr.Zero; IntPtr pResult = IntPtr.Zero; try &#123; if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, regPath, 0, READ_FLAG_MASK, out hKey) == 0) &#123; int size = 0; RegistryValueKind type = RegistryValueKind.Unknown; // 获取需要的缓冲区大小 uint retVal = RegQueryValueEx(hKey, valName, 0, ref type, IntPtr.Zero, ref size); if (size == 0) &#123; return null; &#125; // Marshal 提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在与非托管代码交互时使用的其他杂项方法。 pResult = Marshal.AllocHGlobal(size); retVal = RegQueryValueEx(hKey, valName, 0, ref type, pResult, ref size); if (retVal != 0) &#123; throw new ApplicationException($&quot;查询错误 &#x27;&#123;regPath&#125;\\\\&#123;valName&#125;: 0x&#123;Marshal.GetLastWin32Error().ToString(&quot;x2&quot;)&#125;, 返回: &#123;retVal&#125;&quot;); &#125; else &#123; switch (type) &#123; case RegistryValueKind.String: return Marshal.PtrToStringAnsi(pResult); case RegistryValueKind.DWord: return Marshal.ReadInt32(pResult).ToString(); case RegistryValueKind.QWord: return Marshal.ReadInt64(pResult).ToString(); case RegistryValueKind.ExpandString: // 直接输出原始内容 return Marshal.PtrToStringAnsi(pResult); &#125; &#125; &#125; else &#123; throw new ApplicationException($&quot;打开注册表键错误 HKLM\\\\&#123;regPath&#125;: &#123;Marshal.GetLastWin32Error().ToString(&quot;1:x&quot;)&#125;&quot;); &#125; &#125; finally &#123; if (hKey != UIntPtr.Zero) &#123; RegCloseKey(hKey); &#125; if (pResult != IntPtr.Zero) &#123; Marshal.FreeHGlobal(pResult); &#125; &#125; return null; &#125;","categories":[{"name":"win32","slug":"win32","permalink":"https://www.lollipopnougat.top/categories/win32/"},{"name":"注册表","slug":"win32/注册表","permalink":"https://www.lollipopnougat.top/categories/win32/%E6%B3%A8%E5%86%8C%E8%A1%A8/"}],"tags":[{"name":"win32","slug":"win32","permalink":"https://www.lollipopnougat.top/tags/win32/"},{"name":"注册表","slug":"注册表","permalink":"https://www.lollipopnougat.top/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"}]},{"title":"自己写个jdk部署工具","slug":"自己写个jdk部署工具","date":"2021-06-05T14:58:17.000Z","updated":"2021-08-14T11:19:44.434Z","comments":true,"path":"2021/06/05/自己写个jdk部署工具/","link":"","permalink":"https://www.lollipopnougat.top/2021/06/05/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AAjdk%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/","excerpt":"使用.NET 5的 C# 编写了个jdk部署工具 自动用aria2下载jdk16 检查下载文件完整性(sha-256) 支持java环境变量配置","text":"使用.NET 5的 C# 编写了个jdk部署工具 自动用aria2下载jdk16 检查下载文件完整性(sha-256) 支持java环境变量配置 项目类 环境变量管理类 http辅助类 aria2辅助类 Json请求格式类 Zip文件辅助类 完整性检测辅助类 原理本项目采用 C# 采用rpc控制 aria2 下载jdk16，经检测解压后配置环境变量 rpc实际控制方法为向 aria2 发起 post 请求，然后 aria2 接收回复 流程 构造请求调用的json数据 使用aria2辅助类启动 aria2 主程序 发起下载请求 每 500ms 检查一次 aria2 返回的状态，如果下载结束继续进行，否则持续检查 下载完成检查文件 SHA256 与给出的是否一致，不一致给出提示退出 使用zip辅助类解压jdk的压缩包 通过环境变量管理类设置环境变量 难点 此程序与aria2两进程间通信(rpc) http POST方法的C#实现 SHA-256算法 注册表的可扩充字符串值自动填充环境问题 待更新","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"CSharp","slug":"编程语言/CSharp","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/"}],"tags":[{"name":"win32","slug":"win32","permalink":"https://www.lollipopnougat.top/tags/win32/"},{"name":"注册表","slug":"注册表","permalink":"https://www.lollipopnougat.top/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"}]},{"title":"python包的setup文件","slug":"python包的setup文件","date":"2021-01-12T07:27:04.000Z","updated":"2021-08-14T10:04:22.667Z","comments":true,"path":"2021/01/12/python包的setup文件/","link":"","permalink":"https://www.lollipopnougat.top/2021/01/12/python%E5%8C%85%E7%9A%84setup%E6%96%87%E4%BB%B6/","excerpt":"鸽了一年，突然想起来我还有个博客正好最近写了个超级简陋的 pypi 源管理工具，学习了一波setup.py文件的撰写","text":"鸽了一年，突然想起来我还有个博客正好最近写了个超级简陋的 pypi 源管理工具，学习了一波setup.py文件的撰写 介绍python开发者们习惯使用 pip 来安装一些第三方模块，这个安装过程之所以简单，是因为模块开发者写好了模块的setup.py，而这个文件负责的过程就是 打包。 打包，就是将你的源代码进一步封装，并且将所有的项目部署工作都事先安排好，这样使用者拿到后安装即可用，不用再操心如何部署的问题。 setuptoolssetuptools 是官方提供的一个专业用于包分发的工具，是对包的分发很有用处，定制化程序非常高。 源码包与二进制包Python 包的分发可以分为两种： 以源码包的方式发布源码包安装的过程，是先解压，再编译，最后才安装，所以它是跨平台的，由于每次安装都要进行编译，相对二进包安装方式来说安装速度较慢。 源码包的本质是一个压缩包，其常见的格式有：zip, tar, tar.gz, tar.bz2 等 以二进制包形式发布二进制包的安装过程省去了编译的过程，直接进行解压安装，所以安装速度较源码包来说更快。由于不同平台的二进制文件无法通用，所以在发布时，有时可能需编译多个平台的包（当然如果使用whl也可以做到跨平台使用）。 二进制包的常见格式有：egg, wheel(whl) setup.py文件结构打包分发最关键的一步是编写 setup.py 文件。以下是我项目使用的 setup.py 示例 123456789101112131415161718192021222324252627282930313233from setuptools import setup, find_packagesimport pimmfrom os import paththis_directory = path.abspath(path.dirname(__file__))long_description = Nonewith open(path.join(this_directory, &#x27;README.md&#x27;), encoding=&#x27;utf-8&#x27;) as f: long_description = f.read()setup(name=&#x27;pimm&#x27;, # 包名称 packages=[&#x27;pimm&#x27;], # 需要处理的包目录 version=&#x27;0.0.5&#x27;, # 版本 classifiers=[ &#x27;Development Status :: 3 - Alpha&#x27;, &#x27;License :: OSI Approved :: MIT License&#x27;, &#x27;Programming Language :: Python&#x27;, &#x27;Intended Audience :: Developers&#x27;, &#x27;Operating System :: OS Independent&#x27;, &#x27;Programming Language :: Python :: 3.5&#x27;, &#x27;Programming Language :: Python :: 3.6&#x27;, &#x27;Programming Language :: Python :: 3.7&#x27;, &#x27;Programming Language :: Python :: 3.8&#x27;, &#x27;Programming Language :: Python :: 3.9&#x27; ], install_requires=[&#x27;ping3&#x27;], entry_points=&#123;&#x27;console_scripts&#x27;: [&#x27;pmm=pimm.pimm_module:main&#x27;]&#125;, package_data=&#123;&#x27;&#x27;: [&#x27;*.json&#x27;]&#125;, auth=&#x27;lollipopnougat&#x27;, # 作者 author_email=&#x27;lollipopnougat@126.com&#x27;, # 作者邮箱 description=&#x27;pypi mirrors manager&#x27;, # 介绍 long_description=long_description, # 长介绍，在pypi项目页显示 long_description_content_type=&#x27;text/markdown&#x27;, # 长介绍使用的类型，我使用的是md url=&#x27;https://github.com/lollipopnougat/pimm&#x27;, # 包主页，一般是github项目主页 license=&#x27;MIT&#x27;, # 协议 keywords=&#x27;pimm source manager&#x27;) # 关键字 搜索用 可以看到 setup.py 调用了 setuptools 包中的setup方法，下面解释一下各个参数的含义 程序分类信息classifiers 参数说明包的分类信息，接收一个 string 列表 发展时期 Development Status :: 1 - Planning Development Status :: 2 - Pre-Alpha Development Status :: 3 - Alpha Development Status :: 4 - Beta Development Status :: 5 - Production/Stable … 开发目标用户 Intended Audience :: Customer Service Intended Audience :: Developers Intended Audience :: Education Intended Audience :: End Users/Desktop Intended Audience :: Financial and Insurance Industry Intended Audience :: Healthcare Industry … 目标编程语言 Programming Language :: Basic Programming Language :: C Programming Language :: C# Programming Language :: C++ … Programming Language :: Python :: 3.4 Programming Language :: Python :: 3.5 Programming Language :: Python :: 3.6 Programming Language :: Python :: 3.7 Programming Language :: Python :: 3.8 Programming Language :: Python :: 3.9 … 该字段所有支持的值Intended Audience list 文件分发安装过程中，需要安装的静态文件，如配置文件、图片等可以使用 data_files 参数，接收一个字典参数 字典的键表示部署后文件的存放位置(目标机器)，空字符串表示放在包的根目录 此外需要再准备一个 MANIFEST.in 文件与 setup.py 同级, 来控制文件的分发 一个demo 所有根目录下的以 txt 为后缀名的文件，都会分发 根目录下的 examples 目录 和 txt、py文件都会分发 路径匹配上 examples/sample?/build 不会分发 123include *.txtrecursive-include examples *.txt *.pyprune examples&#x2F;sample?&#x2F;build 依赖包使用 install_requires 参数指定安装依赖，表明当前模块使用时依赖哪些包，若环境中没有，则会从pypi中下载安装, 此参数接收一个 string 列表 使用 tests_require 参数指定测试依赖，仅在测试时需要使用的依赖，在正常发布的代码中是没有用到的，此参数接收一个 string 列表 使用 extras_require 参数指定可选的依赖，此参数接收一个 string 列表 生成可执行文件的分发123456789# 用来支持自动生成脚本，安装后会自动生成 /usr/bin/pmm 的可执行文件(windows管理员权限下会在Python文件夹的script里面生成pmm.exe)# 该文件入口指向 pimm/pimm_module.py 的main 函数entry_points=&#123;&#x27;console_scripts&#x27;: [&#x27;pmm=pimm.pimm_module:main&#x27;]&#125;,# 将 bin/foo.sh 和 bar.py 脚本，生成到系统 PATH中# 执行 python setup.py install 后# 会生成 如 /usr/bin/foo.sh 和 如 /usr/bin/bar.pyscripts=[&#x27;bin/foo.sh&#x27;, &#x27;bar.py&#x27;] 使用 setup.py 构建包 构建源码发布包 用于发布一个 Python 模块或项目，将源码打包成 tar.gz 或者 zip 压缩包 12python setup.py sdist # 打包，默认tar.gzpython setup.py sdist --formats=gztar,zip # 打包，指定压缩格式 构建二进制分发包 在windows中我们习惯了双击 exe 进行软件的安装，Python 模块的安装也同样支持 打包成 exe 这样的二进制软件包 1python setup.py bdist_wininst 若你的项目，需要安装多个平台下，既有 Windows 也有 Linux，按照上面的方法，多种格式我们要执行多次命令，为了方便，你可以一步到位，执行如下这条命令，即可生成多个格式的进制 1python setup.py bdist 构建 wheel 包 1python setup.py sdist bdist_wheel 使用 setup.py 安装包1python setup.py install 如若你的项目还处于开发阶段，频繁的安装模块，也是一个麻烦事。 这时候可以使用下面这条命令安装，该方法不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。 1python setup.py develop 发布包到 PyPi若你觉得自己开发的模块非常不错，想要 share 给其他人使用，你可以将其上传到 PyPi （Python Package Index）上，它是 Python 官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包 如果要发布自己的包，需要先到 pypi 上注册账号。然后创建 ~/.pypirc(windows C:/User/yourname/.pypirc) 文件，此文件中配置 PyPI 访问地址和账号。.pypirc文件内容请根据自己的账号来修改 典型的 .pypirc 文件123456[distutils]index-servers = pypi[pypi]username:xxxpassword:xxx 上传1setup.py sdist upload 想更省劲的话可以考虑安装 twine，然后使用 twine 上传，这个还可以上传whl文件 1twine upload dist/* # 上传dist下的所有文件 pypi 好像不能覆盖文件，要上传新的需要修改版本号 上传以后就可以使用pip下载自己的包了，顺便清华源是10分钟更新一次，所以说10分钟后清华的pypi源就能找到自己的包了","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Python","slug":"编程语言/Python","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lollipopnougat.top/tags/python/"},{"name":"pip","slug":"pip","permalink":"https://www.lollipopnougat.top/tags/pip/"}]},{"title":"肺炎疫情信息的获取","slug":"肺炎疫情信息的获取","date":"2020-02-05T02:47:53.000Z","updated":"2021-08-14T10:04:49.498Z","comments":true,"path":"2020/02/05/肺炎疫情信息的获取/","link":"","permalink":"https://www.lollipopnougat.top/2020/02/05/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96/","excerpt":"python 爬虫相关也算是练习一下好久没写的爬虫了","text":"python 爬虫相关也算是练习一下好久没写的爬虫了 最近病毒肆虐，丁香园为了方便大众得知最新消息，开设了一个网页,可以从中得知当前的最新感染数据信息，笔者在浏览此页面后看到数据是以 json 格式送到浏览器的，觉得不妨写一个爬虫获取数据写入文件来进行统计… 爬取到的网页关键数据(全国)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script id=&quot;getStatisticsService&quot;&gt; try &#123; window.getStatisticsService = &#123; id: 1, createTime: 1579537899000, modifyTime: 1580795061000, infectSource: &#x27;该字段已替换为说明2&#x27;, passWay: &#x27;该字段已替换为说明3&#x27;, imgUrl: &#x27;https://img1.dxycdn.com/2020/0201/450/3394153392393266839-135.png&#x27;, dailyPic: &#x27;https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png,https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png,https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png,https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png,https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png&#x27;, dailyPics: [ &#x27;https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png&#x27;, &#x27;https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png&#x27;, &#x27;https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png&#x27;, &#x27;https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png&#x27;, &#x27;https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png&#x27; ], summary: &#x27;&#x27;, deleted: false, countRemark: &#x27;&#x27;, confirmedCount: 20471, suspectedCount: 23214, curedCount: 657, deadCount: 426, seriousCount: 2788, suspectedIncr: 5072, confirmedIncr: 3235, curedIncr: 182, deadIncr: 65, seriousIncr: 492, virus: &#x27;该字段已替换为说明1&#x27;, remark1: &#x27;易感人群：人群普遍易感。老年人及有基础疾病者感染后病情较重，儿童及婴幼儿也有发病&#x27;, remark2: &#x27;潜伏期：一般为 3～7 天，最长不超过 14 天，潜伏期内存在传染性&#x27;, remark3: &#x27;宿主：野生动物，可能为中华菊头蝠&#x27;, remark4: &#x27;&#x27;, remark5: &#x27;&#x27;, note1: &#x27;病毒：新型冠状病毒 2019-nCoV&#x27;, note2: &#x27;传染源：新型冠状病毒感染的肺炎患者&#x27;, note3: &#x27;传播途径：经呼吸道飞沫传播，亦可通过接触传播，存在粪-口传播可能性&#x27;, generalRemark: &#x27;疑似病例数来自国家卫健委数据，目前为全国数据，未分省市自治区等&#x27;, abroadRemark: &#x27;&#x27;, marquee: [] &#125; &#125; catch (e) &#123;&#125;&lt;/script&gt; 爬取到的网页关键数据(各省，局部)123456789101112131415161718192021222324252627try &#123; window.getAreaStat = [ &#123; provinceName: &#x27;湖北省&#x27;, provinceShortName: &#x27;湖北&#x27;, confirmedCount: 13522, suspectedCount: 0, curedCount: 398, deadCount: 414, comment: &#x27;待明确地区，治愈 96&#x27;, locationId: 420000, cities: [ &#123; cityName: &#x27;武汉&#x27;, confirmedCount: 6384, suspectedCount: 0, curedCount: 307, deadCount: 313, locationId: 420100 &#125;, &#123; // 以下省略n个城市 &#125; ] &#125; ]&#125; 如何从爬取的字符串中获取数据经过一番分析，最终使用了正则和 BS 库获取了 json 字符串，剩下的就很好处理了。 12345678910pat1 = re.compile(&#x27;(\\[[^\\]]+?\\])&#x27;)#原本写的是 pat2 = re.compile(&#x27;(\\&#123;[^\\&#125;\\&#123;]+?\\&#125;)&#x27;) 但丁香园发布了一条特殊格式的数据后不能用了，于是就换成了下面那个pat2 = re.compile(&#x27;=\\s?(\\&#123;.+)\\&#125;catch&#x27;)dat1 = str(soup.findAll(id=&#x27;getListByCountryTypeService1&#x27;)[0].string)dat2 = str(soup.findAll(id=&#x27;getStatisticsService&#x27;)[0].string)# 各省st1 = pat1.findall(dat1)[0]# 全国st2 = pat2.findall(dat2)[0] 附赠一个可以显示目前各省累计确诊人数占全国比例的爬虫 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import requests as reqfrom bs4 import BeautifulSoup as bsimport reimport jsonimport csvimport matplotlib.pyplot as pltimport matplotliburl = &#x27;https://ncov.dxy.cn/ncovh5/view/pneumonia_peopleapp&#x27;header = &#123; &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#x27;&#125;pat1 = re.compile(&#x27;(\\[[^\\]]+?\\])&#x27;)pat2 = re.compile(&#x27;=\\s?(\\&#123;.+)\\&#125;catch&#x27;)def task(): res = req.get(url=url, headers=header) print(res.status_code) res.encoding = res.apparent_encoding soup = bs(res.text, &#x27;html.parser&#x27;) dat1 = str(soup.findAll(id=&#x27;getListByCountryTypeService1&#x27;)[0].string) dat2 = str(soup.findAll(id=&#x27;getStatisticsService&#x27;)[0].string) st1 = pat1.findall(dat1)[0] st2 = pat2.findall(dat2)[0] js = json.loads(st1) al = json.loads(st2) prov_list = [] conf_list = [] for i in js: print(&#x27;%s 确诊数： %d， 治愈数： %d， 死亡数: %d&#x27; % (i[&#x27;provinceName&#x27;], i[&#x27;confirmedCount&#x27;], i[&#x27;curedCount&#x27;], i[&#x27;deadCount&#x27;])) prov_list.append(i[&#x27;provinceName&#x27;]) conf_list.append(i[&#x27;confirmedCount&#x27;]) print(&#x27;全国确诊： %d， 疑似数： %d， 治愈数： %d， 死亡数： %d， 重症数： %d&#x27; % (al[&#x27;confirmedCount&#x27;], al[&#x27;suspectedCount&#x27;], al[&#x27;curedCount&#x27;], al[&#x27;deadCount&#x27;], al[&#x27;seriousCount&#x27;])) # 调用 matplotlib 准备绘图 font = &#123;&#x27;family&#x27;: &#x27;MicroSoft YaHei&#x27;, &#x27;weight&#x27;: &#x27;light&#x27;, &#x27;size&#x27;: 10&#125; matplotlib.rc(&quot;font&quot;, **font) fig = plt.figure(figsize=(10, 9), dpi=80) fig.canvas.set_window_title(&#x27;全国各省感染人数占比&#x27;) plt.axes(aspect=1) # 饼图 plt.pie(x=conf_list, labels=prov_list, autopct=&#x27;%3.1f %%&#x27;, pctdistance=1.2, labeldistance=1.0) plt.title(&#x27;全国各省感染人数占比&#x27;) plt.legend() plt.show() input(&#x27;任意键继续&#x27;)if __name__ == &quot;__main__&quot;: task() 后记完成整个脚本以后配置一下计划任务，再添加一个每一小时获取一次写入文件功能，省了不少事…其实还可以通过异步维护一个计时器，每隔一段时间运行一次(好像单线程就是用 sleep 也可以吧，嘛不管了)","categories":[{"name":"爬虫开发","slug":"爬虫开发","permalink":"https://www.lollipopnougat.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"爬虫开发/python","permalink":"https://www.lollipopnougat.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.lollipopnougat.top/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.lollipopnougat.top/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"最近忙的很","slug":"最近忙的很","date":"2019-12-03T13:10:21.000Z","updated":"2021-04-25T09:02:11.200Z","comments":true,"path":"2019/12/03/最近忙的很/","link":"","permalink":"https://www.lollipopnougat.top/2019/12/03/%E6%9C%80%E8%BF%91%E5%BF%99%E7%9A%84%E5%BE%88/","excerpt":"最近事还挺多的…也没顾的上更新博客","text":"最近事还挺多的…也没顾的上更新博客 等到课近期的设完成大概就有时间了吧…今天先鸽了，，，咕咕咕","categories":[{"name":"吐槽","slug":"吐槽","permalink":"https://www.lollipopnougat.top/categories/%E5%90%90%E6%A7%BD/"}],"tags":[{"name":"吐槽","slug":"吐槽","permalink":"https://www.lollipopnougat.top/tags/%E5%90%90%E6%A7%BD/"}]},{"title":"网络安全协会网站的搭建(一)","slug":"网络安全协会网站的搭建(1)","date":"2019-09-06T15:20:37.000Z","updated":"2021-04-26T07:25:15.857Z","comments":true,"path":"2019/09/06/网络安全协会网站的搭建(1)/","link":"","permalink":"https://www.lollipopnougat.top/2019/09/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA(1)/","excerpt":"网络安全协会网站的搭建一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊特别是看了ACM协会的网站之后，更加坚定了开发的想法所以这个项目就出现了 网站预览","text":"网络安全协会网站的搭建一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊特别是看了ACM协会的网站之后，更加坚定了开发的想法所以这个项目就出现了 网站预览 Vue.js 与 Node.js Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 早就在关注尤雨溪大佬和他的Vue.js项目。 今年年初曾尝试搞了一个demo，结果最后搞的一头雾水，也没弄懂…最终结果就是弃了… 直到今年5月份我准备做数据库课设，才算稍微系统地学习了一下 Node.js，用 Express 熟悉了一下 Node 的项目结构和使用 npm 的方法，顺便提高了js的开发能力。我也学到了 js 的异步回调什么的，还有编写 HTML 和 CSS 的熟练度也得到了少许提高，暑假时又学习了一部分 TypeScript 和 ES6 的语法，勉强算是做了较多的铺垫。 这两天重新看 vue 的项目的时候终于明白那都是什么东西了，有点 Express 的感觉，但是 router 竟然可以 build 成静态的，默认采用的是 Hash 方式，一个网站可以做成单页的，有趣啊！ 于是9月1日建立了项目仓库，9月3日提交了研究了两天的结果(一个 Header )，因为将来要放到新GitHub账号上，build出来的静态文件有开 Http 服务的要求，因此我专门开了我GitHub的托管根目录做预览，这周前前后后一共提交了7次，之后就正式迁移到 chdans.github.io 了，我修改了结构，我build好的项目提交到我fork出来的 chdans 创建的那个静态页项目下，然后再新建 Pull Request，提交到 chdans，再由 chdans来 Merge 请求，这就是一次完整的更新。 不得不说element ui做的真的既简介又漂亮，原版的配色我是很喜欢的，我一度把协会的宣传海报也采用相同配色，如图 之后会详细解释这个网站项目 今天就写这么多，明天还要迎新，7点就要去…","categories":[{"name":"前端","slug":"前端","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://www.lollipopnougat.top/tags/Vue-js/"},{"name":"网站搭建","slug":"网站搭建","permalink":"https://www.lollipopnougat.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"网络安全协会","slug":"网络安全协会","permalink":"https://www.lollipopnougat.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A/"}]},{"title":"PowerShell入门指南(3)","slug":"PowerShell入门指南(3)","date":"2019-07-29T01:56:12.000Z","updated":"2021-04-25T15:24:47.976Z","comments":true,"path":"2019/07/29/PowerShell入门指南(3)/","link":"","permalink":"https://www.lollipopnougat.top/2019/07/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(3)/","excerpt":"PowerShell入门指南(三)·一门新的编程语言 作为独立的编程语言作为一门独立的语言来说，PowerShell 是非常地Powerful，我们先来了解一下它的特点:","text":"PowerShell入门指南(三)·一门新的编程语言 作为独立的编程语言作为一门独立的语言来说，PowerShell 是非常地Powerful，我们先来了解一下它的特点: 特点 破天荒的方便诸如存储计算中 GB， MB， KB 单位等；数组声明中的 1..n 和下标为 -1 的处理；还有所见即所得，通俗易懂的动词+名词结构的Cmdlet(PowerShell命令的称呼)。还有自带的文档支持也很是丰富，只要熟练掌握 Get-Help 命令，其他命令的用法均可通过 Get-Help 查到 面向对象良心啊，这个语言竟然是面向对象的与面向过程相比，面向对象更方便更容易描述现实世界，也算赶上了时髦。 依托 .NET正所谓大树下面好乘凉，PowerShell 绑上 .NET 这个大款了，借助 .NET 平台强大的类库，几乎让一切都成为可能。 强大的兼容性完全兼容 Windows 平台上其它调用，如可执行文件(exe)，批处理bat/cmd和VBscript等, 在 Linux 和 macOS 上也能很好地工作。 基于平台的可扩展性微软有个优点，与应用相比，它更喜欢做平台。PowerShell 早已变成一个平台，在 PowerShell 刚发布的第二年，微软的 System Center Operations Manager 和 SharePoint 就提供了针对该平台的组件，后来的活动目录，Hyper-V，Windows Azure，Office 365就更不用说了。除了微软，亚马逊的云平台管理，Dell的out-of-hand 管理，也都提供了基于 PowerShell 的管理组件。PowerShell 俨然变成了一个标准，变成了一个规范。 使用Get-Help 快速入门下面用一个简单例子说明如何Get-Help，设想这样一个场景：你想通过命令行查看所有进程，你第一个反应应该是用一个跟Process相关的命令来达到此目的，所以你可以会尝试执行： 1234567891011Get-Command *Process#结果CommandType Name Version Source----------- ---- ------- ------Cmdlet Debug-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Enter-PSHostProcess 3.0.0.0 Microsoft.PowerShell.CoreCmdlet Exit-PSHostProcess 3.0.0.0 Microsoft.PowerShell.CoreCmdlet Get-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Start-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Stop-Process 3.1.0.0 Microsoft.PowerShell.ManagementCmdlet Wait-Process 3.1.0.0 Microsoft.PowerShell.Management 得知处理进程的命令有这些然后再用 Get-Help Get-Process -full 就能得到 Get-Process 的详细用法以及使用范例 基本语法背景PowerShell 是一个强类型(变量一旦定义，其本身类型不可改变就是强类型，反之就是弱类型)的动态脚本语言，支持面向对象，支持调用系统API和 .NET 库。受到了 Python, Ksh, Perl, C#, CL, DCL, SQL, Tcl, Tk, Chef, Puppet 等语言的影响，结合了以上语言的部分特性。 PowerShell 代码的外观和操作方式与C#的相似程度最高，不过也有它自己的特色。 关于空白字符与 Python 等语言不同，**PowerShell 的解释器不会考虑代码中的空格或制表符**(这些字符统称空白字符)。这样一来，格式化代码就有很大的自由度，但是遵循某些规则将有助于提高代码的可读性。 代码块和代码基本结构PowerShell 代码由一系列语句构成，每条语句可以使用一个分号结束，当然也可以不写。按照习惯是不写分号的，因此要用换行来区分不同的语句，如果必须写到一行中，那就在每一句后加个分号。 和C语系的大多数语言类似，PowerShell 是一种块结构的语言，这些块用 &#123; 和 &#125; 来界定，代码块可以包含任意多条语句，或者不包含任何语句，下面的示例还使用了缩进格式，这样能大大提高可读性，实际上编译器会自带缩进代码。一般情况下，每个代码块都有自己的缩进级别，代码块之间还能嵌套。 123456789&#123; &lt;#代码行1#&gt; &lt;#代码行2#&gt; &#123; &lt;#代码行3#&gt; &lt;#代码行4#&gt; &#125; &lt;#代码行5#&gt;;&lt;#代码行6#&gt;;&#125; 当然 PowerShell 的缩进不是强制的。 在 PowerShell 代码中，另一种常见的语句是注释，注释并不是能执行的语句，而是对代码的描述说明性文本。当代码运行时，解释器会忽略这些内容。代码最好有注释，特别是处理较复杂的工作时，注释可以为正在进行的操作添加提示，例如“这行代码要求用户输入一个字符”、“此段代码是 LNP 编写的”。PowerShell 有两种添加注释方法 行注释: # 块注释: &lt;# 和 #&gt; 1234567891011#这是一行注释&lt;#这是注释块123ABC#&gt;ls #列出当前目录下的文件和文件夹，是Get-ChildItem的别名#注意下面语句会产生错误&lt;#块注释由&quot;#&gt;&quot;结尾#&gt; 第一个 #&gt; 后面的部分会被认为是 PowerShell 代码，因此出现错误。 还有特别的注意一点，**PowerShell 代码是不区分大小写的**，因此只要拼写正确的命令(或变量)，而无需关心大小写即可执行，不过最好还是有一定规范。 PowerShell 脚本的基本结构PowerShell 像 Python 一样，允许使用控制台直接输入命令进行交互，也可以事先把代码写入一个文件再作为脚本运行。一个 PowerShell 脚本仅仅是一个包含 PowerShell 代码的文本文件。如果这个文本文件执行， PowerShell 解释器会逐行解释并执行它的的语句。PowerShell 脚本有点像以前 CMD 控制台上的批处理文件。可以通过非常简单的文本编辑工具创建 PowerShell 脚本。 PowerShell脚本文件的扩展名是 .ps1 执行策略限制PowerShell 一般初始化情况下都会禁止脚本执行。脚本能否执行取决于PowerShell的执行策略。 12345678PS E:&gt; ./MyScript.ps1无法加载文件 E:MyScript.ps1，因为在此系统中禁止执行脚本。有关详细信息，请参阅 &quot;get-help about_signing&quot;。所在位置 行:1 字符: 15+ .MyScript.ps1 &lt; &lt;&lt;&lt; + CategoryInfo : NotSpecified: (:) [], PSSecurityException + FullyQualifiedErrorId : RuntimeException 只有管理员才有权限更改这个策略。非管理员会报错。 查看脚本执行策略，可以通过在 PowerShell 控制台直接输入:Get-ExecutionPolicy更改脚本执行策略，可以管理员启动PowerShell，在控制台输入:Set-ExecutionPolicy &lt;策略&gt;策略|解释-|-Unrestricted|权限最高，可以不受限制执行任何脚本。Default|为Powershell默认的策略，即RestrictedRestricted|不允许任何脚本执行AllSigned|所有脚本都必须经过签名才能在运行RemoteSigned|本地脚本无限制，但是对来自网络的脚本必须经过签名 如果要使用脚本功能又要兼顾安全性，我们就选择RemoteSigned即在以管理员身份允许的 PowerShell 输入Set-ExecutionPolicy RemoteSigned 123执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临 about_Execution_Policies帮助主题中所述的安全风险。是否要更改执行策略?[Y] 是(Y) [N] 否(N) [S] 挂起(S) [?] 帮助 (默认值为“Y”): y 运行 PowerShell 脚本当您的脚本编写成功后您可能第一次会像下面的方式运行它，也就是只输入脚本的文件名，会报错。 1234567891011PS E:&gt; MyScript.ps1无法将“MyScript.ps1”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后重试。所在位置 行:1 字符: 13+ MyScript.ps1 &lt; &lt;&lt;&lt; + CategoryInfo : ObjectNotFound: (MyScript.ps1:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundExceptionSuggestion [3,General]: 未找到命令 MyScript.ps1，但它确实存在于当前位置。Windows PowerShell 默认情况下不从当前位置加载命令。如果信任此命令，请改为键入 &quot;./MyScript.ps1&quot;。有关更多详细信息，请参阅 &quot;get-help about_Command_Precedence&quot;。 解决办法很简单，如果脚本在当前工作目录，请在脚本文件明前添加./，或者使用绝对路径。 12345678910111213PS E:&gt; .\\MyScript.ps12019年3月27日 18:33:03C:\\Program Files\\Common Filesfiles count20PS E:&gt; E:MyScript.ps12019年3月27日 18:33:11C:\\Program Files\\Common Filesfiles count20 通过重定向创建脚本如果想要执行的脚本不是很长，我们甚至可以直接在控制台中要执行的语句重定向给一个脚本文件。 123PS E:&gt; &#x27;&quot;Hello,World!&quot;&#x27; &gt; MyScript.ps1PS E:&gt; ./MyScript.ps1Hello,World! 这样有个缺点，就是您的代码必须放在闭合的引号中。这样的书写方式一旦在脚本内部也有引号时，是一件很痛苦的事。甚至您还可能希望在脚本中换行。下面的Here-strings例子不错，也就是将脚本文件通过@&#39; &#39;@闭合起来。 12345678910111213141516PS E:&gt; @&#x27;&gt;&gt; Get-Date&gt;&gt; $Env:CommonProgramFiles&gt;&gt; #Script End&gt;&gt; &quot;files count&quot;&gt;&gt; (ls).Count&gt;&gt; #Script Really End&gt;&gt;&gt;&gt; &#x27;@ &gt; myscript.ps1&gt;&gt;PS E:&gt; .MyScript.ps12019年3月27日 18:15:10C:\\Program Files\\Common Filesfiles count20 Here-String以 @&#39;开头，以&#39;@结束.任何文本都可以存放在里面，哪怕是一些特殊字符，空号，白空格。但是如果您不小心将单引号写成了双引号，PowerShell 将会把里面的变量进行解析。 通过编辑器创建脚本其实最方便的还是使用文本编辑器直接编写代码，保存成PS1文件，右键即可执行。这里推荐使用Visual Studio Code(以下简称VSC)，VSC提供了PS1的自动补全(安装插件)、语法高亮、自动缩进、格式化代码、断点调试等功能。 变量变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。PowerShell 的变量定义非常方便。我们可以用 $变量名=初值 的方法定义变量，解释器会根据所赋的初值判断变量类型，类似于C#的 var 关键字或C++11中的 auto 关键字PowerShell 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$.创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外:单引号中的字符串不会识别和处理变量名。 选择变量名在 PowerShell 中变量名均是以美元符 $ 开始，剩余字符可以是数字、字母、下划线的任意字符，并且PowerShell变量名也对大小写不敏感（$a 和 $A 是同一个变量)。某些特殊的字符(比如$等)在 PowerShell 中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。 123PS C:/&gt; $&#123;&quot;I&quot;like $&#125;=5.1PS C:/&gt; $&#123;&quot;I&quot;like $&#125;5.1 不能定义和保留变量名称相同的变量使用ls variable: 列出当前使用的所有变量，刚启动的 PowerShell 执行此命令能看到 PowerShell 的所有自动化变量(一旦打开 Powershell 就会自动加载的变量，后面将会详细解释这些变量的作用) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Name Value---- -----$? True^args &#123;&#125;ConfirmPreference HighConsoleFileNameDebugPreference SilentlyContinueError &#123;&#125;ErrorActionPreference ContinueErrorView NormalViewExecutionContext System.Management.Automation.EngineIntrinsicsfalse FalseFormatEnumerationLimit 4HOME C:\\Users\\aaaaaHost System.Management.Automation.Internal.Host.InternalHostInformationPreference SilentlyContinueinput System.Collections.ArrayList+ArrayListEnumeratorSimpleMaximumAliasCount 4096MaximumDriveCount 4096MaximumErrorCount 256MaximumFunctionCount 4096MaximumHistoryCount 4096MaximumVariableCount 4096MyInvocation System.Management.Automation.InvocationInfoNestedPromptLevel 0nullOutputEncoding System.Text.ASCIIEncodingPID 8796PROFILE C:\\Users\\aaaaa\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1ProgressPreference ContinuePSBoundParameters &#123;&#125;PSCommandPathPSCulture zh-CNPSDefaultParameterValues &#123;&#125;PSEdition DesktopPSEmailServerPSHOME C:\\Windows\\System32\\WindowsPowerShell\\v1.0PSScriptRootPSSessionApplicationName wsmanPSSessionConfigurationName http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;powershell&#x2F;Microsoft.PowerShellPSSessionOption System.Management.Automation.Remoting.PSSessionOptionPSUICulture zh-CNPSVersionTable &#123;PSVersion, PSEdition, PSCompatibleVersions, BuildVersion...&#125;PWD C:\\Users\\aaaaaShellId Microsoft.PowerShellStackTracetrue TrueVerbosePreference SilentlyContinueWarningPreference ContinueWhatIfPreference False 查看变量类型变量可以自动存储任何PowerShell能够识别的类型信息，可以通过 $变量名.GetType() 查看和验证 PowerShell 分配给变量的数据类型 123456PS C:/&gt; $num=10PS C:/&gt; $num.gettype() #不区分大小写IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Int32 System.ValueType 删除变量如果不想继续使用自定义的变量，可以使用del variable:变量名的方法删除变量，注意此处无$符号 123456$a=0$a -eq $nullFalsedel variable:a$a -eq $null True PowerShell支持的变量类型和C#大体相同(没有了short、uint、ulong等)，大多都继承自System.ValueType类( .NET类)，其基本数据类型包括 整型 类型 名称 允许的值 所属类 byte 无符号整数(1字节) 0~255之间的整数 System.Byte sbyte 有符号整数(1字节) -128~127之间的整数 System.SByte int16 有符号短整型(2字节) -32768~32767之间的整数 System.Int16 uint16 无符号短整型(2字节) 0~65535之间的整数 System.UInt16 int 有符号整型 -2147483648~2147483647之间的整数 System.Int32 uint32 无符号整型 0~4294967295之间的整数 System.UInt32 long 有符号长整数(8字节) -9223372036854775808~9223372036854775807之间的整数 System.Int64 ulong 无符号长整数(8字节) 0~18446744073709551615之间的整数 System.UInt64 其实 int 、long 、以及下面的 float 都是 .NET的语法糖，真正的原生类型名是int32、int64、single 之类的类名 浮点型浮点数标准形式(float和double)$+/-m×2^e$其中m为尾数，e为阶码，尾数是一个非负数，阶码是一个整数PowerShell还支持一个特别的浮点数类型 decimal，其形式为$+/-m×10^e$ 类型 名称 指数 m范围 e范围 近似最小值 近似最大值 所属类 float 单精度浮点数 2 0~$2^{24}$ -149~104 $1.5×10^{-45}$ $3.4×10^{38}$ System.Single double 双精度浮点数 2 0~$2^{53}$ -1075~970 $5.0×10^{-324}$ $1.7×10^{308}$ System.Double decimal 16字节浮点数 10 0~$2^{96}$ -28~0 $1.0×10^{-28}$ $7.9×10^{28}$ System.Decimal 其他简单类型除了数值类型以外，还有3种基本类型 类型 名称 允许的值 所属类 char 字符型 一个Unicode字符，存储0~65535之间的整数 System.Char bool 布尔型 布尔值: $true 或 $false(必须加$符号) System.Boolean enum 枚举 限定取值一组命名常量的独特的值类型 System.Enum datetime 时间型 包含日期、时间的类型 System.DateTime string 字符串 一组字符 System.String 注意 C/C++的 char 仅支持ASCII里面的256个字符, PowerShell 和 C# 的 char 是支持Unicode的，PowerShell和C#的string类型并不是继承自 System.ValuType 类，而是继承自 System.Object 类，因此严格来说 string 类型并非是简单类型。**PowerShell的转义字符是 ` 而不是 \\**，这也是和C#的一个区别 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#使用charPS D:/&gt;[char]$c=&quot;A&quot;$cA#使用boolPS D:/&gt;$boolean=$true$booleanTrue#使用enumenum fruit&#123; apple banana cherry durian&#125;[fruit]$en=[fruit]::apple$enapple$item=&quot;cherry&quot;[fruit]$enu=[fruit]::($item)$enucherry#这种使用方法是错误的PS D:/&gt; [fruit]$enum=bananabanana : 无法将“banana”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 12+ [fruit]$en=banana+ ~~~~~~ + CategoryInfo : ObjectNotFound: (banana:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException#当尝试使用非枚举值进行赋值时PS D:/&gt; [fruit]$en=[fruit]::peach由于枚举值无效，无法将 Null 转换为类型“fruit”。请指定以下枚举值之一，然后重试。可能的枚举值为“apple,banana,cherry,durian”。所在位置 行:1 字符: 1+ [fruit]$en=[fruit]::peach+ ~~~~~~~~~~~~~~~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeExceptionPS D:/&gt; &quot;\\n 123 `n 123&quot;&lt;#输出\\n 123 123#&gt;PS D:/&gt;$date=get-date$date$date.gettype()&lt;#输出2019年3月28日 19:32:30IsPublic IsSerial Name BaseType-------- -------- ---- --------True True DateTime System.ValueType#&gt; 赋值和返回值赋值操作符为 =，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令，因为 PowerShell 支持面向对象，对象可以包罗万象。 1234567891011121314151617181920PS D:\\powershell\\test&gt; $item&#x3D;lsPS D:\\powershell\\test&gt; $item 目录: D:\\powershell\\testMode LastWriteTime Length Name---- ------------- ------ -----a---- 2017&#x2F;11&#x2F;24 12:52 136 4-3.cpp-a---- 2019&#x2F;3&#x2F;27 15:13 65 anapple.txtPS D:\\powershell\\test&gt; $item.gettype()IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Object[] System.Array$item为一个对象数组 弱类型与强类型一般对 PowerShell 变量重新赋值时，变量类型会自动改变，这是弱类型语言的特点；而 PowerShell 依托的 .NET是强类型的，所以 PowerShell 可以使用强类型。强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。可以在变量前添加类型限定符使该变量变为强类型，可以确保变量的类型不会随着赋值而改变 123456789[int]$num=123 #正确[int]$num=ls &lt;#错误无法将“System.Object[]”类型的“System.Object[]”值转换为“System.Int32”类型。所在位置 行:1 字符: 1+ [int]$num=ls+ ~~~~~~~~~~~~ + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeException#&gt; 类型转换PowerShell 能够非常方便地将字符串等基本类型转换成期望的类型。之所以神奇，是因为 PowerShell 本身做了很多辛苦的工作，按照优先级： 直接赋值：输入类型和期望类型一致，可以直接交付。 基于语言的类型转换：当目标类型为void,Boolean,String , Array , Hashtable , PSReference (i.e.: [ref]), XmlDocument , Delegate 和 Enum 时，基于语言的类型转换开始工作。 Parse 转换：如果目标类型包含了 Parse() 方法，则采用它。 Static Create 转换：如果目标类型包含静态的Create，则采用它。 构造函数转换：如果目标类型定义了构造函数，采用它。 Cast 转换：如果目标类型定义了从源类型的显式或者隐式的操作符，则采用它。 IConvertible 接口转换：如果目标类型实现了支持源类型IConvertible 接口，则采用它。 IDictionary 转换：如果源类型是词典或者哈希表，会尝试创建一个实例，然后来填充name和value属性。 PSObject 属性转换：如果源类型是PSObject，通过目标类型的默认的构造函数创建一个实例，然后使用PSObject中的属性名称和值来填充实例的属性。 TypeConverter 转换：如果存在注册的 TypeConverter 或 PSTypeConverter 来处理转换，则使用它。 注意对浮点数向整数进行类型转换时，会自动四舍五入！！如果要C++/C#那种向下取整的方法请使用 [math]::Floor() 函数看几个转换的例子 12345PS D:/test&gt; $s=12.56PS D:/test&gt; [int]$s13PS D:/test&gt; [convert]::ToInt32($s)13 [convert]::ToInt32() 是 .NET System.Convert 类提供的转换函数convert 类中的转换函数格式为:TO+原生类型名()，这里的原生类型名指的是各个类型实际类名常用： [convert]::ToInt32() [convert]::ToSingle() [convert]::ToDouble() [convert]::ToBoolean() [convert]::ToString() convert 类提供了一系列方法来完成不同变量之间的转换，获得函数列表及使用方法请参考微软的 .NET文档Convert类 方法列表 运算符注意逻辑运算符和比较运算符的写法,不支持 C# 的&amp;&amp; || ！ == != &lt; &gt; &gt;= &lt;=这些运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#加 减 乘 除 取余+ - * / %#自增、自减运算符，和C#或C++完全一致++$i$i++$i----$i#且-and#并-or#非-not!#样例$true -and $false -or -not 0!$true#输出TrueFalse#等于 (equal to)-eq#不等于 (not equal to)-nq#大于 (greater than)-gt#大于等于 (greater than or equal to)-ge#小于 (less than)-lt#小于等于 (less than or equal to)-le#对于字符串类型，可以在比较运算符前加i或c表示是否区分大小写,#i表示对大小写不敏感，c表示敏感，不写默认不敏感&quot;a&quot; -eq &quot;A&quot;&quot;a&quot; -ceq &quot;A&quot;#输出TrueFalse#判断变量是否为兼容类型(同一类型或其父类型)，类型格式为 [类型名]-is#示例$a=0$a -is [int]$b=1,2,3$b -is [array]$a -is [ValueType]#输出TrueTrueTrue # System.Int32类继承自System.ValueType类，因此int是其父类型ValueType的子类型 条件分支if elseif 和 else 用法和C#完全一样，除了大括号不允许省略，多分支时还多了个elseif 可用，和Python 的 elif 作用相同 123456789if($true -and $true) &#123; $a=0&#125;elseif($a -eq $b) &#123; $a=1&#125;else &#123; $a=2&#125; switchPowerShell的switch非常灵活，使用起来较为方便相对C#或C++，PowerShell的switch不需要写`case:``，但是必须写大括号 123456$a=&quot;Beijing&quot;switch($a) &#123; &quot;Beijing&quot; &#123;$res=&quot;北京&quot;&#125; &quot;Shanghai&quot; &#123;$res=&quot;上海&quot;&#125;&#125; 默认比较运算符为-eq，你也可以使用下面的例子自定义比较条件，必须保证表达式返回boolen类型($true和$false) 12345678910$v=18switch($v)&#123; &#123;$_ -lt 10&#125; &#123;&quot;小于10&quot;&#125; # $_ 表示当前的传入的变量 直接写的字符串会被输出 10 &#123;&quot;等于10&quot;&#125; &#123;$_ -gt 10&#125; &#123;&quot;小于10&quot;&#125;&#125;&lt;#输出大于10#&gt; 循环接下来介绍循环 for循环PowerShell 的 for 循环类似于C#，看一个样例: 1234for($i=0;$i -lt 10;$i++)&#123; Write-Output &quot;Hello&quot;&#125; do-while循环Do 和 While 可能产生死循环，为了防止死循环的发生，因此我们必须确切的指定循环终止的条件。指定了循环终止的条件后，一旦条件不满足就会退出循环。do-while() 会先执行再去判断，能保证循环至少执行一次。 1234567891011do &#123; $n=Read-Host &quot;请输入数字&quot;&#125; while($n -ne 0)&lt;#输出请输入数字: 1请输入数字: 2请输入数字: s请输入数字: 0#&gt; 只使用while123456789101112$n=5while($n -gt 0)&#123; $n $n=$n-1&#125;#输出54321 跳出循环使用 continue 关键字，可以终止当前循环，跳过 continue 后其它语句，重新下一次循环。跳出循环语句使用 break 关键字 1234567891011121314151617181920212223242526272829$n=1while($n -lt 6)&#123; if($n -eq 4) &#123; $n=$n+1 continue &#125; else &#123; $n &#125; $n=$n+1&#125;1235$n=1while($n -lt 6)&#123; if($n -eq 4) &#123; break &#125; $n $n++&#125; 还有一种循环 foreach ，等到我们讲到数组再说 数组定义数组在 PowerShell 中创建数组可以使用逗号 123456PS C:/Powershell&gt; $nums=2,0,1,2PS C:/Powershell&gt; $nums2012 对于连续的数字数组可以使用一个更快捷的方法: 1234567PS C:/Powershell&gt; $nums=1..5PS C:/Powershell&gt; $nums12345 对象数组的多态像变量一样，如果数组中元素的类型为弱类型，默认可以存储不同类型的值。 123456789101112131415161718192021222324252627282930313233PS C:/Powershell&gt; $array=1,&quot;2019&quot;,([Guid]::NewGuid()),(get-date)PS C:/Powershell&gt; $array12019Guid----ea5f17c6-c0a2-42ba-9de4-e4d03bebffafDisplayHint : DateTimeDate : 2019/3/29 0:00:00Day : 29DayOfWeek : FridayDayOfYear : 88Hour : 23Kind : LocalMillisecond : 120Minute : 23Month : 3Second : 39Ticks : 636894986191207086TimeOfDay : 23:23:39.1207086Year : 2019DateTime : 2019年3月29日 23:23:39PS C:/Powershell&gt; $array|foreach&#123;$_.gettype()&#125;#查看数组各元素类型IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Int32 System.ValueTypeTrue True String System.ObjectTrue True Guid System.ValueTypeTrue True DateTime System.ValueType 空数组和单元素数组对数组元素可以查看它的公有属性，比如长度只需要输入$数组名.Count即可显示数组长度 空数组12345PS C:/Powershell&gt; $a=@()PS C:/Powershell&gt; $a -is [array]TruePS C:/Powershell&gt; $a.Count0 单元素数组12345PS C:Powershell&gt; $a=,&quot;moss&quot;PS C:Powershell&gt; $a -is [array]TruePS C:Powershell&gt; $a.Count1 使用数组遍历直接法将数组作为单独一行将会自动遍历这个数组的所有元素 123456789101112PS C:/&gt; $a=1..10PS C:/&gt; $a12345678910 for 循环遍历1234567891011PS C:/&gt; $a=1..5PS C:/&gt; for($i=0;$i -lt 5;$i++) &#123;&gt;&gt; $a[$i] &#125;12345&#125; foreach 遍历法还有一种遍历的方法，用到了之前提到的 foreach 语句意思是使用变量 $n 对 $a 元素进行迭代，这实际上是一种对可迭代对象的访问算法在 C# 也有这种语法 1234567891011$a=&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;foreach($n in $a)&#123; $n+&quot; &quot;+$n&#125;#输出A AB BC CD DE E foreach还有一种遍历的写法 这里我们需要先了解一下管道管道的符号 |管道允许将它左侧命令的输出结果发送到右侧做命令的参数管道并不是什么新事物，以前的Cmd控制台也有重定向的命令，例如Dir | More可以将结果分屏显示。传统的Cmd管道是基于文本的，但是 PowerShell 是基于对象的 列出当前目录下的目录和文件，然后根据文件名降序排列，再投影(数据库术语)文件名，文件大小，文件的修改时间: 123456789101112PS D:/test&gt; ls | Sort-Object -Descending Name | Select-Object Name,Length,LastWriteTime 目录: D:/testName Length LastWriteTime---- ------ -------------out.txt 523 2019/2/24 22:46:35lang.json 6415 2019/2/16 23:49:24anapple.txt 65 2019/3/27 15:13:524-3.cpp 136 2017/11/24 12:52:28 可迭代对象(比如数组)可以由管道送到一些命令上进一步处理foreach就可以接受管道送来的可迭代对象，并进行遍历 1234567891011$array=&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;$array|foreach&#123; $_+&quot;s&quot;&#125;#输出AsBsCsDsEs 将数组逆序输出12345PS C:/Powershell&gt; $books=&quot;A1&quot;,&quot;B2&quot;,&quot;C3&quot;PS C:/Powershell&gt; $books[($books.Count)..0]C3B2A1 访问某些元素与C#相同，数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是 PowerShell 为了使用方便，直接可以将 -1 作为最后的一个元素的索引(参考了 Python 的语法) 123456789PS C:/Powershell&gt; $books=&quot;1A&quot;,&quot;2B&quot;,&quot;3C&quot;PS C:/Powershell&gt; $books[0]1APS C:/Powershell&gt; $books[1]2BPS C:/Powershell&gt; $books[($book.Count-1)]3CPS C:/Powershell&gt; $books[-1]3C 从数组中选择多个元素12345678910PS C:/Powershell&gt; $result=lsPS C:/Powershell&gt; $result[0,3,5,12] Directory: C:PowershellMode LastWriteTime Length Name---- ------------- ------ ----d---- 2011/11/23 17:25 ABC-a--- 2011/11/24 20:04 26384 a.txt-a--- 2011/11/24 20:27 12060 alias.ps1-a--- 2011/11/24 17:37 7420 name.html 给数组添加元素因为PowerShell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用 += 操作符。 1234567PS C:/Powershell&gt; $books=&quot;A1&quot;,&quot;B2&quot;,&quot;C3&quot;PS C:/Powershell&gt; $books+=&quot;D4&quot;PS C:/Powershell&gt; $booksA1B2C3D4 删除指定位置元素采用截断重连法删除指定元素 1234567891011PS C:/Powershell&gt; $num=1..4PS C:/Powershell&gt; $num1234PS C:/Powershell&gt; $num=$num[0..1]+$num[3] #相当于删掉了第三项PS C:/Powershell&gt; $num124 复制数组数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用 Clone() 方法( System.Array 类的成员函数)，除非有特殊需求。 1234567891011121314151617PS C:/Powershell&gt; $chs=@(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;)PS C:/Powershell&gt; $chsBak=$chsPS C:/Powershell&gt; $chsBak[1]=&quot;H&quot;PS C:/Powershell&gt; $chsAHCPS C:/Powershell&gt; $chs.Equals($chsBak)TruePS C:/Powershell&gt; $chsNew=$chs.Clone()PS C:/Powershell&gt; $chsNew[1]=&quot;Good&quot;PS C:/Powershell&gt; $chs.Equals($chsNew)FalsePS C:/Powershell&gt; $chsAHC 强类型数组PowerShell 数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常，这样的数组被称为强类型数组定义方法[类型[]]$数组名=初值 12345678910PS C:/Powershell&gt; [int[]] $nums=@()PS C:/Powershell&gt; $nums+=2012PS C:/Powershell&gt; $nums+=12.3PS C:/Powershell&gt; $nums+=&quot;999&quot;PS C:/Powershell&gt; $nums+=&quot;can not convert&quot;Cannot convert value &quot;can not convert&quot; to type &quot;System.Int32&quot;. Error: &quot;Input string was not in a correct format.&quot;At line:1 char:6+ $nums &lt;&lt;&lt;&lt; +=&quot;can not convert&quot; + CategoryInfo : MetadataError: (:) [], ArgumentTransformationMetadataException + FullyQualifiedErrorId : RuntimeException 命令返回数组当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。但是，事实上 PowerShell 会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时， PowerShell 也会自动把结果存储为数组 12345678910111213141516171819202122232425262728293031323334353637383940414243PS C:/Powershell&gt; $IPcfg=ipconfigPS C:/Powershell&gt; $IPcfg&lt;#输出Windows IP 配置以太网适配器 以太网: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : lan无线局域网适配器 本地连接* 1: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . :无线局域网适配器 本地连接* 2: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : **** IPv4 地址 . . . . . . . . . . . . : **** 子网掩码 . . . . . . . . . . . . : **** 默认网关. . . . . . . . . . . . . :以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 本地链接 IPv6 地址. . . . . . . . : fe80::f88d:cd97:5343:9713%16 IPv4 地址 . . . . . . . . . . . . : **** 子网掩码 . . . . . . . . . . . . : **** 默认网关. . . . . . . . . . . . . :无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : **** 本地链接 IPv6 地址. . . . . . . . : fe80::954:3964:3731:997e%18 IPv4 地址 . . . . . . . . . . . . : **** 子网掩码 . . . . . . . . . . . . : **** 默认网关. . . . . . . . . . . . . : ****#&gt;PS C:/Powershell&gt; $IPcfg.Count37 使用数组存储结果判断一个变量是否为数组 12345678PS C:/Powershell&gt; $ip=ipconfigPS C:/Powershell&gt; $ip -is [array]TruePS C:/Powershell&gt; &quot;abac&quot; -is [array]FalsePS C:/Powershell&gt; $str=&quot;字符串&quot;PS C:/Powershell&gt; $str.ToCharArray() -is [array] #转换为字符数组True 使用真实的对象操作为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令(事实上ipconfig是一个单独的程序)，真正的 PowerShell 命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。 1234567891011121314151617181920212223242526272829PS D:/test&gt; $list=lsPS D:/test&gt; $list 目录: D:/testMode LastWriteTime Length Name---- ------------- ------ -----a---- 2017/11/24 12:52 136 4-3.cpp-a---- 2019/3/27 15:13 65 anapple.txtPS D:/test&gt; $list.gettype()IsPublic IsSerial Name BaseType-------- -------- ---- --------True True Object[] System.ArrayPS D:/test&gt; foreach($i in $list)&#123;$i.name&#125;4-3.cppanapple.txtPS D:/test&gt; $list[0].gettype()IsPublic IsSerial Name BaseType-------- -------- ---- --------True True FileInfo System.IO.FileSystemInfo 上面的例子中数组的每一个元素存放的是一个 System.IO.DirectoryInfo 对象。当我们输出这些对象时，PowerShell 会自动帮我们把它转换成友好的文本格式。对于任何一个对象都可以使用 Format-List * 来查看它所有的属性和方法。 123456789101112131415161718192021222324252627282930313233343536373839404142PS D:/test&gt; $list[0]|fl * # &quot;|&quot;符号是管道符，将左边返回结果做参数发送到右侧，fl是Format-List的简称PSPath : Microsoft.PowerShell.Core\\FileSystem::D:test\\4-3.cppPSParentPath : Microsoft.PowerShell.Core\\FileSystem::D:\\testPSChildName : 4-3.cppPSDrive : DPSProvider : Microsoft.PowerShell.Core\\FileSystemPSIsContainer : FalseMode : -a----VersionInfo : File: D:\\test\\4-3.cpp InternalName: OriginalFilename: FileVersion: FileDescription: Product: ProductVersion: Debug: False Patched: False PreRelease: False PrivateBuild: False SpecialBuild: False Language:BaseName : 4-3Target : &#123;&#125;LinkType :Name : 4-3.cppLength : 136DirectoryName : D:\\testDirectory : D:\\testIsReadOnly : FalseExists : TrueFullName : D:\\test\\4-3.cppExtension : .cppCreationTime : 2019/3/27 15:07:32CreationTimeUtc : 2019/3/27 7:07:32LastAccessTime : 2019/3/27 15:07:32LastAccessTimeUtc : 2019/3/27 7:07:32LastWriteTime : 2017/11/24 12:52:28LastWriteTimeUtc : 2017/11/24 4:52:28Attributes : Archive 函数函数是自定义的 Powershell 代码，有三个原则： 简短：函数名简短，并且显而易见。 聚合：函数可以完成多个操作。 封装和扩展：将一批 Powershell 语句进行封装，实现全新的功能需求。函数的结构由三部分组成：函数名，参数，函数体 定义函数脚本中函数的定义方法函数可以在文本编辑器上编写，写完以后复制进 PowerShell 控制台即可。如果控制台设置为快速编辑模式，从记事本复制后，直接在控制台鼠标右键即可完成粘贴(Windows 10默认开启了快速编辑模式) 1234function FuncName(args[]) #括号可省略&#123; &lt;#代码段#&gt;&#125; 控制台上多行输入定义函数12345PS C:/PowerShell&gt; function MyPing&gt;&gt; &#123;&gt;&gt; PING.EXE -n 1 $args&gt;&gt; &#125;PS C:/PowerShell&gt; 把函数精简成一行我们可以将一个函数定义在一行上，但是这样阅读和理解起来就不方便，所以要在每条命令后加分号进行分割(最后一句可以不写;) 12PS C:/PowerShell&gt; function cd...&#123; cd.. ; cd.. &#125;PS C:/PowerShell&gt; cd... 使用函数作为别名假如 PowerShell 不支持 Get-SystemVersion 命令，你可以通过定义函数实现这个功能： 12345678910function get-systemversion&#123; $psversiontable.BuildVersion&#125;Get-SystemVersionMajor Minor Build Revision----- ----- ----- --------10 0 17134 590 更新函数如果要更新已经定义好的函数，简单的方法是重新定义，这样新的定义会覆盖旧的定义。但是如果函数代码没有保存副本，可以先将函数定义导出到ps文件，然后就可以编辑了。 1234567891011121314PS C:/PowerShell&gt; function MyPing&gt;&gt; &#123;&gt;&gt; PING.EXE -n 1 $args&gt;&gt; &#125;PS C:/PowerShell&gt; $function:MyPing | Out-File myPing.ps1PS C:/PowerShell&gt; $function:MyPingPING.EXE -n 1 $argsPS C:/PowerShell&gt; $function:MyPing | Out-File myPing.ps1PS C:/PowerShell&gt; .myPing.ps1必须指定 IP 地址。PS C:/PowerShell&gt; notepad.exe $$ 删除函数控制台定义的函数只会在当前会话生效，一旦控制台退出，会自动消失。在不关闭控制台的条件下删除一个已经定义好的函数，可是使用虚拟驱动器的方法： 1234567891011function cc&#123;&quot;hello&quot;&#125;PS C:/&gt; cchelloPS C:/&gt; del function:ccPS C:/&gt; cccc : 无法将“cc”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ cc+ ~~ + CategoryInfo : ObjectNotFound: (cc:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException 输入输出函数用于脚本文件的编写 输入PowerShell提供了 Read-Host 命令，可以接收返回用户在控制台输入的字符 1234567$name=read-host &quot;请输入你的名字&quot; #会把提示信息打印到PS控制台，也可以不写提示信息&lt;#执行+输入 结果:请输入你的名字: Nougat #&gt;$nameNougat 注意到 提示信息(如果有)后面自动加了个冒号； 用户键入任何信息都被作为该命令的返回结果； 可以把键入的信息传递给一个变量； 输出有两种输出命令Write-Host和Write-Output若输出字符串不包含空白字符可以不加引号 Write-Host当需要展示一个特定信息，比如使用其他颜色来吸引人们的注意力的时候，可使用 Write-Host 命令 Write-Host 和其他Cmdlets一样使用管道，但是它不放置任何数据道管道中。反而会直接写到宿主应用程序的界面。正如此，可以使用-ForegroundColor 和 -BackgroundColor 参数将前景和背景设置为其他颜色： 12write-host &quot;啊哈&quot; -ForegroundColor White -BackgroundColor Red啊哈 注：不是每个使用PowerShell的应用程序都支持其他颜色，也并不是每个应用程序都支持所有颜色。该输出方法不适用于常规的输出结果，因为 Write-Host 命令输出到屏幕的任何东西都无法被捕捉。若执行远程命令或无人值守命令(纯自动化)， Write-Host 可能不会按照你的预期工作。因此，此命令仅仅用于与人进行直接交互。 Write-OutputWrite-Output命令会将对象发送给管道。由于它不会直接发送到显示界面，所以不允许你指定其他任何的颜色。 它是PowerShell默认使用的一个Cmdlets，默认输出方式即使用该命令，即使你没有指定，PowerShell会在底层将信息传递给Write-Output命令(就是一行直接写一个变量就能直接输出的情况)，另外这个命令还有两个别名 write 和 echo 123456write-host ACB #无空白字符可以不写引号 ACBwrite &quot;ABC&quot;ABCecho &quot;ABD&quot;ABD Write-Output输出基本过程为： Write-Output命令将string类型的对象Hello World!放入管道中； 管道中只有这个string对象，其会直接到达管道的末端，也就是Out-Default命令； Out-Default命令将对象传递给Out-Host命令； Out-Host命令要求PowerShell的格式化系统格式化该对象。 Out-Host将格式化的结果集放在显示界面上 还有一点，在输出多个对象时，Write-Host会以空格隔开各对象Write-Output会以换行隔开各对象 123456write-host &quot;ABC&quot; &quot;23232&quot;ABC 23232write-output &quot;ABC&quot; &quot;23232&quot;ABC 23232 其他的输出方式Write-Warning/Verbose/Debug/Error 具体参考：微软官方文档 处理函数参数PowerShell 函数可以接受参数，并对参数进行处理。函数的参数有3个特性： 任意参数：内部变量$args 接受函数调用时接受的参数，$args是一个数组类型； 命名参数：函数的每一个参数可以分配一个名称，在调用时通过名称指定对应的参数； 预定义参数：函数在定义参数时可以指定默认值，如果调用时没有专门指定参数的值，就会保持默认值； $args 万能参数给一个函数定义参数最简单的是使用$args这个内置的参数。它可以识别任意个参数。尤其适用那些参数可有可无的函数。 123456789101112131415161718192021222324252627282930function sayHello&#123; if($args.Count -eq 0) &#123; &quot;No argument!&quot; &#125; else &#123; $args | foreach &#123;&quot;Hello,$($_)&quot;&#125; &#125;&#125;#无参调用sayhello#输出No argument!#一参调用sayhello &quot;World!&quot; #也可以写成sayhello(&quot;World!&quot;)#输出Hello,World!#多参数调用$str=&quot;it&#x27;s me.&quot;sayhello 123 &quot;aha&quot; $str #如果字符串不包含空白字符(比如空格)，引号可以不写&lt;#输出Hello,123Hello,ahaHello,it&#x27;s me.#&gt; 因为 $arg 是一个数组,可以用它很方便的写出求和函数 12345678function Add&#123; $sum=0 $args | foreach &#123;$sum=$sum+$_&#125; $sum&#125;Add 10 7 3 100#120 使用固定参数12345678910function StringContact($str1,$str2)&#123; return $str1+$str2&#125; StringContact LN P#StringContact -str1 word -str2 press#StringContact(&quot;word&quot;,&quot;press&quot;)LNPwordpress 给参数定义默认值1234567function stringContact($str1=&quot;LN&quot;,$str2=&quot;P&quot;)&#123; return $str1+$str2&#125;stringContactLNP 使用强类型参数通过之前的例子发现将用户的参数传递给函数显得比较混乱。罪魁祸首就是PowerShell的参数解释器，它可以自动处理和分配参数给函数。函数的参数解释器比较傲慢，它对你提供的参数的信息完全不关心。它只会粗略地将参数进行分割，并且最大限度的进行自动类型转换。事实上，这种类型转换很多时候并不完美。所以最好提前能够对参数进行强类型限制 限制数字类型下面的函数执行后，会抛出异常因为 subtract 的参数定义了强类型，参数的类型可能引起函数的处理结果改变。 123456789101112131415161718192021222324252627function subtract([int]$value1,[int]$value2)&#123; return $value1-$value2&#125;subtract LN P#执行结果报错subtract : 无法处理对参数“value1”的参数转换。无法将值“LN”转换为类型“System.Int32”。错误:“输入字符串的格式不正确。”所在位置 行:1 字符: 10+ subtract LN P+ ~~ + CategoryInfo : InvalidData: (:) [subtract]，ParameterBindingArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,subtractsubtract 8.1 7.90&lt;#结果为0，这是因为PowerShell对结果整型化时进行了四舍五入但是如果将上面的函数的参数定义为Double型#&gt;function subtract([double]$value1,[double]$value2)&#123; return $value1-$value2&#125;subtract 8.1 7.90.199999999999999&lt;#输出 0.199999999999999的原因就是 .NET使用IEEE754标准存储浮点数，由于这些小数转化二进制会无限循环，会根据一定精度截取尾数，这个问题引发了这种奇怪的结果，其实著名的0.1+0.2!=0.3也是这个原因导致的#&gt; 限制日期类型函数的参数解释器会自动尝试将字符串转换成日期类型，如果转换失败就是抛出异常看下面的例子 123456789101112131415161718function DayOfWeek([datetime]$date)&#123; return $date.DayOfWeek&#125;DayofWeek &#x27;1927-8-1&#x27;MondayDayofWeek 2008-8-1FridayDayofWeek &#x27;abc&#x27;DayOfWeek : 无法处理对参数“date”的参数转换。无法将值“abc”转换为类型“System.DateTime”。错误:“该字符串未被识别为有效的 DateTime。有一个未知单词(从索引 0 处开始)。”所在位置 行:1 字符: 12+ DayofWeek &#x27;abc&#x27;+ ~~~~~ + CategoryInfo : InvalidData: (:) [DayOfWeek]，ParameterBindingArgumentTransformationException + FullyQualifiedErrorId : ParameterArgumentTransformationError,DayOfWeek Switch 参数Powershell 函数最简单的参数类型为布尔类型，除了使用 Bool 类型，也可以使用 Switch 关键字。下面的函数逆转字符串，但是可以通过 $try 参数进行控制，如果没有指定 $try 的值，默认值为 $false 12345678910111213141516171819function tryReverse( [switch]$try , [string]$source ) #此处switch完全可以换成bool&#123; [string]$target=&quot;&quot; if($try) &#123; for( [int]$i = $source.length -1; $i -ge 0 ;$i--) &#123; $target += $source[$i] &#125; return $target &#125; return $source&#125;tryReverse -source www.google.comtryReverse -try $true -source www.google.com#输出www.google.commoc.eloog.www 指定函数的返回值一个或多个返回值PowerShell 不像其它的编程语言，它的函数可以有多个返回值。如果你直接调用函数，返回值会在控制台输出。当然你也可以将结果存储在一个变量中进一步处理下面的例子演示返回一个值： 12345678910111213141516function Square([double]$num)&#123; return $num*$num&#125;#在控制台输出结果Square 9.8797.4169 #将结果赋值给变量$value=Square 9.87$value97.4169 #返回值为Double类型$value.GetType().FullNameSystem.Double 下面的例子演示返回多个值 123456789101112131415161718192021222324252627282930313233function gbMeasure($amount)&#123; &quot;$amount GB=$($amount) GB&quot; &quot;$amount GB=$($amount*1gb/1mb) MB&quot; &quot;$amount GB=$($amount*1gb/1kb) KB&quot; &quot;$amount GB=$($amount*1gb) B&quot;&#125; #函数返回4个值gbMeasure 11 GB=1 GB1 GB=1024 MB1 GB=1048576 KB1 GB=1073741824 B #将所有的返回值存储在一个变量中$result=gbMeasure 1$result 1 GB=1 GB1 GB=1024 MB1 GB=1048576 KB1 GB=1073741824 B #所有的返回值会自动存储在一个数组中$result=gbMeasure 1$result.GetType().NameObject[] #通过索引访问每个返回值$result=gbMeasure 1$result[3]1 GB=1073741824 B 总结一下，如果一个函数返回一个值，像其它编程语言一样，这个值包括它的类型信息会直接返回。但是如果遇到多个返回值，PowerShell会将所有的返回值自动构造成一个对象数组。可以通过索引访问数组 Return语句Powershell 会将函数中所有的输出作为返回值，但是也可以通过return语句指定具体的返回值。Return 语句会将指定的值返回，同时也会中断函数的执行，return后面的语句会被忽略 看一个例子 12345678910111213141516function test($num)&#123; 1 9 return 10 4 6&#125;test1910&lt;# 1 和 9 作为输出会返回return语句中的10 也会返回return 语句后的4和6会被忽略#&gt; 访问返回值一个函数返回了一个值还是多个值，是可以验证的。下面的例子会产生随机数，如果没有指定个数，默认会返回一个随机数，否则会返回指定个数的随机数 1234567891011121314151617181920function lottery([int]$number=1)&#123; $rand = New-Object system.random for ($i=1; $i -le $number; $i++) &#123; $rand.next(1,50) &#125;&#125;# 参数为空时，返回值不是数组:$result = lottery$result -is [array]False# 如果指定多个随机数时，返回值是数组类型:$result = lottery 10$result -is [array]True$result.count10 从函数的返回值中消除输出函数默认会将函数中的所有输出作为函数的返回值返回，这样很方便。但有时可能会将不必要的输出误以为返回值。写脚本程序时，可能需要自定义一些函数，这个函数可能只需要一个返回值，但是为了提高函数的可读性，可能会在函数增加一些注释输出行，或者使用write-host 1234567891011121314151617181920212223242526272829303132function Test()&#123; &quot;Try to calculate.&quot; &quot;3.1415926&quot; &quot;Done.&quot;&#125; #保存在变量中输出,$value=Test$value#输出Try to calculate.3.1415926Done. #如果要过滤注释，只输出，不作为返回值，#可以使用Write-Host命令function Test()&#123; Write-Host &quot;Try to calculate.&quot; &quot;3.1415926&quot; Write-Host &quot;Done.&quot;&#125;# 在变量值中保存返回值，在控制台输出注释行$value=Test#控制台输出Try to calculate.Done. # 测试返回值$value3.1415926 恭喜你！到此 PowerShell 基础入门算是完成了！之后将介绍 PowerShell 的进阶使用 附录PowerShell Math类常用函数表 函数名 调用写法 所在类 重载 描述 参数 sin [math]::sin(x) System.Math 1 返回x弧度的正弦值 double cos [math]::cos(x) System.Math 1 返回x弧度的余弦值 double abs [math]::abs(x) System.Math 7 返回x的绝对值 所有数值型 sqrt [math]::sqrt(x) System.Math 1 返回x的平方根 double pow [math]::pow(x,n) System.Math 1 返回x的n次幂 两参数都是double log [math]::log(x) System.Math 1 返回x的自然对数 double log [math]::log(x,n) System.Math 1 返回x的以n为底的对数 double min [math]::min(x,y) System.Math 11 返回x，y中的最小值 所有数值型 max [math]::max(x,y) System.Math 11 返回x，y中的最大值 所有数值型 floor [math]::ceiling(x) System.Math 2 返回x向下取整的结果 double、decimal ceiling [math]::ceiling(x) System.Math 2 返回x向上取整的结果 double、decimal math 类其他函数及详细用法参见微软文档: Math类","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PowerShell","slug":"编程语言/PowerShell","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://www.lollipopnougat.top/tags/PowerShell/"}]},{"title":"记一次express后端的搭建","slug":"记一次express后端的搭建","date":"2019-04-30T12:21:25.000Z","updated":"2021-04-26T07:27:24.886Z","comments":true,"path":"2019/04/30/记一次express后端的搭建/","link":"","permalink":"https://www.lollipopnougat.top/2019/04/30/%E8%AE%B0%E4%B8%80%E6%AC%A1express%E5%90%8E%E7%AB%AF%E7%9A%84%E6%90%AD%E5%BB%BA/","excerpt":"Node.js作为网工人怎么能不会搭后端呢？今天就拿 Node.js 下的 Express 搭一个后端","text":"Node.js作为网工人怎么能不会搭后端呢？今天就拿 Node.js 下的 Express 搭一个后端 Node.js 是什么东西你可能没听说过 Node.js，但是应该听说过 JavaScript，你也应该知道 Chrome(谷歌浏览器) 吧 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境(Runtime，即运行时)。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 简介Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。它发布于 2009 年 5 月，由 Ryan Dahl 开发，实质是对 Chrome V8 引擎进行了封装(底层调用 C/C++的相关库)。Node 对一些特殊用例进行优化，提供替代的 API，使得 V8 在非浏览器环境下运行得更好。V8 引擎执行 Javascript 的速度非常快，性能非常好。常用于用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞 I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。 Express.js这是一个基于 Node.js 平台，快速、开放、极简的 Web 开发框架，为 Web 和移动应用程序提供一组强大的功能。其实就是一个 node 下很完善的一个后端框架，在众多 js 后端框架中 Express 是做到大而全的。 为什么选择 Express首先是因为node 相比 java 下的 spring，python 下的 django 之类开发效率高。node 平台编程语言还是 js，对于前端也很友好，即使想要面向对象也有 ECMA6 和 Typescript 可选；还有完善的包管理工具 npm 或者 yarn;express 框架非常易于使用，即使没有使用经验也能很快上手。而且其大而全的特性也是功能强大的表现，相关需求的插件很多，使用文档和教程也是不计其数，可以说是各种流行后端框架中最高效最轻量的一个了。 安装首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 12mkdir myappcd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 欲了解 package.json 是如何起作用的，请参考 Specifics of npm’s package.json handling. 1npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受大部分默认设置即可，下面这个除外： 1entry point: (index.js) 键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。 接下来在 myapp 目录下安装 Express 并将其保存到依赖列表中。如下： 1npm install express --save 如果只是临时安装 Express，不想将它添加到依赖列表中，可执行如下命令： 1npm install express --no-save npm 5.0+ 版本在默认情况下会将安装的模块添加到 package.json 文件中的 dependencies 列表中。对于较老的 npm 版本，你就必须指定 --save 参数。然后，照旧执行 npm install 命令即可自动安装依赖列表中所列出的所有模块。 示例最简单的示例helloworld123456789101112var express = require(&#x27;express&#x27;)var app = express()var port = 8080;app.get(&#x27;/&#x27;, function(req, res) &#123; res.send(&#x27;Hello World&#x27;)&#125;)var server = app.listen(port, function() &#123; var host = server.address().address console.log(&#x27;应用实例，访问地址为 http://%s:%s&#x27;, host, port)&#125;) 甚至可以这样写(ES 6)123456789// ECMAScript 6 支持了 let, const 关键字、类 class、lambda 表达式、字符串模板(`$&#123;&#125;`)、异步关键字async, await、解构赋值、模块的导入(import)和导出(export default/export)、Promise (异步的同步代码)、set和map的实现等好多特性，有时间我会更一期文章讲这个const express = require(&#x27;express&#x27;);const app = express();const port = 3000;app.get(&#x27;/&#x27;, (req, res) =&gt; res.send(&#x27;Hello World!&#x27;));// 采用了lambda表达式的写法非常简洁不是吗app.listen(port, () =&gt; console.log(`Example app listening on port $&#123;port&#125;!`)); 通过 npm 文件名 就可以启动。 请求和响应Express 应用使用回调函数的参数： request 和 response 对象来处理请求和响应的数据。 处理 GET 请求示例12345678app.get(&#x27;/&#x27;, function(req, res) &#123; // 处理访问&#x27;/&#x27;目录的回调函数 // 假设用户访问的是 /?name=string 执行结果就是输出 string console.log(&#x27;您通过query指定的参数是 %s&#x27;, req.query.name) // 返回json响应 res.json(value)&#125;) 处理 POST 请求示例12345app.post(&#x27;/&#x27;, (req, res) =&gt; &#123; // 为了省事，函数我用lambda表达式表示了 // 假设用户向 &#x27;/&#x27; POST 一个 &#123; name: &#x27;string&#x27; &#125; console.log(&#x27;您提交的name字段值是 %s&#x27;, req.body.name) // 返回结果就是 string&#125;) 使用命令行生成器通过应用生成器工具 express-generator 可以快速创建一个应用的基本框架。 1234567# 要求 node.js 版本在 8.2.0 及以上npx express-generator# 如果低于 8.2.0 可以使用npm install -g express-generator# 安装完成后再执行express 详细信息请看教程 使用路由功能教程","categories":[{"name":"后端","slug":"后端","permalink":"https://www.lollipopnougat.top/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Nodejs","slug":"后端/Nodejs","permalink":"https://www.lollipopnougat.top/categories/%E5%90%8E%E7%AB%AF/Nodejs/"}],"tags":[{"name":"网站搭建","slug":"网站搭建","permalink":"https://www.lollipopnougat.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.lollipopnougat.top/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"https://www.lollipopnougat.top/tags/Express/"},{"name":"后端","slug":"后端","permalink":"https://www.lollipopnougat.top/tags/%E5%90%8E%E7%AB%AF/"}]},{"title":"PowerShell入门指南(2)","slug":"PowerShell入门指南(2)","date":"2019-03-29T06:41:14.000Z","updated":"2021-04-26T07:44:20.276Z","comments":true,"path":"2019/03/29/PowerShell入门指南(2)/","link":"","permalink":"https://www.lollipopnougat.top/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(2)/","excerpt":"PowerShell入门指南(二)·挑战CMD和Bash的PowerShell作为CMD/Bash的代替使用如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用","text":"PowerShell入门指南(二)·挑战CMD和Bash的PowerShell作为CMD/Bash的代替使用如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用 PowerShell 命令 PowerShell 简称 CMD 命令 UNIX 命令 描述 Get-ChildItem gci,dir,ls dir ls 显示当前目录下的所有文件和文件夹 Test-Connection ping ping ping 向目标站点发送一个ICMP接受响应，检查网络连通性 Get-Content gc,type,cat type cat 获取文件内容 Get-Command gcm help type, which, compgen 列出可用的命令 Get-Help help,man help apropos,man 在控制台列出命令的使用文档 Clear-Host cls,clear cls clear 清除屏幕内容 Copy-Item cpi,copy,cp copy,xcopy,robocopy cp 拷贝文件/文件夹到指定位置 Move-Item mi,move,mv move mv 移动文件/文件夹到新位置 Remove-Item ri,del,erase,rmdir,rd,rm del,erase,rmdir,rd rm,rmdir 删除文件/文件夹 Rename-Item rni,ren,mv ren,rename mv 重命名文件/文件夹 Get-Location gl,cd,pwd cd pwd 显示当前工作目录 Pop-Location popd popd popd 将工作路径更改为最近压入堆栈的位置 Push-Location pushd pushd pushd 将工作路径存储到堆栈上 Set-Location sl,cd,chdir cd,chdir cd 更改当前工作目录 Tee-Object tee 不支持 tee 将输入通过管道传递到文件或变量 Write-Output echo,write echo echo 将字符或其他对象输出到标准输出流上 Get-Process gps,ps tlist,tasklist ps 列出当前全部进程 Stop-Process spps,kill kill,taskkill kill 终止指定进程 Select-String sls findstr find,grep 打印匹配的字符行 Set-Variable sv,set set env,export,set,setenv 创建或更改环境变量的内容 Invoke-WebRequest iwr,curl,wget[^1] 不支持 wget,curl 从Internet上的网页获取内容 [^1]:curl和wget不在PowerShell Core中，因此不会干扰调用非Windows操作系统的同名组件。 功能键和快捷键先来了解一下功能键和快捷键 ALT+F7 清除命令的历史记录 PgUp PgDn 显示当前会话的第一个命令和最后一个命令 Enter 执行当前命令 End 将光标移至当前命令的末尾 Del 从右开始删除输入的命令字符 Esc 清空当前命令行 F2 自动补充历史命令至指定字符(例如历史记录中存在Get-Process，按F2，提示”Enter char to copy up to”，键入 S，自动补齐命令:Get-Proce) F4 删除命令行至光标右边指定字符处 F7 对话框显示命令行历史记录 F8 检索包含指定字符的命令行历史记录 F9 根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看 ←/→ 左右移动光标 ↑/↓ 切换命令行的历史记录 Home 光标移至命令行最左端 Backspace 从右删除命令行字符 Ctrl+C 取消正在执行的命令 Ctrl+←/→ 在单词之间移动光标 Ctrl+Home 删除光标最左端的所有字符 Tab 自动补齐命令或者文件名 数值计算我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。 12345678PS C:/pstest&gt; 1+2+36PS C:/pstest&gt; 0xABCD43981PS C:/pstest&gt; 3.14*10*10314PS C:/pstest&gt; 1+3-(2.4-5)*(7.899-4.444)12.983 PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB 12345678PS C:/pstest&gt; 1pb/1tb1024PS C:/pstest&gt; 1tb/1gb1024PS C:/pstest&gt; 1gb/1kb1048576PS C:/pstest&gt; 1gb/20mb*10kb524288 假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数为： 12PS C:/pstest&gt; 10GB/(80KB*5)/30873.813333333333","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PowerShell","slug":"编程语言/PowerShell","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://www.lollipopnougat.top/tags/PowerShell/"}]},{"title":"PowerShell入门指南(1)","slug":"PowerShell入门指南1","date":"2019-03-29T06:32:58.000Z","updated":"2021-04-26T07:37:53.576Z","comments":true,"path":"2019/03/29/PowerShell入门指南1/","link":"","permalink":"https://www.lollipopnougat.top/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%971/","excerpt":"Powershell入门指南(一)·PowerShell及CLI发展不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。","text":"Powershell入门指南(一)·PowerShell及CLI发展不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。 也许你也曾经打开过它，但是不知道它有什么用;或者你了解一些CMD命令，但是你发现在这个PowerShell里面有些命令好像不能执行了。而且这个PowerShell相比CMD启动也不算快，微软为什么要拿这个替换CMD呢？这要从早期的Windows的命令行背景说起： 背景用于个人计算机的每个Windows版本都包含一个用于管理操作系统的命令行解释程序(CLI)；Windows系统的前身，即MS-DOS，完全依赖CLI支持。在MS-DOS和Windows9x系列系统里面提供CLI功能的程序是COMMAND.COM，在Windows NT以及之后的各种系统是CMD.exe提供CLI支持的。这两者都支持一些内部命令。它们还包括基本的脚本语言(batch file)支持，这些脚本可以完成多种自动化工作，但是对于用户交互界面(GUI)的自动化工作，它们就完全无能为力了。这是因为对GUI这些操作对应脚本的等价操作来说是受限的，毕竟这是最基本的脚本环境，支持的功能不全。到了Windows Sever 2003发布的时候，这一情况有所改善，但是仍令人不满意。 其实Microsoft在1998年就试图通过对Windows 98引入Windows脚本宿主(WSH)来解决其中一些缺点，这个程序在系统中名叫cscript.exe，它集成了Active script[^1]脚本引擎，可以使用兼容的VBscript和JScript来编写，调用其他应用程序的API或者COM。然而，它有其自身的不足之处：的文档不是很容易获得，并且在几个有名的计算机病毒利用其安全协议中的弱点之后，迅速获得了作为脆弱的系统漏洞荣誉(大雾)。不同版本的Windows提供了各种专用命令行解释器（例如netsh和WMIC）及其只适用自己的命令，但它们之间不可互操作。 开发人员的设想在9月13日发表的一次采访中，Jeffrey Snover(PowerShell之父)解释了开发该项目的动机: “我一直推动管理的变更，然后我开始把一些UNIX工具适配到Windows平台，结果它们却不能工作，对吧？因为Windows 和Linux的核心架构有很大区别。在Linux上，一切都是ASCII文本文件，因此所有支持这种文件的软件都可以作为管理软件。想想看，使用AWK(文本处理工具)、grep(文本搜索工具)、sed(类似于AWK)管理你的系统是多么美好的事请！我把这些工具移植到Windows，结果它们对于系统的管理没有任何作用，因为所有的API返回的都是结构化的数据，因此那些UNIX软件没什么帮助。……我突然有了就是现在powershell这样子的想法，告诉别人说：‘嘿！没准我们可以把这个做得更好！’” 开发历程 2002年，微软开始开发一种新的命令行管理方法，名为Monad（也称为Microsoft Shell或MSH）的CLI。其背后的想法于2002年8月发表在一份名为Monad Manifesto的白皮书中。Monad将成为一个新的可扩展CLI，其设计新颖，能够自动执行各种核心管理任务。 微软于2003年10月在洛杉矶举行的专业发展大会上首次展示Monad。几个月后开始私人测试计划，最终推出公共测试计划。 Microsoft 于2005年6月17日发布了第一个Monad公共测试版， 2005年9月11日发布了Beta 2 2006年1月10日发布了Beta 3。 不久之后，2006年4月25日，Microsoft正式宣布Monad已重命名为Windows PowerShell，将其定位为其管理技术产品的重要组成部分。 名称更改和RC的一个重要方面是，它现在是Windows的一个组件，而不是附加产品。 PowerShell版本1的候选版本2于2006年9月26日发布，最终发布于2006年11月14日，并在TechEd Barcelona上发布。 早期版本的Windows PowerShell于2007年1月30日发布。 PowerShell v2.0开发在PowerShell v1.0发布之前就开始了。在开发过程中，Microsoft发布了三个社区技术预览（CTP）。Microsoft向公众提供了这些版本。 Windows PowerShell v2.0的最后一个CTP版本于2008年12月推出。 适用于Ubuntu 14.04 x64 上的Linux 6.0 Alpha 9的PowerShell PowerShell v2.0已于2009年8月完成并发布，作为Windows 7和Windows Server 2008 R2的组成部分。适用于Windows XP，Windows Server 2003，Windows Vista和Windows Server 2008的PowerShell版本于2009年10月发布，可供32位和64位平台下载。 Windows 10提供了PowerShell的测试框架 2016年8月18日，微软宣布他们开发了PowerShell开源和跨平台，支持Windows，macOS，CentOS和Ubuntu。源代码发布在GitHub上。转向开源创建了PowerShell的第二个版本，称为“PowerShell Core”，它运行在 .NET Core上。它与“Windows PowerShell”不同，后者在完整的 .NET Framework上运行。 从版本5.1开始，PowerShell Core与Windows Server 2016 Nano Server捆绑在一起 简介PowerShell是Microsoft的任务自动化和配置管理框架，由命令行shell和相关的脚本语言组成。最初只是一个Windows组件，称为Windows PowerShell，它于2016年8月18日通过PowerShell Core的推出而成为开源和跨平台。前者构建于 .NET Framework上，后者构建于 .NET Core上。 在PowerShell中，管理任务通常由cmdlet（发音为command-lets）执行，cmdlet是实现特定操作的专用 .NET 类。这些工作通过访问不同数据存储中的数据（如文件系统或注册表），这些数据存储通过提供程序提供给PowerShell 。第三方开发人员可以向PowerShell添加cmdlet和提供程序。自定义的脚本可以使用Cmdlet ，还可以打包成模块作为新的Cmdlet使用。 PowerShell提供对COM和WMI的完全访问，使管理员能够在本地和远程Windows系统以及WS-Management和CIM上执行管理任务，从而实现远程对Linux系统和网络设备的管理。PowerShell还提供了一个托管API，PowerShell运行时可以使用该API嵌入到其他应用程序中。然后，这些应用程序可以使用PowerShell功能来实现某些操作，包括通过图形界面公开的操作。Microsoft Exchange Server 2007 使用此功能将其管理功能公开为PowerShell指令和提供程序并实现作为PowerShell主机的图形管理工具，可通过调用必要的cmdlet来使用Exchange Sever 2007。其他Microsoft应用程序（包括Microsoft SQL Server 2008）也通过PowerShell cmdlet公开其管理界面。 PowerShell含有广泛的，基于控制台的自身帮助（类似于手册页在Unix外壳）通过键入Get-Help命令即可轻松获取使用方法。你可以通过Update-Help cmdlet 从Internet升级本地帮助内容，还能通过Get-Help &lt;命令名&gt; -online获取来自网络的帮助。 以上内容来自PowerShell - Wikipedia，背景和开发人员设想部分为笔者翻译(翻译如有问题欢迎指出)，开发历程和简介由Google提供翻译服务，笔者进行了校对。 版本 了解更多请参考： PowerShell - Wikipedia 最初使用代号“Monad”，PowerShell于2003年9月首次在专业开发者大会上公开展示。所有主要版本仍然受支持，并且每个主要版本都具有与先前版本的向后兼容性。 PowerShell 1.0 PowerShell 1.0于2006年11月发布，适用于Windows XP SP2，Windows Server 2003 SP1和Windows Vista。它还是Windows Server 2008的可选组件。 PowerShell 2.0 PowerShell 2.0与Windows 7和Windows Server 2008 R2集成，适用于Windows XP Service Pack 3，Windows Server 2003 Service Pack 2和Windows Vista Service Pack 1. PowerShell v2除了包含240多个新cmdlet之外，还包括对脚本语言和托管API的更改。 PowerShell 3.0 PowerShell 3.0与Windows 8和Windows Server 2012集成在一起。Microsoft还为Windows 7 Service Pack 1，Windows Server 2008 Service Pack 1和Windows Server 2008 R2 Service Pack 1 提供了PowerShell 3.0 。 PowerShell 3.0是更大的软件包Windows Management Framework 3.0（WMF3）的一部分，它还包含支持远程处理的WinRM服务。Windows Management Framework 3.0的早期社区技术预览2（CTP 2）版本于2011年12月2日发布。 Windows Management Framework 3.0于2012年12月发布，并默认包含在Windows 8和Windows Server 2012中。 PowerShell 4.0 PowerShell 4.0与Windows 8.1和Windows Server 2012 R2集成在一起。Microsoft还为Windows 7 SP1，Windows Server 2008 R2 SP1和Windows Server 2012提供了PowerShell 4.0。 PowerShell 5.0 包含PowerShell 5.0的Windows Management Framework（WMF）5.0 RTM于2016年2月24日在发布严重错误的初始版本后重新发布到Web。主要功能包括OneGet PowerShell cmdlet，支持Chocolatey基于存储库的包管理，并将对交换机管理的支持扩展到第2层网络交换机。 PowerShell 5.1 它与2016年8月2日的Windows 10 周年更新以及Windows Server 2016一起发布。PackageManagement现在支持代理，PSReadLine现在支持ViMode，并添加了两个新的cmdlet：Get-TimeZone和Set-TimeZone。LocalAccounts模块允许添加/删除本地用户帐户。 PowerShell 5.1的预览版已于2016年7月16日针对Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Server 2012和Windows Server 2012 R2 发布，并于2017年1月19日发布正式版。 PowerShell 5.1是第一个有两个版本的PowerShell，包括“桌面”和“核心”版本。“桌面”版本是在完整的 .NET Framework堆栈上运行的传统Windows PowerShell的延续。“Core”版本在 .NET Core上运行，并与Windows Server 2016 Nano Server捆绑在一起。为了减少占用空间，后者缺少一些功能，例如用于管理剪贴板的cmdlet或将计算机加入域，WMI版本1 cmdlet，事件日志cmdlet和配置文件。这是专为Windows制作的PowerShell的最终版本。 PowerShell 6.0 PowerShell Core 6.0于2016年8月18日首次发布，当时微软公布了PowerShell Core并决定使该产品跨平台，独立于Windows，而且是免费和开源的。 它于2018年1月10日实现了Windows，macOS和Linux的普遍可用性。它有自己的支持生命周期，并遵循Windows 10引入的Microsoft生命周期策略：仅支持最新版本的PowerShell Core。微软希望每六个月为PowerShell Core 6.0发布一个次要版本。 此版本PowerShell中最重要的变化是扩展到其他平台。对于Windows管理员，此版本的PowerShell没有任何主要的新功能。在2018年1月11日的社区访谈中，PowerShell团队被要求列出将从Windows PowerShell 5.1迁移到PowerShell Core 6.0的Windows IT专业人员可能发生的十大最令人兴奋的事情。作为回应，微软的Angel Calvo只能说出两个：跨平台和开源(这两个就足够了)。 PowerShell 7.0 PowerShell 7.0 GA 正式发布了。 除了常见的新 cmdlet/API 和错误修复之外，PowerShell 7.0 还引入了许多新功能，主要包括： 使用 ForEach-Object -Parallel 进行管道并行化 新的运算符 三元运算符： a ? b : c Pipeline 主运算符：|| 和 &amp;&amp; 空分配和合并运算符 ：?? 和 ??= 简化的动态错误视图和 Get-Error cmdlet，可更轻松地调查错误 兼容性层，使用户能够在隐式 Windows PowerShell 会话中导入模块 自动化新版本通知 直接从 PowerShell 7 调用以调用 DSC 资源的能力（实验性） 从 PowerShell Core 6.x 到 7.0 的转变也标志着从 .NET Core 2.x 到 3.1 的转变。.NET Core 3.1 带来了许多 .NET Framework API（特别是在 Windows 上），从而使与现有 Windows PowerShell 模块的向后兼容性大大提高。这包括 Windows 上需要 GUI 功能的许多模块，例如 Out-GridView 和 Show-Command，以及 Windows 附带的许多角色管理模块。更多信息可查看 PowerShell 7.0 的模块兼容性表。 官方表示，PowerShell 7 标志着与 Windows PowerShell 的向后兼容性最大化的旅程已完成，“PowerShell 7 及其以后的版本将是真正的 PowerShell ”。 目前Windows 10 上自带的版本是5.1[^1]:一种可以采用各种语言以及固定格式等实现、并能与其他 ActiveX 控件(可以理解为一种互联网插件)交互的脚本","categories":[],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://www.lollipopnougat.top/tags/PowerShell/"}]},{"title":"春节快乐","slug":"春节快乐","date":"2019-02-04T12:38:56.000Z","updated":"2021-04-26T07:26:36.643Z","comments":true,"path":"2019/02/04/春节快乐/","link":"","permalink":"https://www.lollipopnougat.top/2019/02/04/%E6%98%A5%E8%8A%82%E5%BF%AB%E4%B9%90/","excerpt":"春节快乐祝各位春节快乐,新的一年大家也要继续努力鸭!笔者还准备了礼物送给大家，点击下面的阅读全文查看","text":"春节快乐祝各位春节快乐,新的一年大家也要继续努力鸭!笔者还准备了礼物送给大家，点击下面的阅读全文查看 献上笔者绘制的Peppa Pig(社会猪佩奇) 送上猪年祝福语 春风初度到猪年，欢歌声声震云天。千家万户乐翩翩，迎福纳财笑开颜。我有祝福在心田，悄悄送到你身边。愿你猪年爱情甜，合家快乐福无边。 朝霞映满天，盛世耀猪年。歌美舞翩翩，快乐太平年。瑞雪一片片，幸福绕猪年。春风暖心田，欢度团圆年。猪年到了，愿你快乐绵绵！ 猪年好，猪年妙，猪年的歌声满天飘；猪年灿，猪年暖，猪年的幸福享不完；猪年旺，猪年香，猪年的祝福分外长。愿你猪年心飞扬，万事皆顺畅！ 除夕到来菩萨忙，各路神仙送吉祥：财神送你金元宝，寿星保你身安康，文殊给你大智慧，观音佑你幸福长，弥勒让你乐不断，福星伴你走四方！春节快乐！ 春风叩开猪年的门扉，对联贴满猪年的庭院，欢畅陶醉猪年的日子，幸福温暖猪年的时光，情意铺满猪年的道路。猪年到了，愿你的生活灿烂美满。 猪年就要到了，新春祝福提前到。祝你有人缘，事业顺利不心烦；祝你有情缘，爱情甜蜜心也甜；祝你有财源，腰包鼓鼓金钱花不完。最后祝你猪年大吉！ 一张圆桌，合家团座笑呵呵；一顿晚餐，美味家肴喜庆多；一杯美酒，装满幸福和快乐；一个除夕，张灯结彩好喜气；一条祝福，愿你多财又多福；新年到，愿你全家幸福乐逍遥！ 春节到处乐洋洋，祝福语先到身旁，心意情意都献上，愿您接纳永收藏，愿您事业财源广，愿您暖和体安康，愿您烦恼忧愁散，愿您春节安康！ 绘制佩奇使用的是PS的钢笔","categories":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"},{"name":"春节","slug":"节日祝福/春节","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/%E6%98%A5%E8%8A%82/"}],"tags":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://www.lollipopnougat.top/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"},{"name":"春节","slug":"春节","permalink":"https://www.lollipopnougat.top/tags/%E6%98%A5%E8%8A%82/"}]},{"title":"HTML (一)","slug":"HTML (一)","date":"2019-01-25T13:36:08.000Z","updated":"2021-04-25T15:24:25.768Z","comments":true,"path":"2019/01/25/HTML (一)/","link":"","permalink":"https://www.lollipopnougat.top/2019/01/25/HTML%20(%E4%B8%80)/","excerpt":"HTMLHTML 指超文本标记语言 HTML 是通向 WEB 技术世界的钥匙。","text":"HTMLHTML 指超文本标记语言 HTML 是通向 WEB 技术世界的钥匙。 简介HTML是现在世界通用的超文本标记语言，通过它，可以实现图片、链接、音乐以及程序等等多种元素。现如今，HTML已经是程序员必须掌握的一项基本功。 HTML发展史HTML没有1.0，因为关于它的初版存在争议，1995年HTML 2.0面世，1997年由国际官方组织W3C推出了HTML 3.2以及HTML 4.0标准，后面W3C(万维网联盟)也渐渐变成Web技术领域的权威，经过漫长的演变，2014年，HTML 5标准最终面世。 *HTML 2.0——1995年11月，RFC 1866发布*HTML 3.2——1997年1月14日，W3C发布推荐标准*HTML 4.0——1997年12月18日，W3C发布推荐标准*HTML 4.01——1999年12月24日，W3C发布推荐标准*HTML 5——2014年10月28日，W3C发布推荐标准 HTML5编辑规范 文件拓展名默认使用htm或者html，便于操作系统或者程序辨认文件，而图片则基本上存为gif或jpg 浏览器默认忽视回车符，不过为了方便阅览，人们还是会习惯地在写完一段代码后进行回车 标记符号用尖括号括起来，带斜杠的元素表示该标记说明结束，大多数标记符必须成对使用，用以说明起始和结束。 必须使用半角而不是全角字符 HTML注释&lt;!--注释内容--&gt;的内容不给予显示。 这是笔者写的较为详细的一个入门页面HTML入门·一","categories":[{"name":"前端","slug":"前端","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://www.lollipopnougat.top/tags/HTML/"}]},{"title":"PowerShell (一)","slug":"PowerShell (一)","date":"2019-01-17T11:48:41.000Z","updated":"2021-04-25T09:03:23.906Z","comments":true,"path":"2019/01/17/PowerShell (一)/","link":"","permalink":"https://www.lollipopnougat.top/2019/01/17/PowerShell%20(%E4%B8%80)/","excerpt":"PowershellPowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。","text":"PowershellPowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。 介绍PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，PowerShell需要.NET环境的支持，借助 .NET Framework平台强大的类库，几乎让一切都成为可能。微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。 受众Windows PowerShell 入门主要面向IT 专业人员、程序员和高级用户。 特点通过解决长期存在的问题并添加一些新的功能，Windows PowerShell 旨在改进命令行和脚本环境。PowerShell以 .NET Framework为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。PowerShell推出了一个功能强大的命令叫做cmdlet,所有的cmdlet命令都遵循动词-名词这样语法结构。如Get-Command, Get-Process等，即使从来没有接触过PowerShell，也很容易能够明白命令的作用。如Get-Process命令的意思就是获取所有的进程。 新的脚本语言由于以下原因，Windows PowerShell 使用它自己的语言，而不是重用现有的语言：Windows PowerShell 需要用于管理.NET 对象的语言。该语言需要为使用cmdlet 提供一致的环境。该语言需要支持复杂的任务，而不会使简单的任务变得更复杂。 该语言需要与在.NET编程中使用的高级语言（如C#）一致。 PS1文件一个PowerShell脚本其实就是一个简单的文本文件，这个文件包含了一系列PowerShell命令，每个命令显示为独立的一行，对于被视为PowerShell脚本的文本文件，它的文件名需要使用.PS1扩展。 执行权限为防止恶意脚本的执行，PowerShell有一个执行策略，默认情况下，这个执行策略被设为受限的（Restricted），意味着PowerShell脚本无法执行，你可以使用下面的cmdlet命令确定当前的执行策略： Get-ExecutionPolicy 你可以选择使用的执行策略有： Restricted -脚本不能运行。 RemoteSigned - 本地创建的脚本可以运行，但网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）。 AllSigned – 仅当脚本由受信任的发布者签名才能运行。 Unrestricted –脚本执行不受限制，不管来自哪里，也不管它们是否有签名。 你可以使用下面的cmdlet命令设置PowerShell的执行策略： 1Set-ExecutionPolicy &lt;policy name&gt; 运行脚本如果你想从命令行运行一个可执行文件，多年来一个永恒不变的方法是，在命令行转到该执行文件所在的位置，然后键入该执行文件的名称，但这个古老的方法现在却不能适用于PowerShell可执行脚本了。如果你想执行一个PowerShell脚本，通常必须键入完整的路径和文件名，例如，假设你要运行一个名为a.ps1的脚本，你可以键入：C:\\Scripts\\aps1最大的例外是，如果PowerShell脚本文件刚好位于你的系统目录中，那么你可以直接在命令提示符后键入脚本文件名即可运行，如：.\\a.ps1 注意前面需要加上.\\，这和Linux下执行Shell脚本的方法如出一辙。 管道管道的作用是将一个命令的输出作为另一个命令的输入，两个命令（或cmdlet）之间只需要用管道符号（|）连接即可。为了帮助你了解管道是如何工作的，我们以一个例子进行说明，假设你想创建运行在服务器上的进程列表，并按进程的ID号进行排序，可以使用Get-Process cmdlet命令获得进程列表，但默认情况下列表不会排序，如果将这个cmdlet命令的输出用管道输送给Sort-Object ID命令，进程列表将会按进程ID号进行排序，如： 1Get-Process | Sort-Object ID 变量虽然可以使用管道将一个命令的输出输送给另一个命令，但管道本身也是有限制的，当你用管道从一个命令向另一个命令传递输出结果时，输出结果立即被使用，但有时候，你可能需要保存输出结果一段时间，以便以后可以使用（或重用），这个时候管道就应该下场，轮到变量上场了。人们很容易将变量想象成一个仓库，但在PowerShell中，变量可以保存命令的完整输出，例如，假设你想保存服务器处于运行中的进程列表，你可以将它赋给一个变量，如：$a = Get-Process在这里，变量被命名为$a，如果你想使用这个变量，只需要简单地调用它的名称即可，例如，键入$a便可在屏幕上打印变量的内容。你可以将多个用管道连接的命令的最终输出赋给一个变量，只需要用一对小括号将命令括起来即可，例如，假设你想按进程ID对运行中的进程进行排序，然后将结果输出给一个变量，你可以使用下面这个命令： 1$a = (Get-Process | Sort-Object ID) @符号通过使用@符号，你可以将列表内容转换成一个数组，例如，下面的代码创建了一个名为$Procs的变量，它包含多行文本内容（一个数组）：$procs = @&#123;name=&quot;explorer&quot;,&quot;svchost&quot;&#125;使用变量时你也可以使用@符号，为了确保它作为数组而不是单个值处理，例如，下面的代码将在我前面定义的变量上运行Get-Process cmdlet命令： 1Get-Process @procsWindows 将显示Windows资源管理器和Svchost使用的所有进程，注意变量前使用的@符号，而不是常见的$符号。 SplitSplit操作符根据你指定的字符拆分一个文本字符串，例如，假设你想将一个句子拆分成一个单词组成的一个数组，你可以使用下面的命令做到： 1&quot;This is a test&quot; -split &quot; &quot; 拆分后的结果如下：This is a test Join就像Split可以将一个文本字符串拆分成多块一样，Join的操作则是逆向的，将多个独立的块连接成一个整体，例如，下面这行代码将会创建一个文本字符串，由我的名字和姓氏组成： 1&quot;Brien&quot;,&quot;Posey&quot; -join &quot; &quot; 命令末尾双引号之间的空格告诉Windows在两个文本字符串之间插入一个空格。 断点运行一个新创建的PowerShell脚本时，如果脚本有Bug，会遇到意想不到的后果，保护自己的一个方法是在脚本的关键位置插入断点，这样你就可以确保脚本正常运行先，然后再处理可能存在的问题。插入断点最简单的方法是根据行号插入，例如，假设你要在第10行插入一个断点，可以使用下面的命令： 1234567New-PSBreakpoint -Script C:\\Scripts\\a.ps1 -Line 10#你也可以将断点绑定到变量上，如果你希望你的脚本任何时候都可以修改a$的内容，可以使用下面的命令：New-PSBreakpoint -Script C:\\scripts\\a.ps1 -variables a #注意，在变量名后并没有包括美元符号。#可以和`PSBreakpoint`一起使用的动词包括`New`，`Get`，`Enable`，`Disable`和`Remove`。 Step调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用Step-Into cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用Step-Out cmdlet命令即可，但需要注意的是，使用Step-Out cmdlet命令后，断点仍然有效。顺便说一句，如果你的脚本使用了函数，你可能对Step-Out cmdlet更感兴趣，Step-Out 的工作方式和Step-Into 一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。 因此PowerShell实际是一门独立的脚本语言了PowerShell能干什么？PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。 PowerShell能做下面这些事: .NET/.NET CORE编程, Registry, COM, WMI, ADSI. Exchange, Sharepoint, Systems Center, Hyper-V, SQL. VMware vCenter, Cisco UCS, Citrix XenApp and XenDesktop.，Azure, Excel 和 Office applications. 基本上所有的微软产品都提供PowerShell接口。 1、管理进程前面已经提过管理系统进程的命令，管理进程常用命令就是get-process和stop-process，get-process获取进程之后可以直接用管道发送给stop-process结束进程。比如，关闭打开的记事本，可以使用下面的命令很方便的关闭记事本。 1get-process -Name notepad | stop-process 2、处理文件和文件夹PowerShell使用Get-ChildItem获取文件夹中直接包含的所有项，它有系统内置别名dir和ls，使用CMD和BASH的用户均可以轻松上手。如果想查看C:中的文件夹和文件，直接使用dir c:，PowerShell立刻就会列出C:中的文件和文件夹。其它处理文件和文件夹的命令有Copy-Item、New-Item、Remove-Item等，具体用法可以使用get-help然后跟命令名称即可查询。 3、处理系统服务可以像管理进程一样管理系统服务， Get-Service命令获取服务列表， Stop-Service命令停止服务， Start-Service命令启动服务， Suspend-Service命令挂起服务， Restart-Service命令重启服务， Set-Service服务设置服务属性。如果想一次性启动已经停止的服务，可以使用以下命令：1get-service | where-object &#123;$_.Status -eq &quot;Stopped&quot;&#125; -exclude 下面这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。*wisvc | start-service 4、处理注册表PowerShell可以非常方便的处理注册表项目，与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。由于注册表对系统非常重要，错误处理注册表也许会导致系统出问题，处理注册表，特别是删除注册表项目要非常小心，最好能在处理注册表项目之前先备份要处理的项目。没有管理员权限也能处理部分注册表项目，这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。 5、处理其它任务PowerShell还可以处理证书、防火墙、appx应用、打印机等任务，篇幅所限，不具体举例。大家可以使用get-command命令查找相关命令。 6、编写脚本程序借助于.Net/.Net Core 实际上来说其他的编程语言能干什么，PowerShell都可以做到，PowerShell能够充分利用.Net类型和COM对象，来简单地与各种系统交互，完成各种复杂的、自动化的操作，因此PowerShell现在也是很不错的编程语言了，有人还做出了ps1 to exe的脚本，可以将PowerShell编写的脚本文件编译成exe可执行文件。 一个有趣的例子这是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。 12345678910111213141516171819202122232425# 创建新的excel com对象$objExcel = New-Object -comobject Excel.Application$objExcel.Visible = $True$objWorkbook = $objExcel.Workbooks.Add()$objWorksheet = $objWorkbook.Worksheets.Item(1)# 把信息写入excel$i = 0$first10 = (ps | sort ws -Descending | select -first 10)$first10 | foreach -Process &#123;$i++; $objWorksheet.Cells.Item($i,1) = $_.name; $objWorksheet.Cells.Item($i,2) = $_.ws&#125;$otherMem = (ps | measure ws -s).Sum - ($first10 | measure ws -s).Sum$objWorksheet.Cells.Item(11,1) = &quot;Others&quot;; $objWorksheet.Cells.Item(11,2) = $otherMem# 画饼图$objCharts = $objWorksheet.ChartObjects()$objChart = $objCharts.Add(0, 0, 500, 300)$objChart.Chart.SetSourceData($objWorksheet.range(&quot;A1:B11&quot;), 2)$objChart.Chart.ChartType = 70$objChart.Chart.ApplyDataLabels(5)#暂停pause$objExcel.Quit()$objExcel = $null[GC]::Collect() 执行结果:","categories":[{"name":"编程语言","slug":"编程语言","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"PowerShell","slug":"编程语言/PowerShell","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"}],"tags":[{"name":"PowerShell","slug":"PowerShell","permalink":"https://www.lollipopnougat.top/tags/PowerShell/"}]},{"title":"元旦快乐","slug":"元旦快乐","date":"2018-12-31T16:12:12.000Z","updated":"2021-04-26T07:41:39.670Z","comments":true,"path":"2019/01/01/元旦快乐/","link":"","permalink":"https://www.lollipopnougat.top/2019/01/01/%E5%85%83%E6%97%A6%E5%BF%AB%E4%B9%90/","excerpt":"2019元旦快乐","text":"2019元旦快乐 相逢是首悠扬的歌，相识是杯醇香的酒， 相处是那南飞的雁，相知是根古老的藤。 健康是最佳的礼物，知足是最大的财富， 信心是最可贵的品德，关心是最真挚的问候， 牵挂是最无私的思念，祝福是最美好的话语！ 在此献上最美好的祝福祝各位朋友们2019年新年快乐！平安幸福！","categories":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"},{"name":"元旦","slug":"节日祝福/元旦","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/%E5%85%83%E6%97%A6/"}],"tags":[{"name":"节日祝福","slug":"节日祝福","permalink":"https://www.lollipopnougat.top/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"},{"name":"元旦","slug":"元旦","permalink":"https://www.lollipopnougat.top/tags/%E5%85%83%E6%97%A6/"}]},{"title":"面向对象的程序设计","slug":"面向对象的程序设计","date":"2018-12-30T07:06:15.000Z","updated":"2021-04-26T07:28:17.196Z","comments":true,"path":"2018/12/30/面向对象的程序设计/","link":"","permalink":"https://www.lollipopnougat.top/2018/12/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"面向对象的程序设计简介面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。","text":"面向对象的程序设计简介面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性。 面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。 特点面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个个体，即对象。目前已经被证实的是，面向对象程序设计推广了程序的灵活性和可维护性，并且在大型项目设计中广为应用。此外，面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。 发展面向对象是在结构化设计方法出现很多问题的情况下应运而生的。 结构化设计方法求解问题的基本策略是从功能的角度审视问题域。它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。 1. 审视问题域的视角 在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校学生管理系统来说，无论是简单还是复杂，始终是围绕学生和老师这两个客体实施。在自然界，每个客体都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。 通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在客体之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的客体，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。 结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行程序设计的时候，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，客体是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个客体，但管理图书的方法可能是截然不同的。结构化设计方法将审视问题的视角定位于不稳定的操作之上，并将描述客体的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。 2. 抽象级别 抽象是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性。抽象主要包括过程抽象和数据抽象。结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种抽象级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个客体属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。 3. 封装体 封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。这样做既可以实现对客体属性的保护作用，又可以提高软件系统的可维护性。只要用户接口不改变，任何封装体内部的改变都不会对软件系统的其他部分造成影响。结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。 4. 可重用性 可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用构件，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，结构化程序设计方法的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在C语言编写程序时使用大量的标准函数。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些数据类型发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用构件是如今应用领域对软件开发提出的新需求。 上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对软件开发的更高要求，面向对象由此产生。 面向对象程序设计从80年代以后成为了一种主导思想，这主要归功于C++在编写图形界面的应用。在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地适应了潮流。面向对象程序设计的思想也使事件处理式的程序设计更加广泛被应用 抽象的示例假如我们要写一个程序模拟一只羊，使用C语言面向过程的方法，首先想到的是开一个结构体，然后定义几个变量: 12345678struct Sheep&#123; int age; double height; double weight;&#125;;Sheep Jeff; //定义一只叫Jeff的羊 很容易，现在Jeff要跑，怎么办？于是就用一个run函数，把Jeff作为一个参数传递来实现: 123456void run(Sheep sheep)&#123; /* code */&#125;run(Jeff); 也很容易是吧，现在我们的Jeff遇到了羊大侠，羊大侠是站着跑的，怎么描述羊大侠站着跑呢？再写一个函数，站着跑？那假如又遇到穿鞋跑的怎么办？ 这时候如果使用面向对象的方法，将跑步作为对象的成员函数，把跑步的方法作为参数传递；这样，所有的羊都有了一种叫跑步的方法，就方便多了: 123456789101112131415161718class Sheep &#123;public: void run(string method=&quot;default&quot;); void mie();//咩private: int age; double height,weight;&#125;;//定义一个Sheep类Sheep Jeff;Jeff.run(); //Jeff使用默认的方法跑步Sheep YangDaXia;YangDaXia.run(&quot;onFoot&quot;); //羊大侠站着跑Sheep XiYangYang;XiYangYang.run(&quot;shoes&quot;); //喜羊羊穿鞋跑","categories":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.lollipopnougat.top/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"面向对象","slug":"面向对象","permalink":"https://www.lollipopnougat.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.lollipopnougat.top/tags/C-C/"}]},{"title":"The first one","slug":"The-first-one","date":"2018-12-30T03:44:32.000Z","updated":"2021-04-25T09:04:20.446Z","comments":true,"path":"2018/12/30/The-first-one/","link":"","permalink":"https://www.lollipopnougat.top/2018/12/30/The-first-one/","excerpt":"测试用页面","text":"测试用页面 第一个第一个第一个哈哈哈哈哈哈哈哈哈哈![^1][^1]: 这是脚注 这是1级标题这是斜体这是加粗这是斜体加粗 这是删除 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; &quot;hello,world!&quot;; return 0; //这是代码段&#125; 这是2级标题这是代码块 这是3级标题 这是引述 这是引述嵌套 这是4级标题这是百度一下 -[x] 选项一-[ ] 选项二-[ ] 选项三 这是5级标题 这是无序列表 这是无序列表 这是无序列表 这是有序列表 这是有序列表 这是有序列表","categories":[],"tags":[]}],"categories":[{"name":"杂谈","slug":"杂谈","permalink":"https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/"},{"name":"没啥用知识","slug":"杂谈/没啥用知识","permalink":"https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"name":"win32","slug":"win32","permalink":"https://www.lollipopnougat.top/categories/win32/"},{"name":"注册表","slug":"win32/注册表","permalink":"https://www.lollipopnougat.top/categories/win32/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"编程语言","slug":"编程语言","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"CSharp","slug":"编程语言/CSharp","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/"},{"name":"Python","slug":"编程语言/Python","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"},{"name":"爬虫开发","slug":"爬虫开发","permalink":"https://www.lollipopnougat.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/"},{"name":"python","slug":"爬虫开发/python","permalink":"https://www.lollipopnougat.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/python/"},{"name":"吐槽","slug":"吐槽","permalink":"https://www.lollipopnougat.top/categories/%E5%90%90%E6%A7%BD/"},{"name":"前端","slug":"前端","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"PowerShell","slug":"编程语言/PowerShell","permalink":"https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"},{"name":"后端","slug":"后端","permalink":"https://www.lollipopnougat.top/categories/%E5%90%8E%E7%AB%AF/"},{"name":"Nodejs","slug":"后端/Nodejs","permalink":"https://www.lollipopnougat.top/categories/%E5%90%8E%E7%AB%AF/Nodejs/"},{"name":"节日祝福","slug":"节日祝福","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"},{"name":"春节","slug":"节日祝福/春节","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/%E6%98%A5%E8%8A%82/"},{"name":"HTML","slug":"前端/HTML","permalink":"https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"元旦","slug":"节日祝福/元旦","permalink":"https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/%E5%85%83%E6%97%A6/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.lollipopnougat.top/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}],"tags":[{"name":"没啥用知识","slug":"没啥用知识","permalink":"https://www.lollipopnougat.top/tags/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"},{"name":"杂谈","slug":"杂谈","permalink":"https://www.lollipopnougat.top/tags/%E6%9D%82%E8%B0%88/"},{"name":"win32","slug":"win32","permalink":"https://www.lollipopnougat.top/tags/win32/"},{"name":"注册表","slug":"注册表","permalink":"https://www.lollipopnougat.top/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"},{"name":"python","slug":"python","permalink":"https://www.lollipopnougat.top/tags/python/"},{"name":"pip","slug":"pip","permalink":"https://www.lollipopnougat.top/tags/pip/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.lollipopnougat.top/tags/%E7%88%AC%E8%99%AB/"},{"name":"吐槽","slug":"吐槽","permalink":"https://www.lollipopnougat.top/tags/%E5%90%90%E6%A7%BD/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://www.lollipopnougat.top/tags/Vue-js/"},{"name":"网站搭建","slug":"网站搭建","permalink":"https://www.lollipopnougat.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"},{"name":"网络安全协会","slug":"网络安全协会","permalink":"https://www.lollipopnougat.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A/"},{"name":"PowerShell","slug":"PowerShell","permalink":"https://www.lollipopnougat.top/tags/PowerShell/"},{"name":"Node.js","slug":"Node-js","permalink":"https://www.lollipopnougat.top/tags/Node-js/"},{"name":"Express","slug":"Express","permalink":"https://www.lollipopnougat.top/tags/Express/"},{"name":"后端","slug":"后端","permalink":"https://www.lollipopnougat.top/tags/%E5%90%8E%E7%AB%AF/"},{"name":"节日祝福","slug":"节日祝福","permalink":"https://www.lollipopnougat.top/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"},{"name":"春节","slug":"春节","permalink":"https://www.lollipopnougat.top/tags/%E6%98%A5%E8%8A%82/"},{"name":"HTML","slug":"HTML","permalink":"https://www.lollipopnougat.top/tags/HTML/"},{"name":"元旦","slug":"元旦","permalink":"https://www.lollipopnougat.top/tags/%E5%85%83%E6%97%A6/"},{"name":"面向对象","slug":"面向对象","permalink":"https://www.lollipopnougat.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"C/C++","slug":"C-C","permalink":"https://www.lollipopnougat.top/tags/C-C/"}]}