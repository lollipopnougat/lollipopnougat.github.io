<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LNP</title>
  
  
  <link href="https://www.lollipopnougat.top/atom.xml" rel="self"/>
  
  <link href="https://www.lollipopnougat.top/"/>
  <updated>2023-05-21T02:26:46.551Z</updated>
  <id>https://www.lollipopnougat.top/</id>
  
  <author>
    <name>lollipopnougat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机械硬盘的坏扇区和磁记录方式</title>
    <link href="https://www.lollipopnougat.top/2022/11/12/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E7%9A%84%E5%9D%8F%E6%89%87%E5%8C%BA%E5%92%8C%E7%A3%81%E8%AE%B0%E5%BD%95%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.lollipopnougat.top/2022/11/12/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98%E7%9A%84%E5%9D%8F%E6%89%87%E5%8C%BA%E5%92%8C%E7%A3%81%E8%AE%B0%E5%BD%95%E6%96%B9%E5%BC%8F/</id>
    <published>2022-11-12T13:41:00.000Z</published>
    <updated>2023-05-21T02:26:46.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="机械硬盘的坏扇区、磁记录方式"><a href="#机械硬盘的坏扇区、磁记录方式" class="headerlink" title="机械硬盘的坏扇区、磁记录方式"></a>机械硬盘的坏扇区、磁记录方式</h3><p>10月初室友的笔记本电脑开机提示<a href="https://baike.baidu.com/item/S.M.A.R.T./4992688">S.M.A.R.T.</a>(Self-Monitoring Analysis and Reporting，是一种嵌入硬盘、固态硬盘和eMMC存储上的硬盘监控系统)有问题，笔者使用CrystalDiskInfo检测，发现机械硬盘的 <code>重新分配扇区计数</code> 出现了警告。重新分配扇区计数值在一段时间内显著增加，说明这个硬盘快要挂掉了。<br>昨天室友的笔记本电脑蓝屏了好几次，并时不时出现掉盘的现象，虽然系统盘并非那块机械，但是蓝屏错误大概率与那个要坏掉的机械硬盘有关，比如如果在访问虚拟内存时发生掉盘，就有可能出现各种意想不到的问题。<br>深夜那块硬盘在最后回光返照了一下以后，再也识别不到了(悲)。还好在昨天发觉不对劲之时已经抢救了一部分数据，造成的损失倒没有多少，可能就是需要买一块新的硬盘，然后把之前的软件和游戏重新安装……总之很麻烦就是了。</p><span id="more"></span><p>除了用一个新磁盘直接克隆受影响的磁盘外，对重新分配的扇区计数警告无法修复。然而，带有重新分配扇区计数警告的驱动器并不意味着该驱动器不能工作。只要驱动器运行，就可以继续使用它，但风险由用户自行承担，其实这也就是说明你还可以用，但是硬盘不能保证数据的可靠性了，而且未来有可能还会恶化，所以基本看到重新分配的扇区计数就得考虑购买新的磁盘准备替换了。</p><h3 id="机械硬盘的坏扇区"><a href="#机械硬盘的坏扇区" class="headerlink" title="机械硬盘的坏扇区"></a>机械硬盘的坏扇区</h3><p>从本质上讲，重新分配的扇区(也称为坏扇区或坏块或坏道)是磁盘上不再安全存储数据的区域，通俗来说就是硬盘上永久损坏一个地方，该部分中保存的所有信息都将丢失。</p><h4 id="坏扇区分类"><a href="#坏扇区分类" class="headerlink" title="坏扇区分类"></a>坏扇区分类</h4><p>坏扇区一般分为两种类型：硬坏扇区（也称为物理坏道）和软坏扇区（也称为逻辑坏道）。</p><ul><li>硬坏扇区<br>硬坏扇区主要是由物理损坏引起的，例如制造中出现问题、硬盘盘片受到物理划伤等；</li><li>软坏扇区<br>软坏扇区通常与软件问题有关，例如对硬盘的不当操作、文件系统错误等</li></ul><p>当系统无法读取、写入或验证存储在特定扇区的数据时，它将该扇区标记为坏扇区，并将存储的数据重新分配或映射到硬盘上的预留区域(空闲区域)。。预留区域是磁盘预留出来的区域，用于磁盘的正常运行，并防止由于坏道导致数据立即丢失。一般厂商都会留有一定量的冗余扇区作为备份，如果坏扇区的数量低于冗余的数量，那么这个磁盘暂时还是不太受影响；如果损坏继续扩大，超过了冗余，那么就是正常的数据受损了。</p><h4 id="造成坏扇区的原因"><a href="#造成坏扇区的原因" class="headerlink" title="造成坏扇区的原因"></a>造成坏扇区的原因</h4><ul><li><p>硬盘原本的质量瑕疵<br>受技术所限，现在的机械硬盘在生产时无法达到100%无坏扇区，往往会有一些物理坏道在硬盘盘的碟片上。厂商会将此类坏道列入工厂坏道表中，且完全隔离，不再使用。此类坏道被称为工厂坏扇区。</p></li><li><p>个人使用习惯不良<br>例如频繁读写资料、计算机不当关机、强制断电等等都可能会使硬盘产生坏道。</p></li><li><p>电压不稳<br>硬盘运作时，是依靠电流使盘片高速旋转，再用电流驱使磁头移动到盘片上产生磁场来达到读取及写入资料，若是电压不稳则会破坏盘片及磁头运作，导致坏道。</p></li><li><p>温度过高<br>硬盘运作温度过高，造成控制电路过热，会损害硬盘正常工作。</p></li><li><p>物理损坏<br>例如硬盘碰撞、震动、进水等，都可能会对硬盘产生损坏。</p></li></ul><h3 id="磁记录方式"><a href="#磁记录方式" class="headerlink" title="磁记录方式"></a>磁记录方式</h3><p>既然上文提到了磁盘坏扇区可能需要准备购买新的磁盘替换，如何选择磁盘又成了问题，并且近年来对存储性能要求的不断增加，使得大家意识到了机械硬盘的磁记录方式对存储性能的影响。最近几年，选购机械硬盘，常常会看到网上文章说 “千万不要选叠瓦盘” “性能差、易损坏” ，诸如此类说法。下面就简单介绍一下。</p><p><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112202121073-301934442.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112202121073-301934442.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="水平和垂直磁记录"></p><h4 id="水平磁记录方式-LMR"><a href="#水平磁记录方式-LMR" class="headerlink" title="水平磁记录方式(LMR)"></a>水平磁记录方式(LMR)</h4><p>机械硬盘的主要构造有马达、磁盘、磁头臂、磁头，硬盘运行的时候磁头悬浮在磁盘上方几纳米。<br>水平磁记录的磁盘，磁性记录颗粒的易磁化方向相对于碟片是平行的，如下图所示。颗粒沿着碟片圆周以端对端排列，所以便有机会出现SS（南）和NN（北）的互斥排列。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112203346244-1933166957.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112203346244-1933166957.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="水平记录"><br>磁头上的读取磁头可以读取磁盘上磁粒的极性，磁粒极性向右的时候为1，极性向左的时候为0，这样来达到读取数据的目的。写碰头可以改变磁粒的极性，达到改写或定入数据的目的。</p><p>由于现今硬盘的资料记录区块大小已经发展到宽度只有30纳米左右，而磁性记录颗粒的尺寸不断下降，但硬盘容量倍数上升，导致出现电磁学上的超顺磁效应（超顺磁性），在室温的情况下颗粒便会对随机的热运动异常敏感，失去稳定性，导致出现比特（0和1）翻转的现象，记录的数据因此被破坏，大大降低了硬盘的容量提升潜力。</p><h4 id="垂直磁记录方式-PMR"><a href="#垂直磁记录方式-PMR" class="headerlink" title="垂直磁记录方式(PMR)"></a>垂直磁记录方式(PMR)</h4><p>随着制造工艺的升级，写入磁头做的更小，出现了垂直磁记录，碰粒极性由原来的水平改为了垂直，极性向上为1，向下为0。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112203949974-1900133955.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112203949974-1900133955.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="垂直磁记录"><br>垂直磁记录技术中的磁性记录颗粒的易磁化方向相对于碟片是垂直的，因此允许使用单极磁头配合磁记录介质下的软磁层对其所产生的镜像效应所产生的“间隙磁场”来将信息写入磁记录介质中，而纵向写入技术采用环形磁头在间隙处产生的杂散场来将信息写入，因此，采用具有相同饱和磁化强度的材料所制备的垂直写入磁头，能产生两倍于纵向写入磁头所能产生的磁场。更大的写入磁场允许我们使用具有更高磁各向异性的材料来制备磁记录介质，而磁各向异性越强，出现超顺磁性效应的临界体积就越小，因此，碟片中的存储密度可以在一定程度内得到进一步的提高。比如LMR水平磁记录磁盘的存储密度仅有133GB/平方英寸，而PMR垂直磁记录磁盘可以达到1108GB/平方英寸，</p><h5 id="传统垂直磁记录-CMR"><a href="#传统垂直磁记录-CMR" class="headerlink" title="传统垂直磁记录(CMR)"></a>传统垂直磁记录(CMR)</h5><p>这种方式保留了以前PMR替代LMR时的传统技术，为了区别于叠瓦磁记录，这类磁记录方式被命名为CMR。</p><h5 id="叠瓦磁记录-SMR"><a href="#叠瓦磁记录-SMR" class="headerlink" title="叠瓦磁记录(SMR)"></a>叠瓦磁记录(SMR)</h5><p>这几年在PMR磁盘下又出现了一个新的分支，那就是SMR瓦楞式堆叠(叠瓦磁记录)，利用了叠瓦磁道的原理，相对PMR可提高存储密度和每个驱动器的整体存储容量，但是写入性能却下降了。</p><p>为什么SMR磁盘性能比CMR磁盘性能下降了呢？在此之前需要先说明磁盘是如何工作的。</p><h4 id="磁盘先验知识"><a href="#磁盘先验知识" class="headerlink" title="磁盘先验知识"></a>磁盘先验知识</h4><p>为了能精准的定位数据在磁盘的具体位置，磁盘被划分了无数个磁道，磁道又被划分成多个扇区。<img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112205312401-1875050924.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112205312401-1875050924.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="磁盘寻道寻址原理"><br>在读取数据的时候先定位数据所在的扇区的磁道的位置，磁头先摆动到数据所在的磁道的上方，然后等待着数据所在的扇区转过来，就可以读取数据了，这就是机械硬盘的寻道和寻址功能。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112205740453-1772517176.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112205740453-1772517176.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="磁道"></p><h5 id="CMR工作原理"><a href="#CMR工作原理" class="headerlink" title="CMR工作原理"></a>CMR工作原理</h5><p>由于物理原因，写磁头比读磁头宽，所以写磁头写入数据后再用读磁头读取数据时，只有读磁头扫过的中间部分是有效的。<br>读磁头只需要窄窄数据带就可以读取数据了，但写入磁头无法做的再小了，所以磁道的上下方的空余部分其实是没用的。<br>CMR磁盘为了保证写磁头不干扰到相邻磁道，通过写入彼此平行而不重叠的磁道来记录数据，如下图所示，<br>磁道与磁道之间留出了一定的间隔，不过导致了数据密度变的低了，很多空间就被浪费了。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112210142778-2115941972.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112210142778-2115941972.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="CMR写入数据"></p><h5 id="SMR工作原理"><a href="#SMR工作原理" class="headerlink" title="SMR工作原理"></a>SMR工作原理</h5><p>而叠瓦磁记录技术的硬盘写入的新磁道则与先前写入的磁道部分重叠，从而使先前的磁道更窄，因此能拥有更高的磁道密度。由此可以看出，使用叠瓦磁技术的磁道相互重叠，与用作屋顶的瓦片堆叠方式类似。<img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112204337600-53637510.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112204337600-53637510.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="瓦片"><br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112210633156-1151233967.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112210633156-1151233967.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SMR"></p><p>因为读取头较小，因此SMR磁盘的读取与一般的PMR磁盘并无不同，但是写入就有很大区别了，由于叠瓦磁盘的磁道是堆叠在一起的，写磁头比较宽，所以写入数据的时候会把下面的磁道也一起写入，下一个磁道写入的时候覆盖了上一个磁道重复写入的数据的同时又把下一个磁道又重复写入了。依此类推把数据全部写入磁道。<img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112210924314-2065845292.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221112210924314-2065845292.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="SMR写入1"><br>这样一来，改写某一磁道的数据势必会影响下一个磁道的数据，所以必须要有一个缓冲区先把下一磁盘的数据放入缓冲区，改写完目标数据后，再从把缓冲区把数据重新填回来，这样可能会写到下面的磁道中，这样一来需要重复刚才的动作，直到把所有覆盖的部分处理好。可以看到本来在CMR中写一次就可以完成的任务，放在SMR磁盘身上可能要写很多次，并且需要一个较大的缓存支持(一般SMR磁盘的缓存都是在256MB左右，CMR磁盘的缓存在64MB左右)。</p><p>当然要改写某一磁道的数据时并不是要把它后面所有的磁道都挨个重写，要不然如果是改写最外圈的磁道岂不是要把整个碟片全部重写！那样的话实在是太麻烦了。所以整个磁盘并不是从头到尾全部采用叠瓦技术的，而是以扇区为最大单位，每个扇区内的磁道都是叠瓦，各个扇区之间留有间隔、互不干扰。改写某一磁道数据只会影响所在扇区内的磁道，其它扇区不受影响。</p><h3 id="SMR磁盘的优点及缺点"><a href="#SMR磁盘的优点及缺点" class="headerlink" title="SMR磁盘的优点及缺点"></a>SMR磁盘的优点及缺点</h3><p>优点：</p><ol><li><strong>体积减小</strong>。SMR瓦楞式堆叠磁盘由于采用了磁道堆叠技术，使得数据存储密度更高，同等容量的磁盘碟片数量更少，磁盘的体积会更小，更轻便。</li><li><strong>价格便宜</strong>。因同等容量的磁盘碟片数量更少，也就大大减少了成本，所以价格上也会比CMR磁盘更便宜。</li></ol><p>缺点：</p><ol><li><strong>随机写入慢</strong>。因改写磁道中间数据时会影响其它磁道的数据，改写一条磁道的数据需操作多次才能完成，大大增加了工作量，所以在改写数据时比CMR磁盘性能上有很大的差距，特别是剩余空间越少时读写越慢，慢到令人发指，而且在写入大文件超过缓存大小时，还会出现速度“断崖式”下降。</li><li><strong>磁盘寿命短</strong>。磁盘读写的次数与其寿命是有关的，叠瓦盘在改写数据时进行的读写次数远超CMR磁盘，所以它的寿命相比CMR磁盘更短。</li><li><strong>转速低导致读写都慢</strong>，CMR磁盘普遍是7200转，而到了叠瓦盘则变成了5400转，因为叠瓦盘数据密度变大，转速务必要降低，而转速直接影响读写速度，所以即便数据密度变大了由于转速的降低使其读写性能不增反降。</li></ol><h3 id="如何辨别CMR和SMR？"><a href="#如何辨别CMR和SMR？" class="headerlink" title="如何辨别CMR和SMR？"></a>如何辨别CMR和SMR？</h3><p>至于怎么分辨SMR也很简单，选购机械硬盘的时候尽量选择7200转64MB缓存的，不要选5400转256缓存的就可以了。一般来说1TB内的硬盘都是CMR机械硬盘，2TB以上基本都是SMR叠瓦盘。</p><p>本应用在高容量HDD上的SMR技术近年来逐渐向1T、2T这种较低容量的硬盘靠近。而硬盘厂商们却对此闭口不提，消费者对此也不知情。西部数据(WD)、希捷(ST)、东芝(TOSHIBA)都曾在或仍在未标明磁盘是否使用 SMR 技术的情况下出售硬盘。这导致了很大的争议。而被曝出混用也是有用户因为在NAS中组RAID报错，经过挖掘之后才发现的，导致消费者投诉，主要硬盘品牌最终公布了使用 SMR 技术的硬盘产品型号并保证特定系列型号不使用 SMR 技术，其公布信息可以去品牌官网查询，或参考<a href="https://tech.sina.com.cn/roll/2020-04-29/doc-iircuyvi0481065.shtml">链接</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;机械硬盘的坏扇区、磁记录方式&quot;&gt;&lt;a href=&quot;#机械硬盘的坏扇区、磁记录方式&quot; class=&quot;headerlink&quot; title=&quot;机械硬盘的坏扇区、磁记录方式&quot;&gt;&lt;/a&gt;机械硬盘的坏扇区、磁记录方式&lt;/h3&gt;&lt;p&gt;10月初室友的笔记本电脑开机提示&lt;a href=&quot;https://baike.baidu.com/item/S.M.A.R.T./4992688&quot;&gt;S.M.A.R.T.&lt;/a&gt;(Self-Monitoring Analysis and Reporting，是一种嵌入硬盘、固态硬盘和eMMC存储上的硬盘监控系统)有问题，笔者使用CrystalDiskInfo检测，发现机械硬盘的 &lt;code&gt;重新分配扇区计数&lt;/code&gt; 出现了警告。重新分配扇区计数值在一段时间内显著增加，说明这个硬盘快要挂掉了。&lt;br&gt;昨天室友的笔记本电脑蓝屏了好几次，并时不时出现掉盘的现象，虽然系统盘并非那块机械，但是蓝屏错误大概率与那个要坏掉的机械硬盘有关，比如如果在访问虚拟内存时发生掉盘，就有可能出现各种意想不到的问题。&lt;br&gt;深夜那块硬盘在最后回光返照了一下以后，再也识别不到了(悲)。还好在昨天发觉不对劲之时已经抢救了一部分数据，造成的损失倒没有多少，可能就是需要买一块新的硬盘，然后把之前的软件和游戏重新安装……总之很麻烦就是了。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="没啥用知识" scheme="https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="没啥用知识" scheme="https://www.lollipopnougat.top/tags/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
    <category term="杂谈" scheme="https://www.lollipopnougat.top/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>快充协议如何工作</title>
    <link href="https://www.lollipopnougat.top/2022/11/11/%E5%BF%AB%E5%85%85%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/"/>
    <id>https://www.lollipopnougat.top/2022/11/11/%E5%BF%AB%E5%85%85%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C/</id>
    <published>2022-11-10T16:34:00.000Z</published>
    <updated>2023-05-21T02:26:37.766Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快充协议如何工作"><a href="#快充协议如何工作" class="headerlink" title="快充协议如何工作"></a>快充协议如何工作</h3><p>前几天跟朋友聊天谈到了网上有人使用非官方数据线和充电器给使用 USB Type-C 口的 iPad Pro 充电，结果导致 iPad 损坏的情况。联想到快充的方法无非是提高电压或提高电流，我们猜测与快充协议有关，于是去查了一下，找到一篇写得不错的<a href="https://www.chongdiantou.com/archives/57970.html">文章</a>，我们看完以后，感觉的确不应该随便混用不同品牌的充电头和充电线，如果错误使用可能会发生意想不到的事情。</p><span id="more"></span><p>鉴于我们并不是微电子行业的从业人员(计算机专业的学生而已)，这种知识可能也就是所谓“没啥用”知识了(以下省略“没啥用的知识又增加了.jpg”图)，不过感觉既然看到了，还是记录一下，或者干脆搞个“没啥用知识”系列，写点冷知识，感觉还不错？</p><p>说干就干，下面转载这篇<a href="https://www.chongdiantou.com/archives/57970.html">文章</a>，作为没啥用知识系列的第一篇。</p><h3 id="快充协议是如何工作的"><a href="#快充协议是如何工作的" class="headerlink" title="快充协议是如何工作的"></a>快充协议是如何工作的</h3><p>快充协议是充电器与设备沟通握手所需的“语言”，只有正确“对话”后，才可以“握手”成功，进行快速充电。我们一步一步来看不同的快充协议是怎样工作的。</p><h4 id="旧式快充协议"><a href="#旧式快充协议" class="headerlink" title="旧式快充协议"></a>旧式快充协议</h4><p>几年前快充协议十分简单，简单到类似交通信号灯，幼儿园小朋友都可以通过颜色判断信号含义。设备与充电器不需要很“聪明”就可以读懂双方的需求，不管是研发难度还是物料成本都简单便宜。而快充协议的红绿灯，则是采用D+D-电压进行信息传输。<br>旧式快充协议都是使用USB2.0通讯接口，常见于USB-A接口。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221110235225782-1869726941.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221110235225782-1869726941.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="USB-A输出母座"><br>图片中是一个在移动电源上的USB-A输出母座，可以看到他与主板连接的只有四个引脚，其中两侧是用于传输电流的VCC、GND引脚，中间的是用于传输数据的D+、D-引脚。D+D-的“D”是数据Data的意思，充电端与接受电力的设备之间通过D+D-进行数据通讯，进而握手快充协议。</p><p><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221110235849636-1347674725.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221110235849636-1347674725.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="数据线"></p><p>再来看看数据线，一般来说USB2.0数据线USB-A接口上只有4个触点，与USB-A母座定义相同，最外面两个是用来传输电流的，中间两个是用来传输数据的。VCC、GND较长，D+D-较短，那是故意设计，为了拔出时先断开数据连接，后断开电力供给。</p><ol><li><p>APPLE 2.4A</p><p> 在大家都是5V充电的年代，iPhone直接充电只有5W，需要充电器有特殊的识别电阻才可以获得更大充电功率。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000043029-400010398.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000043029-400010398.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="苹果充电芯片"><br> 图中PCB左边是两个USB-A输出口的焊盘，共用了一颗支持双路智能识别的协议芯片，iPhone插入后，协议芯片调整USB-A接口的D+D-电压为2.7V/2.7V，提供APPLE 2.4A的识别。而最右边的USB-A接口，则是简单地将D+D-直接连起来短接，提供DCP 5V1.5A的输出识别。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000211217-865490449.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000211217-865490449.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="苹果充电测试"><br> 通过POWER-Z测试仪监测iPhone 8 Plus的充电，可以发现当前D+D-电压为2.66V/2.65V，接近APPLE2.4A识别协议的2.7V/2.7V，iPhone 8 Plus进入APPLE2.4A充电模式，功率达到12W。</p></li><li><p>QC2.0<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000348665-522442080.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000348665-522442080.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="QC2.0"><br> 进入QC2.0高压快充年代后，USB-A接口不再是简单的5V输出，而是可以升压至9V甚至12V电压获取大功率电力传输，这存在一定危险，什么情况才需要升压而不会烧坏设备？所以QC年代智能识别芯片做出了较大的进化，包含了多种不同快充协议，QC、FCP、AFC等等，同样是通过控制D+D-电压来进行轮询判断。例如QC2.0快充需要输出9V的话，D+D-电压就是3.3V/0.5V，需要输出12V的话，D+D-电压就调节为0.5v/0.5v，没有反馈就不进行升压，保持5V输出确保安全。</p></li><li><p>MTK PE<br> 如果说QC2.0基于D+D-电压进行通讯的方式类似红绿灯的话，魅族手机采用的MTK PE快充则是类似打电报的摩尔密码，嘀——嘀嘀嘀——嘀嘀——嘀嘀嘀——嘀——嘀——这样进行通讯。PE快充不需要D+D-数据传输，甚至只有VCC GND的两芯数据线都可以成功使用并触发PE快充，并且PE的电流脉冲信号近乎于无损数字传输，不会像D+D-那样出现电压值误差无法触发快充的情况。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000502385-1519453697.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000502385-1519453697.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="魅族充电测试"><br> 图中是POWER-Z USB测试仪抓取到魅族触发PE快充时的电流脉冲，可以看到电流的通断与间隔就像打电报一样进行信息传递，信息传递握手正确后，充电器输出电压从5V跳至7V再跳至9V。但PE快充太少众，市场占有率低没有话语权，配件选择面也少，甚至现在连魅族新机型都不再支持PE快充，这就是题外话了。</p></li></ol><h4 id="USB-PD高级通讯协议"><a href="#USB-PD高级通讯协议" class="headerlink" title="USB PD高级通讯协议"></a>USB PD高级通讯协议</h4><p>在进入USB PD快充时代后，充电器与数码产品的物理接口从USB-A口全面过渡到USB-C接口，USB-C接口拥有更多的Pin脚，支持更高的电力传输上限，并且完全不同于以往简单的D+D-识别，而是智慧式数据包双向沟通的手段进行更加复杂的通讯。如果说旧式快充协议是幼儿园学生看红绿灯过马路的话，USB PD快充协议就是两个成年人在进行微信聊天这种复杂程度。</p><p>我们来先看看接口的区别，USB-C物理接口满pin形态高达24个针脚，但用于充电不管多大功率，都只要USB2.0形态的12个针脚就足够了，满pin多出来的针脚是用于跑USB3.0/3.1/3.2/雷电等高速数据的，与充电无关，下面我们重点介绍一下USB2.0标准pin脚的USB-C接口。</p><p><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000633109-570411594.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000633109-570411594.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="usb-c"></p><p>可以看到USB-C用于电力传输的VBUS、GND一共有两对也就是4根针脚，除了支持正反面盲插外，多了一倍的针脚让他可以支撑更大功率的电力传输。在接口的中间可以看到D+D-这两个USB-A标准上的针脚，所以USB-C可以向下兼容数据通讯。而USB PD最关键的是CC针脚，CC线是USB PD快速充电标准用于信息交换的通道，没有CC针脚的话就无法进行PD快充。一些魔改USB-A口，虽然形态是A口，但中间新增了一根针脚CC线，所以可以在A口上跑USB PD协议。</p><p><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000750357-136570819.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000750357-136570819.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="c口芯片"></p><p>USB-C通讯采用可编程语言进行双向通讯，需要用到高性能USB PD控制器，芯片体积、针脚数量、复杂程度都远超QC年代的协议芯片。下面我们通过POWER-Z USB测试仪抓取充电器与手机之间的通讯包，看看在充电过程中发生了什么事情。</p><ol><li><p>PD2.0<br> USB PD快速充电标准现在已经发展到PD 3.0，数字越大的版本所支持的功能越多，我们先看看PD2.0。PD2.0快充支持固定电压档切换，可以根据充电器广播选择需要的固定电压。POWER-Z USB测试仪上可以看到，设备与充电器通讯后从5V3A跳转到了9V3A这个电压档进行充电。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000910055-1725056275.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111000910055-1725056275.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="pd2.0"><br> 我们再通过POWER-Z电脑端APP抓包看看，信息端口栏目分别是两个方向的传输，Source—&gt;Sink、Source&lt;—Sink。其中Source—&gt;Sink是代表发射端向接收端发出的通讯，例如充电器对手机，Source&lt;—Sink是接收端反馈信息给发射端，例如手机对充电器，搞懂了方向那我们接下来就能看懂他们之间的通讯方式。</p><p> USB PD通讯流程我们以PD 2.0充电器作为举例，线缆插上后供电端与设备并不是立刻开始充电，而是先打招呼，充电器进行广播PDO电压，充电器告诉手机，我支持5V2.4A / 9V3A / 15V3A / 20V2.25A四个固定电压输出。</p><p> 手机接收到PDO广播信息后，先是反馈给充电器，告知需要5V2.4A这个电压档，充电器收到反馈后回复手机，电力已经调整至5V2.4A。之后手机充电器再互相通讯，手机请求调整输出电压至9V2A，充电器告知请求已经收到，正在调整至9V2A，这样完成一个通讯阶段。</p></li><li><p>PD 3.0 PPS<br> PD3.0 PPS与PD2.0相比原理接近，多了PPS电压子集。PPS电压子集是一组以0.02V跨度为调整幅度的供电电压集，可以精细地进行电压微调，让电荷泵快充、直充变成可能。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001039035-2082706243.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001039035-2082706243.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="pd3.01"><br> PD 3.0 PPS插入线缆后，充电器向手机发出一个数据包（PDO广播），告诉手机我是一个充电器，拥有5V3A / 9V3A / 12V3A / 15V3A / 20V2.25A四个固定PDO与5-11V3A / 5-16V3A两组PPS。手机接收到这个广播后，对充电器反馈信息，请求输出5V3A电压。充电器接受到电压调整请求，并告知手机已经调整OK，手机反馈说已经做好充电准备，开始5V3A进行充电。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001148219-1039539452.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001148219-1039539452.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="pd3.02"><br> 在充电的途中，手机发出信息告知充电器，我需要调整电压，请求将输出电压调整至8.66V3A，充电器接收到电压调整请求，将输出从5V3A调整至8.66V3A。之后手机每秒发送多次调整电压指令，每次都告知充电器将电压下调0.02V，充电器也如实进行调整。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001243255-1076452533.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001243255-1076452533.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="pd3.03"><br> 在经过了五百多次的通讯进行电压微调后，最终稳定在了7V3A这一个电压进行充电，以达到充的快温升低的目的，这就是PPS快充协议的通讯过程。</p></li></ol><h4 id="私有协议"><a href="#私有协议" class="headerlink" title="私有协议"></a>私有协议</h4><ol><li><p>全私有协议</p><p> 某些厂家会对部分设备开发私有快充协议，在通讯过程中加密了信息流，用户想要获得最佳充电体验只能使用原厂配件。这种做法一来是因为目前的标准无法满足厂家需求，例如USB PD上限只有20V5A 100W，二来可以建设私有配件生态圈，足够的利润支撑技术研发达到良性发展，这么做无可厚非。<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001418583-615665288.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001418583-615665288.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="私有1"></p></li><li><p>半私有协议<br> <img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001450796-573099744.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001450796-573099744.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="半私有"><br> 部分厂商则是采用半私有协议，例如三星45W AFC快充，基于PD3.0 PPS开发的快速充电协议进行微调修改，因为未进行加密，所以市面上部分第三方配件也可以通用，用户选择配件范围较大。</p></li></ol><h4 id="USB-C接口统一对快充的好处"><a href="#USB-C接口统一对快充的好处" class="headerlink" title="USB-C接口统一对快充的好处"></a>USB-C接口统一对快充的好处</h4><p>多年前接口未统一时，存在Micro USB、Mini USB、异形排针、DC圆口等多种不同接口，就连供电电压都存在差异，混沌的乱象阻碍着发展。USB-C好比灯泡卡座，淘汰其他接口大统一为USB-C接口标准，让万千设备均处以相同标准下运行，相同的物理接口，相同的通讯标准。生产商技术研发不再需要为各种标准而设计不同规格产品，快充技术得到飞速发展，用户作为消费者也在享受USB-C大统一的便利。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001555979-1618084248.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001555979-1618084248.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="灯泡卡座"></p><p>USB-C是灯泡卡座的话，充电器就好比灯泡，基于USB-C标准而制造的充电器诞生出18Ｗ、30Ｗ、45Ｗ、65Ｗ、100Ｗ以及未来更大功率，用户可以根据自己需求选择不同功率的产品使用，无需担心接口问题。<br><img src="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001615289-343455141.png" class="lazyload" data-srcset="https://img2022.cnblogs.com/blog/1653187/202211/1653187-20221111001615289-343455141.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="灯泡"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于手机、笔记本等设备来说，快充协议必不可少，没有快充协议支撑的话充电功率会受限在非常低的功率，得益于USB-C统一标准让快充全面普及，不管是入门机型还是旗舰产品都支持快充，不同消费层用户都可以享受快充带来的乐趣。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;快充协议如何工作&quot;&gt;&lt;a href=&quot;#快充协议如何工作&quot; class=&quot;headerlink&quot; title=&quot;快充协议如何工作&quot;&gt;&lt;/a&gt;快充协议如何工作&lt;/h3&gt;&lt;p&gt;前几天跟朋友聊天谈到了网上有人使用非官方数据线和充电器给使用 USB Type-C 口的 iPad Pro 充电，结果导致 iPad 损坏的情况。联想到快充的方法无非是提高电压或提高电流，我们猜测与快充协议有关，于是去查了一下，找到一篇写得不错的&lt;a href=&quot;https://www.chongdiantou.com/archives/57970.html&quot;&gt;文章&lt;/a&gt;，我们看完以后，感觉的确不应该随便混用不同品牌的充电头和充电线，如果错误使用可能会发生意想不到的事情。&lt;/p&gt;</summary>
    
    
    
    <category term="杂谈" scheme="https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    <category term="没啥用知识" scheme="https://www.lollipopnougat.top/categories/%E6%9D%82%E8%B0%88/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="没啥用知识" scheme="https://www.lollipopnougat.top/tags/%E6%B2%A1%E5%95%A5%E7%94%A8%E7%9F%A5%E8%AF%86/"/>
    
    <category term="杂谈" scheme="https://www.lollipopnougat.top/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>Windows注册表的字段类型</title>
    <link href="https://www.lollipopnougat.top/2021/06/14/Windows%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>https://www.lollipopnougat.top/2021/06/14/Windows%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2021-06-14T03:46:51.000Z</published>
    <updated>2021-08-14T11:28:45.894Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍一下windows注册表的数据类型"><a href="#介绍一下windows注册表的数据类型" class="headerlink" title="介绍一下windows注册表的数据类型"></a>介绍一下windows注册表的数据类型</h3><span id="more"></span><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>主要有6种(其实还有更多，但常用就6种吧)</p><h5 id="二进制-REG-BINARY"><a href="#二进制-REG-BINARY" class="headerlink" title="二进制(REG_BINARY)"></a>二进制(REG_BINARY)</h5><p>在注册表中，二进制是没有长度限制的，可以是任意个字节的长度。</p><h5 id="DWORD值-REG-DWORD"><a href="#DWORD值-REG-DWORD" class="headerlink" title="DWORD值(REG_DWORD)"></a>DWORD值(REG_DWORD)</h5><p>DWORD值是一个32位（4个字节，即双字）长度的数值。在注册表编辑器中，系统以十六进制的方式显示DWORD值。</p><h5 id="字符串值-REG-SZ"><a href="#字符串值-REG-SZ" class="headerlink" title="字符串值(REG_SZ)"></a>字符串值(REG_SZ)</h5><p>在注册表中，字符串值一般用来表示文件的描述、硬件的标识等，通常它是以空字符(‘\0’)结尾的字符串。</p><h5 id="QWORD值-REG-QWORD"><a href="#QWORD值-REG-QWORD" class="headerlink" title="QWORD值(REG_QWORD)"></a>QWORD值(REG_QWORD)</h5><p>QWORD值是一个64位（8个字节，即四字）长度的数值。在注册表编辑器中，系统以十六进制的方式显示QWORD值。</p><h5 id="多字符串值-REG-MULTI-SZ"><a href="#多字符串值-REG-MULTI-SZ" class="headerlink" title="多字符串值(REG_MULTI_SZ)"></a>多字符串值(REG_MULTI_SZ)</h5><p>由两个空字符终止的空终止字符串数组。</p><h5 id="可扩充字符串值-REG-EXPAND-SZ"><a href="#可扩充字符串值-REG-EXPAND-SZ" class="headerlink" title="可扩充字符串值(REG_EXPAND_SZ)"></a>可扩充字符串值(REG_EXPAND_SZ)</h5><p>包含对环境变量的未扩展引用的空终止字符串（例如，“%PATH%”）。</p><h4 id="代码相关"><a href="#代码相关" class="headerlink" title="代码相关"></a>代码相关</h4><p>这个其实是写上次那个jdk部署工具的过程中遇到的问题，</p><p>一般的方法取可扩充字符串的值结果都会自动填写环境变量实际的值，而想要的功能是注册表的<code>可扩充字符串值</code>如何不自动扩展环境变量</p><p>由于 <code>.net</code> 封装的注册表未提供此方面的方法，因此采用 <code>C#</code> 调 <code>winapi</code> 的方法解决</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取注册表值</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;advapi32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">uint</span> <span class="title">RegQueryValueEx</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    UIntPtr hKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">string</span> lpValueName,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">int</span> lpReserved,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">ref</span> RegistryValueKind lpType,</span></span></span><br><span class="line"><span class="function"><span class="params">    IntPtr lpData,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">ref</span> <span class="built_in">int</span> lpcbData</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打开注册表键</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;advapi32.dll&quot;</span>, CharSet = CharSet.Auto)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">RegOpenKeyEx</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    UIntPtr hKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">string</span> subKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">int</span> ulOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">int</span> samDesired,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">out</span> UIntPtr hkResult</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span>;</span><br><span class="line"><span class="comment">// 关闭注册表键 因为是非托管内存，GC不会自动回收，一定需要手动释放掉注打开册表键的句柄</span></span><br><span class="line">[<span class="meta">DllImport(<span class="meta-string">&quot;advapi32.dll&quot;</span>, SetLastError = true)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">extern</span> <span class="built_in">int</span> <span class="title">RegCloseKey</span>(<span class="params">UIntPtr hKey</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> UIntPtr HKEY_LOCAL_MACHINE = <span class="keyword">new</span> UIntPtr(<span class="number">0x80000002</span>u);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">int</span> READ_FLAG_MASK = <span class="number">0x20019</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">string</span> <span class="title">GetLMNamedValue</span>(<span class="params"><span class="built_in">string</span> valName, <span class="built_in">string</span> regPath</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            UIntPtr hKey = UIntPtr.Zero;</span><br><span class="line">            IntPtr pResult = IntPtr.Zero;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (RegOpenKeyEx(HKEY_LOCAL_MACHINE, regPath, <span class="number">0</span>, READ_FLAG_MASK, <span class="keyword">out</span> hKey) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">int</span> size = <span class="number">0</span>;</span><br><span class="line">                    RegistryValueKind type = RegistryValueKind.Unknown;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获取需要的缓冲区大小</span></span><br><span class="line">                    <span class="built_in">uint</span> retVal = RegQueryValueEx(hKey, valName, <span class="number">0</span>, <span class="keyword">ref</span> type, IntPtr.Zero, <span class="keyword">ref</span> size);</span><br><span class="line">                    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Marshal 提供了一个方法集合，这些方法用于分配非托管内存、复制非托管内存块、将托管类型转换为非托管类型，此外还提供了在与非托管代码交互时使用的其他杂项方法。</span></span><br><span class="line">                    pResult = Marshal.AllocHGlobal(size);</span><br><span class="line"></span><br><span class="line">                    retVal = RegQueryValueEx(hKey, valName, <span class="number">0</span>, <span class="keyword">ref</span> type, pResult, <span class="keyword">ref</span> size);</span><br><span class="line">                    <span class="keyword">if</span> (retVal != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationException(<span class="string">$&quot;查询错误 &#x27;<span class="subst">&#123;regPath&#125;</span>\\<span class="subst">&#123;valName&#125;</span>: 0x<span class="subst">&#123;Marshal.GetLastWin32Error().ToString(<span class="string">&quot;x2&quot;</span>)&#125;</span>, 返回: <span class="subst">&#123;retVal&#125;</span>&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">switch</span> (type)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> RegistryValueKind.String:</span><br><span class="line">                                <span class="keyword">return</span> Marshal.PtrToStringAnsi(pResult);</span><br><span class="line">                            <span class="keyword">case</span> RegistryValueKind.DWord:</span><br><span class="line">                                <span class="keyword">return</span> Marshal.ReadInt32(pResult).ToString();</span><br><span class="line">                            <span class="keyword">case</span> RegistryValueKind.QWord:</span><br><span class="line">                                <span class="keyword">return</span> Marshal.ReadInt64(pResult).ToString();</span><br><span class="line">                            <span class="keyword">case</span> RegistryValueKind.ExpandString:</span><br><span class="line">                                <span class="comment">// 直接输出原始内容</span></span><br><span class="line">                                <span class="keyword">return</span> Marshal.PtrToStringAnsi(pResult);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationException(<span class="string">$&quot;打开注册表键错误 HKLM\\<span class="subst">&#123;regPath&#125;</span>: <span class="subst">&#123;Marshal.GetLastWin32Error().ToString(<span class="string">&quot;1:x&quot;</span>)&#125;</span>&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (hKey != UIntPtr.Zero)</span><br><span class="line">                &#123;</span><br><span class="line">                    RegCloseKey(hKey);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (pResult != IntPtr.Zero)</span><br><span class="line">                &#123;</span><br><span class="line">                    Marshal.FreeHGlobal(pResult);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍一下windows注册表的数据类型&quot;&gt;&lt;a href=&quot;#介绍一下windows注册表的数据类型&quot; class=&quot;headerlink&quot; title=&quot;介绍一下windows注册表的数据类型&quot;&gt;&lt;/a&gt;介绍一下windows注册表的数据类型&lt;/h3&gt;</summary>
    
    
    
    <category term="win32" scheme="https://www.lollipopnougat.top/categories/win32/"/>
    
    <category term="注册表" scheme="https://www.lollipopnougat.top/categories/win32/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
    
    <category term="win32" scheme="https://www.lollipopnougat.top/tags/win32/"/>
    
    <category term="注册表" scheme="https://www.lollipopnougat.top/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>自己写个jdk部署工具</title>
    <link href="https://www.lollipopnougat.top/2021/06/05/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AAjdk%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/"/>
    <id>https://www.lollipopnougat.top/2021/06/05/%E8%87%AA%E5%B7%B1%E5%86%99%E4%B8%AAjdk%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/</id>
    <published>2021-06-05T14:58:17.000Z</published>
    <updated>2021-08-14T11:19:44.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用-NET-5的-C-编写了个jdk部署工具"><a href="#使用-NET-5的-C-编写了个jdk部署工具" class="headerlink" title="使用.NET 5的 C# 编写了个jdk部署工具"></a>使用.NET 5的 C# 编写了个jdk部署工具</h3><ul><li>自动用aria2下载jdk16</li><li>检查下载文件完整性(sha-256)</li><li>支持java环境变量配置</li></ul><span id="more"></span><h4 id="项目类"><a href="#项目类" class="headerlink" title="项目类"></a>项目类</h4><ul><li>环境变量管理类</li><li>http辅助类</li><li>aria2辅助类</li><li>Json请求格式类</li><li>Zip文件辅助类</li><li>完整性检测辅助类</li></ul><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>本项目采用 <code>C#</code> 采用rpc控制 <code>aria2</code> 下载jdk16，经检测解压后配置环境变量</p><p>rpc实际控制方法为向 <code>aria2</code> 发起 <code>post</code> 请求，然后 <code>aria2</code> 接收回复</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ol><li>构造请求调用的json数据</li><li>使用aria2辅助类启动 <code>aria2</code> 主程序</li><li>发起下载请求</li><li>每 <code>500ms</code> 检查一次 <code>aria2</code> 返回的状态，如果下载结束继续进行，否则持续检查</li><li>下载完成检查文件 <code>SHA256</code> 与给出的是否一致，不一致给出提示退出</li><li>使用zip辅助类解压jdk的压缩包</li><li>通过环境变量管理类设置环境变量</li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>此程序与aria2两进程间通信(rpc)</li><li>http POST方法的C#实现</li><li>SHA-256算法</li><li>注册表的可扩充字符串值自动填充环境问题</li></ul><h4 id="待更新"><a href="#待更新" class="headerlink" title="待更新"></a>待更新</h4>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;使用-NET-5的-C-编写了个jdk部署工具&quot;&gt;&lt;a href=&quot;#使用-NET-5的-C-编写了个jdk部署工具&quot; class=&quot;headerlink&quot; title=&quot;使用.NET 5的 C# 编写了个jdk部署工具&quot;&gt;&lt;/a&gt;使用.NET 5的 C# 编写了个jdk部署工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;自动用aria2下载jdk16&lt;/li&gt;
&lt;li&gt;检查下载文件完整性(sha-256)&lt;/li&gt;
&lt;li&gt;支持java环境变量配置&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="CSharp" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/CSharp/"/>
    
    
    <category term="win32" scheme="https://www.lollipopnougat.top/tags/win32/"/>
    
    <category term="注册表" scheme="https://www.lollipopnougat.top/tags/%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>python包的setup文件</title>
    <link href="https://www.lollipopnougat.top/2021/01/12/python%E5%8C%85%E7%9A%84setup%E6%96%87%E4%BB%B6/"/>
    <id>https://www.lollipopnougat.top/2021/01/12/python%E5%8C%85%E7%9A%84setup%E6%96%87%E4%BB%B6/</id>
    <published>2021-01-12T07:27:04.000Z</published>
    <updated>2021-08-14T10:04:22.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="鸽了一年，突然想起来我还有个博客"><a href="#鸽了一年，突然想起来我还有个博客" class="headerlink" title="鸽了一年，突然想起来我还有个博客"></a>鸽了一年，突然想起来我还有个博客</h3><p>正好最近写了个超级简陋的 <code>pypi</code> 源管理工具，学习了一波setup.py文件的撰写</p><span id="more"></span><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>python开发者们习惯使用 <code>pip</code> 来安装一些第三方模块，这个安装过程之所以简单，是因为模块开发者写好了模块的setup.py，而这个文件负责的过程就是 <code>打包</code>。</p><p>打包，就是将你的源代码进一步封装，并且将所有的项目部署工作都事先安排好，这样使用者拿到后安装即可用，不用再操心如何部署的问题。</p><h4 id="setuptools"><a href="#setuptools" class="headerlink" title="setuptools"></a>setuptools</h4><p><code>setuptools</code> 是官方提供的一个专业用于包分发的工具，是对包的分发很有用处，定制化程序非常高。</p><h3 id="源码包与二进制包"><a href="#源码包与二进制包" class="headerlink" title="源码包与二进制包"></a>源码包与二进制包</h3><p>Python 包的分发可以分为两种：</p><ol><li>以源码包的方式发布<br><br>源码包安装的过程，是先解压，再编译，最后才安装，所以它是跨平台的，由于每次安装都要进行编译，相对二进包安装方式来说安装速度较慢。</li></ol><blockquote><p>源码包的本质是一个压缩包，其常见的格式有：<br><br>zip, tar, tar.gz, tar.bz2 等</p></blockquote><ol start="2"><li>以二进制包形式发布<br><br>二进制包的安装过程省去了编译的过程，直接进行解压安装，所以安装速度较源码包来说更快。<br><br>由于不同平台的二进制文件无法通用，所以在发布时，有时可能需编译多个平台的包（当然如果使用whl也可以做到跨平台使用）。</li></ol><blockquote><p>二进制包的常见格式有：<br>egg, wheel(whl)</p></blockquote><h3 id="setup-py文件结构"><a href="#setup-py文件结构" class="headerlink" title="setup.py文件结构"></a>setup.py文件结构</h3><p>打包分发最关键的一步是编写 <code>setup.py</code> 文件。<br>以下是我项目使用的 <code>setup.py</code> 示例</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> setup, find_packages</span><br><span class="line"><span class="keyword">import</span> pimm</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> path</span><br><span class="line">this_directory = path.abspath(path.dirname(__file__))</span><br><span class="line">long_description = <span class="literal">None</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(path.join(this_directory, <span class="string">&#x27;README.md&#x27;</span>), encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    long_description = f.read()</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">&#x27;pimm&#x27;</span>, <span class="comment"># 包名称</span></span><br><span class="line">      packages=[<span class="string">&#x27;pimm&#x27;</span>], <span class="comment"># 需要处理的包目录</span></span><br><span class="line">      version=<span class="string">&#x27;0.0.5&#x27;</span>, <span class="comment"># 版本</span></span><br><span class="line">      classifiers=[</span><br><span class="line">          <span class="string">&#x27;Development Status :: 3 - Alpha&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;License :: OSI Approved :: MIT License&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Programming Language :: Python&#x27;</span>, <span class="string">&#x27;Intended Audience :: Developers&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Operating System :: OS Independent&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Programming Language :: Python :: 3.5&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Programming Language :: Python :: 3.6&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Programming Language :: Python :: 3.7&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Programming Language :: Python :: 3.8&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Programming Language :: Python :: 3.9&#x27;</span></span><br><span class="line">      ],</span><br><span class="line">      install_requires=[<span class="string">&#x27;ping3&#x27;</span>],</span><br><span class="line">      entry_points=&#123;<span class="string">&#x27;console_scripts&#x27;</span>: [<span class="string">&#x27;pmm=pimm.pimm_module:main&#x27;</span>]&#125;,</span><br><span class="line">      package_data=&#123;<span class="string">&#x27;&#x27;</span>: [<span class="string">&#x27;*.json&#x27;</span>]&#125;,</span><br><span class="line">      auth=<span class="string">&#x27;lollipopnougat&#x27;</span>, <span class="comment"># 作者</span></span><br><span class="line">      author_email=<span class="string">&#x27;lollipopnougat@126.com&#x27;</span>, <span class="comment"># 作者邮箱</span></span><br><span class="line">      description=<span class="string">&#x27;pypi mirrors manager&#x27;</span>, <span class="comment"># 介绍</span></span><br><span class="line">      long_description=long_description, <span class="comment"># 长介绍，在pypi项目页显示</span></span><br><span class="line">      long_description_content_type=<span class="string">&#x27;text/markdown&#x27;</span>, <span class="comment"># 长介绍使用的类型，我使用的是md</span></span><br><span class="line">      url=<span class="string">&#x27;https://github.com/lollipopnougat/pimm&#x27;</span>, <span class="comment"># 包主页，一般是github项目主页</span></span><br><span class="line">      license=<span class="string">&#x27;MIT&#x27;</span>, <span class="comment"># 协议</span></span><br><span class="line">      keywords=<span class="string">&#x27;pimm source manager&#x27;</span>) <span class="comment"># 关键字 搜索用</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>setup.py</code> 调用了 <code>setuptools</code> 包中的setup方法，下面解释一下各个参数的含义</p><h4 id="程序分类信息"><a href="#程序分类信息" class="headerlink" title="程序分类信息"></a>程序分类信息</h4><p><code>classifiers</code> 参数说明包的分类信息，接收一个 <code>string</code> 列表</p><h5 id="发展时期"><a href="#发展时期" class="headerlink" title="发展时期"></a>发展时期</h5><ul><li>Development Status :: 1 - Planning</li><li>Development Status :: 2 - Pre-Alpha</li><li>Development Status :: 3 - Alpha</li><li>Development Status :: 4 - Beta</li><li>Development Status :: 5 - Production/Stable</li><li>…</li></ul><h5 id="开发目标用户"><a href="#开发目标用户" class="headerlink" title="开发目标用户"></a>开发目标用户</h5><ul><li>Intended Audience :: Customer Service</li><li>Intended Audience :: Developers</li><li>Intended Audience :: Education</li><li>Intended Audience :: End Users/Desktop</li><li>Intended Audience :: Financial and Insurance Industry</li><li>Intended Audience :: Healthcare Industry</li><li>…</li></ul><h5 id="目标编程语言"><a href="#目标编程语言" class="headerlink" title="目标编程语言"></a>目标编程语言</h5><ul><li>Programming Language :: Basic</li><li>Programming Language :: C</li><li>Programming Language :: C#</li><li>Programming Language :: C++</li><li>…</li><li>Programming Language :: Python :: 3.4</li><li>Programming Language :: Python :: 3.5</li><li>Programming Language :: Python :: 3.6</li><li>Programming Language :: Python :: 3.7</li><li>Programming Language :: Python :: 3.8</li><li>Programming Language :: Python :: 3.9</li><li>…</li></ul><h5 id="该字段所有支持的值"><a href="#该字段所有支持的值" class="headerlink" title="该字段所有支持的值"></a>该字段所有支持的值</h5><p><a href="https://pypi.org/pypi?:action=list_classifiers">Intended Audience list</a></p><h4 id="文件分发"><a href="#文件分发" class="headerlink" title="文件分发"></a>文件分发</h4><p>安装过程中，需要安装的静态文件，如配置文件、图片等可以使用 <code>data_files</code> 参数，接收一个字典参数</p><p>字典的键表示部署后文件的存放位置(目标机器)，空字符串表示放在包的根目录</p><p>此外需要再准备一个 <code>MANIFEST.in</code> 文件与 <code>setup.py</code> 同级, 来控制文件的分发</p><h5 id="一个demo"><a href="#一个demo" class="headerlink" title="一个demo"></a>一个demo</h5><ul><li>所有根目录下的以 txt 为后缀名的文件，都会分发</li><li>根目录下的 examples 目录 和 txt、py文件都会分发</li><li>路径匹配上 examples/sample?/build 不会分发</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include *.txt</span><br><span class="line">recursive-include examples *.txt *.py</span><br><span class="line">prune examples&#x2F;sample?&#x2F;build</span><br></pre></td></tr></table></figure><h4 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h4><p>使用 <code>install_requires</code> 参数指定安装依赖，表明当前模块使用时依赖哪些包，若环境中没有，则会从pypi中下载安装, 此参数接收一个 <code>string</code> 列表</p><p>使用 <code>tests_require</code> 参数指定测试依赖，仅在测试时需要使用的依赖，在正常发布的代码中是没有用到的，此参数接收一个 <code>string</code> 列表</p><p>使用 <code>extras_require</code> 参数指定可选的依赖，此参数接收一个 <code>string</code> 列表</p><h4 id="生成可执行文件的分发"><a href="#生成可执行文件的分发" class="headerlink" title="生成可执行文件的分发"></a>生成可执行文件的分发</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用来支持自动生成脚本，安装后会自动生成 /usr/bin/pmm 的可执行文件(windows管理员权限下会在Python文件夹的script里面生成pmm.exe)</span></span><br><span class="line"><span class="comment"># 该文件入口指向 pimm/pimm_module.py 的main 函数</span></span><br><span class="line">entry_points=&#123;<span class="string">&#x27;console_scripts&#x27;</span>: [<span class="string">&#x27;pmm=pimm.pimm_module:main&#x27;</span>]&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 bin/foo.sh 和 bar.py 脚本，生成到系统 PATH中</span></span><br><span class="line"><span class="comment"># 执行 python setup.py install 后</span></span><br><span class="line"><span class="comment"># 会生成 如 /usr/bin/foo.sh 和 如 /usr/bin/bar.py</span></span><br><span class="line">scripts=[<span class="string">&#x27;bin/foo.sh&#x27;</span>, <span class="string">&#x27;bar.py&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用-setup-py-构建包"><a href="#使用-setup-py-构建包" class="headerlink" title="使用 setup.py 构建包"></a>使用 setup.py 构建包</h3><ol><li>构建源码发布包</li></ol><p>用于发布一个 <code>Python</code> 模块或项目，将源码打包成 <code>tar.gz</code> 或者 <code>zip</code> 压缩包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist <span class="comment"># 打包，默认tar.gz</span></span><br><span class="line">python setup.py sdist --formats=gztar,zip <span class="comment"># 打包，指定压缩格式</span></span><br></pre></td></tr></table></figure><ol start="2"><li>构建二进制分发包</li></ol><p>在windows中我们习惯了双击 exe 进行软件的安装，Python 模块的安装也同样支持 打包成 exe 这样的二进制软件包</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py bdist_wininst</span><br></pre></td></tr></table></figure><p>若你的项目，需要安装多个平台下，既有 Windows 也有 Linux，按照上面的方法，多种格式我们要执行多次命令，为了方便，你可以一步到位，执行如下这条命令，即可生成多个格式的进制</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py bdist</span><br></pre></td></tr></table></figure><p>构建 wheel 包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py sdist bdist_wheel</span><br></pre></td></tr></table></figure><h4 id="使用-setup-py-安装包"><a href="#使用-setup-py-安装包" class="headerlink" title="使用 setup.py 安装包"></a>使用 setup.py 安装包</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>如若你的项目还处于开发阶段，频繁的安装模块，也是一个麻烦事。</p><p>这时候可以使用下面这条命令安装，该方法不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py develop</span><br></pre></td></tr></table></figure><h4 id="发布包到-PyPi"><a href="#发布包到-PyPi" class="headerlink" title="发布包到 PyPi"></a>发布包到 PyPi</h4><p>若你觉得自己开发的模块非常不错，想要 share 给其他人使用，你可以将其上传到 PyPi （Python Package Index）上，它是 Python 官方维护的第三方包仓库，用于统一存储和管理开发者发布的 Python 包</p><p>如果要发布自己的包，需要先到 pypi 上注册账号。然后创建 <code>~/.pypirc</code>(windows <code>C:/User/yourname/.pypirc</code>) 文件，此文件中配置 PyPI 访问地址和账号。.pypirc文件内容请根据自己的账号来修改</p><h5 id="典型的-pypirc-文件"><a href="#典型的-pypirc-文件" class="headerlink" title="典型的 .pypirc 文件"></a>典型的 .pypirc 文件</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[distutils]</span></span><br><span class="line"><span class="attr">index-servers</span> = pypi</span><br><span class="line"></span><br><span class="line"><span class="section">[pypi]</span></span><br><span class="line">username:xxx</span><br><span class="line">password:xxx</span><br></pre></td></tr></table></figure><h5 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setup.py sdist upload</span><br></pre></td></tr></table></figure><p>想更省劲的话可以考虑安装 <code>twine</code>，然后使用 <code>twine</code> 上传，这个还可以上传whl文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">twine upload dist/* <span class="comment"># 上传dist下的所有文件</span></span><br></pre></td></tr></table></figure><p>pypi 好像不能覆盖文件，要上传新的需要修改版本号</p><p>上传以后就可以使用pip下载自己的包了，顺便清华源是10分钟更新一次，所以说10分钟后清华的pypi源就能找到自己的包了</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;鸽了一年，突然想起来我还有个博客&quot;&gt;&lt;a href=&quot;#鸽了一年，突然想起来我还有个博客&quot; class=&quot;headerlink&quot; title=&quot;鸽了一年，突然想起来我还有个博客&quot;&gt;&lt;/a&gt;鸽了一年，突然想起来我还有个博客&lt;/h3&gt;&lt;p&gt;正好最近写了个超级简陋的 &lt;code&gt;pypi&lt;/code&gt; 源管理工具，学习了一波setup.py文件的撰写&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Python" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
    
    <category term="python" scheme="https://www.lollipopnougat.top/tags/python/"/>
    
    <category term="pip" scheme="https://www.lollipopnougat.top/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>肺炎疫情信息的获取</title>
    <link href="https://www.lollipopnougat.top/2020/02/05/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>https://www.lollipopnougat.top/2020/02/05/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96/</id>
    <published>2020-02-05T02:47:53.000Z</published>
    <updated>2021-08-14T10:04:49.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python-爬虫相关"><a href="#python-爬虫相关" class="headerlink" title="python 爬虫相关"></a>python 爬虫相关</h3><p>也算是练习一下好久没写的爬虫了</p><span id="more"></span><p>最近病毒肆虐，丁香园为了方便大众得知最新消息，开设了一个<a href="https://ncov.dxy.cn/ncovh5/view/pneumonia">网页</a>,可以从中得知当前的最新感染数据信息，笔者在浏览此页面后看到数据是以 json 格式送到浏览器的，觉得不妨写一个爬虫获取数据写入文件来进行统计…</p><h4 id="爬取到的网页关键数据-全国"><a href="#爬取到的网页关键数据-全国" class="headerlink" title="爬取到的网页关键数据(全国)"></a>爬取到的网页关键数据(全国)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">&quot;getStatisticsService&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.getStatisticsService = &#123;</span></span><br><span class="line">      id: 1,</span><br><span class="line">      createTime: 1579537899000,</span><br><span class="line">      modifyTime: 1580795061000,</span><br><span class="line"><span class="javascript">      infectSource: <span class="string">&#x27;该字段已替换为说明2&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      passWay: <span class="string">&#x27;该字段已替换为说明3&#x27;</span>,</span></span><br><span class="line">      imgUrl:</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0201/450/3394153392393266839-135.png&#x27;</span>,</span></span><br><span class="line">      dailyPic:</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png,https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png,https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png,https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png,https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png&#x27;</span>,</span></span><br><span class="line">      dailyPics: [</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&#x27;https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png&#x27;</span></span></span><br><span class="line">      ],</span><br><span class="line"><span class="javascript">      summary: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      deleted: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">      countRemark: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">      confirmedCount: 20471,</span><br><span class="line">      suspectedCount: 23214,</span><br><span class="line">      curedCount: 657,</span><br><span class="line">      deadCount: 426,</span><br><span class="line">      seriousCount: 2788,</span><br><span class="line">      suspectedIncr: 5072,</span><br><span class="line">      confirmedIncr: 3235,</span><br><span class="line">      curedIncr: 182,</span><br><span class="line">      deadIncr: 65,</span><br><span class="line">      seriousIncr: 492,</span><br><span class="line"><span class="javascript">      virus: <span class="string">&#x27;该字段已替换为说明1&#x27;</span>,</span></span><br><span class="line">      remark1:</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;易感人群：人群普遍易感。老年人及有基础疾病者感染后病情较重，儿童及婴幼儿也有发病&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      remark2: <span class="string">&#x27;潜伏期：一般为 3～7 天，最长不超过 14 天，潜伏期内存在传染性&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      remark3: <span class="string">&#x27;宿主：野生动物，可能为中华菊头蝠&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      remark4: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      remark5: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      note1: <span class="string">&#x27;病毒：新型冠状病毒 2019-nCoV&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      note2: <span class="string">&#x27;传染源：新型冠状病毒感染的肺炎患者&#x27;</span>,</span></span><br><span class="line">      note3:</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;传播途径：经呼吸道飞沫传播，亦可通过接触传播，存在粪-口传播可能性&#x27;</span>,</span></span><br><span class="line">      generalRemark:</span><br><span class="line"><span class="javascript">        <span class="string">&#x27;疑似病例数来自国家卫健委数据，目前为全国数据，未分省市自治区等&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      abroadRemark: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">      marquee: []</span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="爬取到的网页关键数据-各省，局部"><a href="#爬取到的网页关键数据-各省，局部" class="headerlink" title="爬取到的网页关键数据(各省，局部)"></a>爬取到的网页关键数据(各省，局部)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.getAreaStat = [</span><br><span class="line">    &#123;</span><br><span class="line">      provinceName: <span class="string">&#x27;湖北省&#x27;</span>,</span><br><span class="line">      provinceShortName: <span class="string">&#x27;湖北&#x27;</span>,</span><br><span class="line">      confirmedCount: <span class="number">13522</span>,</span><br><span class="line">      suspectedCount: <span class="number">0</span>,</span><br><span class="line">      curedCount: <span class="number">398</span>,</span><br><span class="line">      deadCount: <span class="number">414</span>,</span><br><span class="line">      comment: <span class="string">&#x27;待明确地区，治愈 96&#x27;</span>,</span><br><span class="line">      locationId: <span class="number">420000</span>,</span><br><span class="line">      cities: [</span><br><span class="line">        &#123;</span><br><span class="line">          cityName: <span class="string">&#x27;武汉&#x27;</span>,</span><br><span class="line">          confirmedCount: <span class="number">6384</span>,</span><br><span class="line">          suspectedCount: <span class="number">0</span>,</span><br><span class="line">          curedCount: <span class="number">307</span>,</span><br><span class="line">          deadCount: <span class="number">313</span>,</span><br><span class="line">          locationId: <span class="number">420100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 以下省略n个城市</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何从爬取的字符串中获取数据"><a href="#如何从爬取的字符串中获取数据" class="headerlink" title="如何从爬取的字符串中获取数据"></a>如何从爬取的字符串中获取数据</h4><p>经过一番分析，最终使用了正则和 BS 库获取了 json 字符串，剩下的就很好处理了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pat1 = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\[[^\]]+?\])&#x27;</span>)</span><br><span class="line"><span class="comment">#原本写的是 pat2 = re.compile(&#x27;(\&#123;[^\&#125;\&#123;]+?\&#125;)&#x27;) 但丁香园发布了一条特殊格式的数据后不能用了，于是就换成了下面那个</span></span><br><span class="line">pat2 = re.<span class="built_in">compile</span>(<span class="string">&#x27;=\s?(\&#123;.+)\&#125;catch&#x27;</span>)</span><br><span class="line">dat1 = <span class="built_in">str</span>(soup.findAll(<span class="built_in">id</span>=<span class="string">&#x27;getListByCountryTypeService1&#x27;</span>)[<span class="number">0</span>].string)</span><br><span class="line">dat2 = <span class="built_in">str</span>(soup.findAll(<span class="built_in">id</span>=<span class="string">&#x27;getStatisticsService&#x27;</span>)[<span class="number">0</span>].string)</span><br><span class="line"><span class="comment"># 各省</span></span><br><span class="line">st1 = pat1.findall(dat1)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 全国</span></span><br><span class="line">st2 = pat2.findall(dat2)[<span class="number">0</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>附赠一个可以显示目前各省累计确诊人数占全国比例的爬虫</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://ncov.dxy.cn/ncovh5/view/pneumonia_peopleapp&#x27;</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pat1 = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\[[^\]]+?\])&#x27;</span>)</span><br><span class="line">pat2 = re.<span class="built_in">compile</span>(<span class="string">&#x27;=\s?(\&#123;.+)\&#125;catch&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    res = req.get(url=url, headers=header)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(res.status_code)</span><br><span class="line">    res.encoding = res.apparent_encoding</span><br><span class="line"></span><br><span class="line">    soup = bs(res.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    dat1 = <span class="built_in">str</span>(soup.findAll(<span class="built_in">id</span>=<span class="string">&#x27;getListByCountryTypeService1&#x27;</span>)[<span class="number">0</span>].string)</span><br><span class="line">    dat2 = <span class="built_in">str</span>(soup.findAll(<span class="built_in">id</span>=<span class="string">&#x27;getStatisticsService&#x27;</span>)[<span class="number">0</span>].string)</span><br><span class="line">    st1 = pat1.findall(dat1)[<span class="number">0</span>]</span><br><span class="line">    st2 = pat2.findall(dat2)[<span class="number">0</span>]</span><br><span class="line">    js = json.loads(st1)</span><br><span class="line">    al = json.loads(st2)</span><br><span class="line">    prov_list = []</span><br><span class="line">    conf_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> js:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 确诊数： %d， 治愈数： %d， 死亡数: %d&#x27;</span> %</span><br><span class="line">              (i[<span class="string">&#x27;provinceName&#x27;</span>], i[<span class="string">&#x27;confirmedCount&#x27;</span>], i[<span class="string">&#x27;curedCount&#x27;</span>],</span><br><span class="line">               i[<span class="string">&#x27;deadCount&#x27;</span>]))</span><br><span class="line">        prov_list.append(i[<span class="string">&#x27;provinceName&#x27;</span>])</span><br><span class="line">        conf_list.append(i[<span class="string">&#x27;confirmedCount&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;全国确诊： %d， 疑似数： %d， 治愈数： %d， 死亡数： %d， 重症数： %d&#x27;</span> %</span><br><span class="line">          (al[<span class="string">&#x27;confirmedCount&#x27;</span>], al[<span class="string">&#x27;suspectedCount&#x27;</span>], al[<span class="string">&#x27;curedCount&#x27;</span>],</span><br><span class="line">           al[<span class="string">&#x27;deadCount&#x27;</span>], al[<span class="string">&#x27;seriousCount&#x27;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用 matplotlib 准备绘图</span></span><br><span class="line">    font = &#123;<span class="string">&#x27;family&#x27;</span>: <span class="string">&#x27;MicroSoft YaHei&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;light&#x27;</span>, <span class="string">&#x27;size&#x27;</span>: <span class="number">10</span>&#125;</span><br><span class="line">    matplotlib.rc(<span class="string">&quot;font&quot;</span>, **font)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">9</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    fig.canvas.set_window_title(<span class="string">&#x27;全国各省感染人数占比&#x27;</span>)</span><br><span class="line">    plt.axes(aspect=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 饼图</span></span><br><span class="line">    plt.pie(x=conf_list,</span><br><span class="line">            labels=prov_list,</span><br><span class="line">            autopct=<span class="string">&#x27;%3.1f %%&#x27;</span>,</span><br><span class="line">            pctdistance=<span class="number">1.2</span>,</span><br><span class="line">            labeldistance=<span class="number">1.0</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;全国各省感染人数占比&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">input</span>(<span class="string">&#x27;任意键继续&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    task()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>完成整个脚本以后配置一下计划任务，再添加一个每一小时获取一次写入文件功能，省了不少事…其实还可以通过异步维护一个计时器，每隔一段时间运行一次(好像单线程就是用 sleep 也可以吧，嘛不管了)</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;python-爬虫相关&quot;&gt;&lt;a href=&quot;#python-爬虫相关&quot; class=&quot;headerlink&quot; title=&quot;python 爬虫相关&quot;&gt;&lt;/a&gt;python 爬虫相关&lt;/h3&gt;&lt;p&gt;也算是练习一下好久没写的爬虫了&lt;/p&gt;</summary>
    
    
    
    <category term="爬虫开发" scheme="https://www.lollipopnougat.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/"/>
    
    <category term="python" scheme="https://www.lollipopnougat.top/categories/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91/python/"/>
    
    
    <category term="python" scheme="https://www.lollipopnougat.top/tags/python/"/>
    
    <category term="爬虫" scheme="https://www.lollipopnougat.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>最近忙的很</title>
    <link href="https://www.lollipopnougat.top/2019/12/03/%E6%9C%80%E8%BF%91%E5%BF%99%E7%9A%84%E5%BE%88/"/>
    <id>https://www.lollipopnougat.top/2019/12/03/%E6%9C%80%E8%BF%91%E5%BF%99%E7%9A%84%E5%BE%88/</id>
    <published>2019-12-03T13:10:21.000Z</published>
    <updated>2021-04-25T09:02:11.200Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近事还挺多的…"><a href="#最近事还挺多的…" class="headerlink" title="最近事还挺多的…"></a>最近事还挺多的…</h3><p>也没顾的上更新博客</p><span id="more"></span><p>等到课近期的设完成大概就有时间了吧…<br>今天先鸽了，，，咕咕咕</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;最近事还挺多的…&quot;&gt;&lt;a href=&quot;#最近事还挺多的…&quot; class=&quot;headerlink&quot; title=&quot;最近事还挺多的…&quot;&gt;&lt;/a&gt;最近事还挺多的…&lt;/h3&gt;&lt;p&gt;也没顾的上更新博客&lt;/p&gt;</summary>
    
    
    
    <category term="吐槽" scheme="https://www.lollipopnougat.top/categories/%E5%90%90%E6%A7%BD/"/>
    
    
    <category term="吐槽" scheme="https://www.lollipopnougat.top/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>网络安全协会网站的搭建(一)</title>
    <link href="https://www.lollipopnougat.top/2019/09/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA(1)/"/>
    <id>https://www.lollipopnougat.top/2019/09/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA(1)/</id>
    <published>2019-09-06T15:20:37.000Z</published>
    <updated>2021-04-26T07:25:15.857Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络安全协会网站的搭建"><a href="#网络安全协会网站的搭建" class="headerlink" title="网络安全协会网站的搭建"></a>网络安全协会网站的搭建</h3><p>一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊<br>特别是看了ACM协会的网站之后，更加坚定了开发的想法<br>所以<a href="https://github.com/lollipopnougat/chdns">这个</a>项目就出现了</p><p><a href="https://chdans.github.io/">网站预览</a></p><span id="more"></span><h3 id="Vue-js-与-Node-js"><a href="#Vue-js-与-Node-js" class="headerlink" title="Vue.js 与 Node.js"></a>Vue.js 与 Node.js</h3><blockquote><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote><p>早就在关注尤雨溪大佬和他的<a href="https://github.com/vuejs/vue">Vue.js</a>项目。</p><p>今年年初曾尝试搞了一个demo，结果最后搞的一头雾水，也没弄懂…<br>最终结果就是弃了…</p><p>直到今年5月份我准备做数据库课设，才算稍微系统地学习了一下 <code>Node.js</code>，用 <code>Express</code> 熟悉了一下 <code>Node</code> 的项目结构和使用 <code>npm</code> 的方法，顺便提高了js的开发能力。我也学到了 <code>js</code> 的异步回调什么的，还有编写 <code>HTML</code> 和 <code>CSS</code> 的熟练度也得到了少许提高，暑假时又学习了一部分 <code>TypeScript</code> 和 <code>ES6</code> 的语法，勉强算是做了较多的铺垫。</p><p>这两天重新看 <code>vue</code> 的项目的时候终于明白那都是什么东西了，有点 <code>Express</code> 的感觉，但是 <code>router</code> 竟然可以 build 成静态的，默认采用的是 <code>Hash</code> 方式，一个网站可以做成单页的，有趣啊！</p><p>于是9月1日建立了项目仓库，9月3日提交了研究了两天的结果(一个 <code>Header</code> )，因为将来要放到新GitHub账号上，build出来的静态文件有开 Http 服务的要求，因此我专门开了我GitHub的托管根目录做预览，这周前前后后一共提交了7次，之后就正式迁移到 <a href="https://chdans.github.io/">chdans.github.io</a> 了，我修改了结构，我build好的项目提交到我fork出来的 chdans 创建的那个静态页项目下，然后再新建 <code>Pull Request</code>，提交到 chdans，再由 chdans来 <code>Merge</code> 请求，这就是一次完整的更新。</p><p>不得不说<a href="https://element.eleme.io/">element ui</a>做的真的既简介又漂亮，原版的配色我是很喜欢的，我一度把协会的宣传海报也采用相同配色，如图<br><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/picbed/neoposter.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/lollipopnougat/picbed/neoposter.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="海报"></p><p>之后会详细解释这个网站项目</p><p>今天就写这么多，明天还要迎新，7点就要去…</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;网络安全协会网站的搭建&quot;&gt;&lt;a href=&quot;#网络安全协会网站的搭建&quot; class=&quot;headerlink&quot; title=&quot;网络安全协会网站的搭建&quot;&gt;&lt;/a&gt;网络安全协会网站的搭建&lt;/h3&gt;&lt;p&gt;一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊&lt;br&gt;特别是看了ACM协会的网站之后，更加坚定了开发的想法&lt;br&gt;所以&lt;a href=&quot;https://github.com/lollipopnougat/chdns&quot;&gt;这个&lt;/a&gt;项目就出现了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chdans.github.io/&quot;&gt;网站预览&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="前端" scheme="https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue" scheme="https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/vue/"/>
    
    
    <category term="Vue.js" scheme="https://www.lollipopnougat.top/tags/Vue-js/"/>
    
    <category term="网站搭建" scheme="https://www.lollipopnougat.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
    <category term="网络安全协会" scheme="https://www.lollipopnougat.top/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(3)</title>
    <link href="https://www.lollipopnougat.top/2019/07/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(3)/"/>
    <id>https://www.lollipopnougat.top/2019/07/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(3)/</id>
    <published>2019-07-29T01:56:12.000Z</published>
    <updated>2021-04-25T15:24:47.976Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PowerShell入门指南-三-·一门新的编程语言"><a href="#PowerShell入门指南-三-·一门新的编程语言" class="headerlink" title="PowerShell入门指南(三)·一门新的编程语言"></a>PowerShell入门指南(三)·一门新的编程语言</h3><hr><h4 id="作为独立的编程语言"><a href="#作为独立的编程语言" class="headerlink" title="作为独立的编程语言"></a>作为独立的编程语言</h4><p>作为一门独立的语言来说，<code>PowerShell</code> 是非常地Powerful，我们先来了解一下它的特点:</p><span id="more"></span><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><h4 id="破天荒的方便"><a href="#破天荒的方便" class="headerlink" title="破天荒的方便"></a>破天荒的方便</h4><p>诸如存储计算中 <code>GB</code>， <code>MB</code>， <code>KB</code> 单位等；数组声明中的 <code>1..n</code> 和下标为 <code>-1</code> 的处理；还有所见即所得，通俗易懂的<strong>动词</strong>+<strong>名词</strong>结构的Cmdlet(PowerShell命令的称呼)。<br>还有自带的文档支持也很是丰富，只要熟练掌握 <code>Get-Help</code> 命令，其他命令的用法均可通过 <code>Get-Help</code> 查到</p></li><li><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>良心啊，这个语言竟然是面向对象的<br>与面向过程相比，面向对象更方便更容易描述现实世界，也算赶上了时髦。</p></li><li><h4 id="依托-NET"><a href="#依托-NET" class="headerlink" title="依托 .NET"></a>依托 .NET</h4><p>正所谓大树下面好乘凉，<code>PowerShell</code> 绑上 <code>.NET</code> 这个大款了，借助 <code>.NET</code> 平台强大的类库，几乎让一切都成为可能。</p></li><li><h4 id="强大的兼容性"><a href="#强大的兼容性" class="headerlink" title="强大的兼容性"></a>强大的兼容性</h4><p>完全兼容 <code>Windows</code> 平台上其它调用，如可执行文件(exe)，批处理bat/cmd和VBscript等, 在 <code>Linux</code> 和 <code>macOS</code> 上也能很好地工作。</p></li><li><h4 id="基于平台的可扩展性"><a href="#基于平台的可扩展性" class="headerlink" title="基于平台的可扩展性"></a>基于平台的可扩展性</h4><p>微软有个优点，与应用相比，它更喜欢做平台。<code>PowerShell</code> 早已变成一个平台，在 <code>PowerShell</code> 刚发布的第二年，微软的 System Center Operations Manager 和 SharePoint 就提供了针对该平台的组件，后来的活动目录，Hyper-V，Windows Azure，Office 365就更不用说了。除了微软，亚马逊的云平台管理，Dell的out-of-hand 管理，也都提供了基于 <code>PowerShell</code> 的管理组件。<code>PowerShell</code> 俨然变成了一个标准，变成了一个规范。</p></li></ul><hr><h3 id="使用Get-Help-快速入门"><a href="#使用Get-Help-快速入门" class="headerlink" title="使用Get-Help 快速入门"></a>使用<code>Get-Help</code> 快速入门</h3><p>下面用一个简单例子说明如何<code>Get-Help</code>，设想这样一个场景：<br>你想通过命令行查看所有进程，你第一个反应应该是用一个跟Process相关的命令来达到此目的，所以你可以会尝试执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Command</span> *<span class="keyword">Process</span></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">CommandType     Name                   Version    Source</span><br><span class="line">-----------     ----                   -------    ------</span><br><span class="line">Cmdlet          <span class="built_in">Debug-Process</span>          <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Enter-PSHostProcess</span>    <span class="number">3.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Core</span><br><span class="line">Cmdlet          <span class="built_in">Exit-PSHostProcess</span>     <span class="number">3.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Core</span><br><span class="line">Cmdlet          <span class="built_in">Get-Process</span>            <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Start-Process</span>          <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Stop-Process</span>           <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Wait-Process</span>           <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br></pre></td></tr></table></figure><p>得知处理进程的命令有这些<br>然后再用 <code>Get-Help Get-Process -full</code> 就能得到 <code>Get-Process</code> 的详细用法以及使用范例</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><code>PowerShell</code> 是一个强类型(变量一旦定义，其本身类型不可改变就是强类型，反之就是弱类型)的动态脚本语言，支持面向对象，支持调用系统API和 <code>.NET</code> 库。<br>受到了 <code>Python</code>, <code>Ksh</code>, <code>Perl</code>, <code>C#</code>, <code>CL</code>, <code>DCL</code>, <code>SQL</code>, <code>Tcl</code>, <code>Tk</code>, <code>Chef</code>, <code>Puppet</code> 等语言的影响，结合了以上语言的部分特性。</p><p><code>PowerShell</code> 代码的外观和操作方式与C#的相似程度最高，不过也有它自己的特色。</p><h4 id="关于空白字符"><a href="#关于空白字符" class="headerlink" title="关于空白字符"></a>关于空白字符</h4><p>与 <code>Python</code> 等语言不同，**<code>PowerShell</code> 的解释器不会考虑代码中的空格或制表符**(这些字符统称空白字符)。这样一来，格式化代码就有很大的自由度，但是遵循某些规则将有助于提高代码的可读性。</p><h4 id="代码块和代码基本结构"><a href="#代码块和代码基本结构" class="headerlink" title="代码块和代码基本结构"></a>代码块和代码基本结构</h4><p><code>PowerShell</code> 代码由一系列语句构成，每条语句可以使用一个分号结束，当然也可以不写。<strong>按照习惯是不写分号的，因此要用换行来区分不同的语句，如果必须写到一行中，那就在每一句后加个分号</strong>。</p><p>和C语系的大多数语言类似，<code>PowerShell</code> 是一种块结构的语言，这些块用 <code>&#123;</code> 和 <code>&#125;</code> 来界定，代码块可以包含任意多条语句，或者不包含任何语句，下面的示例还使用了缩进格式，这样能大大提高可读性，实际上编译器会自带缩进代码。一般情况下，每个代码块都有自己的缩进级别，代码块之间还能嵌套。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">&lt;#代码行1#&gt;</span></span><br><span class="line">    <span class="comment">&lt;#代码行2#&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">&lt;#代码行3#&gt;</span></span><br><span class="line">        <span class="comment">&lt;#代码行4#&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">&lt;#代码行5#&gt;</span>;<span class="comment">&lt;#代码行6#&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 <code>PowerShell</code> 的缩进不是强制的。</p><p>在 <code>PowerShell</code> 代码中，另一种常见的语句是注释，注释并不是能执行的语句，而是对代码的描述说明性文本。当代码运行时，解释器会忽略这些内容。<br>代码最好有注释，特别是处理较复杂的工作时，注释可以为正在进行的操作添加提示，例如“这行代码要求用户输入一个字符”、“此段代码是 LNP 编写的”。<br><code>PowerShell</code> 有两种添加注释方法</p><ul><li>行注释:  <code>#</code></li><li>块注释:  <code>&lt;#</code> 和 <code>#&gt;</code></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是一行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment">这是注释块</span></span><br><span class="line"><span class="comment">123ABC</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">ls</span> <span class="comment">#列出当前目录下的文件和文件夹，是Get-ChildItem的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意下面语句会产生错误</span></span><br><span class="line"><span class="comment">&lt;#块注释由&quot;#&gt;</span><span class="string">&quot;结尾#&gt;</span></span><br></pre></td></tr></table></figure><p>第一个 <code>#&gt;</code> 后面的部分会被认为是 <code>PowerShell</code> 代码，因此出现错误。</p><p>还有特别的注意一点，**<code>PowerShell</code> 代码是不区分大小写的**，因此只要拼写正确的命令(或变量)，而无需关心大小写即可执行，不过最好还是有一定规范。</p><hr><h3 id="PowerShell-脚本的基本结构"><a href="#PowerShell-脚本的基本结构" class="headerlink" title="PowerShell 脚本的基本结构"></a><code>PowerShell</code> 脚本的基本结构</h3><p><code>PowerShell</code> 像 <code>Python</code> 一样，允许使用控制台直接输入命令进行交互，也可以事先把代码写入一个文件再作为脚本运行。<br>一个 <code>PowerShell</code> 脚本仅仅是一个包含 <code>PowerShell</code> 代码的文本文件。如果这个文本文件执行， <code>PowerShell</code> 解释器会逐行解释并执行它的的语句。<code>PowerShell</code> 脚本有点像以前 <code>CMD</code> 控制台上的批处理文件。可以通过非常简单的文本编辑工具创建 <code>PowerShell</code> 脚本。</p><p>PowerShell脚本文件的扩展名是 <code>.ps1</code></p><hr><h3 id="执行策略限制"><a href="#执行策略限制" class="headerlink" title="执行策略限制"></a>执行策略限制</h3><p><code>PowerShell</code> 一般初始化情况下都会禁止脚本执行。脚本能否执行取决于PowerShell的执行策略。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:&gt; ./MyScript.ps1</span><br><span class="line"></span><br><span class="line">无法加载文件 E:MyScript.ps1，因为在此系统中禁止执行脚本。有关详细信息，请参阅 <span class="string">&quot;get-help about_signing&quot;</span>。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">15</span></span><br><span class="line">+ .MyScript.ps1 &lt; &lt;&lt;&lt;</span><br><span class="line">    + CategoryInfo          : NotSpecified: (:) [], PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : RuntimeException</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>只有管理员才有权限更改这个策略。非管理员会报错。</strong></p><p>查看脚本执行策略，可以通过在 <code>PowerShell</code> 控制台直接输入:<br><code>Get-ExecutionPolicy</code><br><strong>更改脚本执行策略，可以管理员启动PowerShell，在控制台输入:</strong><br><code>Set-ExecutionPolicy &lt;策略&gt;</code><br>策略|解释<br>-|-<br>Unrestricted|权限最高，可以不受限制执行任何脚本。<br>Default|为Powershell默认的策略，即Restricted<br>Restricted|不允许任何脚本执行<br>AllSigned|所有脚本都必须经过签名才能在运行<br>RemoteSigned|本地脚本无限制，但是对来自网络的脚本必须经过签名</p><p>如果要使用脚本功能又要兼顾安全性，我们就选择RemoteSigned<br>即在以管理员身份允许的 <code>PowerShell</code> 输入<br><code>Set-ExecutionPolicy RemoteSigned</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临 about_Execution_Policies帮助主题中所述的安全风险。是否要更改执行策略?</span><br><span class="line">[Y] 是(Y)  [N] 否(N)  [S] 挂起(S)  [?] 帮助 (默认值为“Y”): y</span><br></pre></td></tr></table></figure><hr><h3 id="运行-PowerShell-脚本"><a href="#运行-PowerShell-脚本" class="headerlink" title="运行 PowerShell 脚本"></a>运行 <code>PowerShell</code> 脚本</h3><p>当您的脚本编写成功后您可能第一次会像下面的方式运行它，也就是只输入脚本的文件名，会报错。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:&gt; MyScript.ps1</span><br><span class="line"></span><br><span class="line">无法将“MyScript.ps1”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括</span><br><span class="line">路径，请确保路径正确，然后重试。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">13</span></span><br><span class="line">+ MyScript.ps1 &lt; &lt;&lt;&lt;</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (MyScript.ps1:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br><span class="line"></span><br><span class="line">Suggestion [<span class="number">3</span>,<span class="type">General</span>]: 未找到命令 MyScript.ps1，但它确实存在于当前位置。Windows PowerShell 默认情况下不从当前位置加载命令。如果信任此命令，请改为键入 <span class="string">&quot;./MyScript.ps1&quot;</span>。有关更多详细信息，请参阅 <span class="string">&quot;get-h</span></span><br><span class="line"><span class="string">elp about_Command_Precedence&quot;</span>。</span><br></pre></td></tr></table></figure><p>解决办法很简单，如果脚本在当前工作目录，请在脚本文件明前添加<code>./</code>，或者使用绝对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS E:&gt; .\MyScript.ps1</span><br><span class="line"></span><br><span class="line">2019年3月27日 18:33:03</span><br><span class="line">C:\Program Files\Common Files</span><br><span class="line">files count</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">PS E:&gt; E:MyScript.ps1</span><br><span class="line"></span><br><span class="line">2019年3月27日 18:33:11</span><br><span class="line">C:\Program Files\Common Files</span><br><span class="line">files count</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h5 id="通过重定向创建脚本"><a href="#通过重定向创建脚本" class="headerlink" title="通过重定向创建脚本"></a>通过重定向创建脚本</h5><p>如果想要执行的脚本不是很长，我们甚至可以直接在控制台中要执行的语句重定向给一个脚本文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:&gt; <span class="string">&#x27;&quot;Hello,World!&quot;&#x27;</span> &gt; MyScript.ps1</span><br><span class="line"><span class="built_in">PS</span> E:&gt; ./MyScript.ps1</span><br><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><p>这样有个缺点，就是您的代码必须放在闭合的引号中。这样的书写方式一旦在脚本内部也有引号时，是一件很痛苦的事。甚至您还可能希望在脚本中换行。下面的Here-strings例子不错，也就是将脚本文件通过<code>@&#39; &#39;@</code>闭合起来。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> E:&gt; <span class="string">@&#x27;</span></span><br><span class="line"><span class="string">&gt;&gt; Get-Date</span></span><br><span class="line"><span class="string">&gt;&gt; $Env:CommonProgramFiles</span></span><br><span class="line"><span class="string">&gt;&gt; #Script End</span></span><br><span class="line"><span class="string">&gt;&gt; &quot;files count&quot;</span></span><br><span class="line"><span class="string">&gt;&gt; (ls).Count</span></span><br><span class="line"><span class="string">&gt;&gt; #Script Really End</span></span><br><span class="line"><span class="string">&gt;&gt;</span></span><br><span class="line"><span class="string">&gt;&gt; &#x27;@ &gt; myscript.ps1</span></span><br><span class="line"><span class="string">&gt;&gt;</span></span><br><span class="line"><span class="string">PS E:&gt; .MyScript.ps1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2019年3月27日 18:15:10</span></span><br><span class="line"><span class="string">C:\Program Files\Common Files</span></span><br><span class="line"><span class="string">files count</span></span><br><span class="line"><span class="string">20</span></span><br></pre></td></tr></table></figure><p>Here-String以 <code>@&#39;</code>开头，以<code>&#39;@</code>结束.任何文本都可以存放在里面，哪怕是一些特殊字符，空号，白空格。但是如果您不小心将单引号写成了双引号，<code>PowerShell</code> 将会把里面的变量进行解析。</p><h5 id="通过编辑器创建脚本"><a href="#通过编辑器创建脚本" class="headerlink" title="通过编辑器创建脚本"></a>通过编辑器创建脚本</h5><p>其实最方便的还是使用文本编辑器直接编写代码，保存成PS1文件，右键即可执行。<br>这里推荐使用Visual Studio Code(以下简称VSC)，VSC提供了PS1的自动补全(安装插件)、语法高亮、自动缩进、格式化代码、断点调试等功能。</p><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。<code>PowerShell</code> 的变量定义非常方便。<br>我们可以用 <code>$变量名=初值</code> 的方法定义变量，解释器会根据所赋的初值判断变量类型，类似于C#的 <code>var</code> 关键字或C++11中的 <code>auto</code> 关键字<code>PowerShell</code> 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$.<br>创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外:<strong>单引号中的字符串不会识别和处理变量名。</strong></p><h4 id="选择变量名"><a href="#选择变量名" class="headerlink" title="选择变量名"></a>选择变量名</h4><p>在 <code>PowerShell</code> 中变量名均是以美元符 <code>$</code> 开始，剩余字符可以是数字、字母、下划线的任意字符，并且PowerShell变量名也对大小写不敏感（<code>$a</code> 和 <code>$A</code> 是同一个变量)。<br>某些特殊的字符(比如<code>$</code>等)在 <code>PowerShell</code> 中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$</span>&#123;<span class="string">&quot;I&quot;</span>like <span class="variable">$</span>&#125;=<span class="number">5.1</span></span><br><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$</span>&#123;<span class="string">&quot;I&quot;</span>like <span class="variable">$</span>&#125;</span><br><span class="line"><span class="number">5.1</span></span><br></pre></td></tr></table></figure><p><strong>不能定义和保留变量名称相同的变量</strong><br>使用<code>ls variable:</code> 列出当前使用的所有变量，刚启动的 <code>PowerShell</code> 执行此命令能看到 <code>PowerShell</code> 的所有自动化变量(一旦打开 <code>Powershell</code> 就会自动加载的变量，后面将会详细解释这些变量的作用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Name                           Value</span><br><span class="line">----                           -----</span><br><span class="line">$</span><br><span class="line">?                              True</span><br><span class="line">^</span><br><span class="line">args                           &#123;&#125;</span><br><span class="line">ConfirmPreference              High</span><br><span class="line">ConsoleFileName</span><br><span class="line">DebugPreference                SilentlyContinue</span><br><span class="line">Error                          &#123;&#125;</span><br><span class="line">ErrorActionPreference          Continue</span><br><span class="line">ErrorView                      NormalView</span><br><span class="line">ExecutionContext               System.Management.Automation.EngineIntrinsics</span><br><span class="line">false                          False</span><br><span class="line">FormatEnumerationLimit         4</span><br><span class="line">HOME                           C:\Users\aaaaa</span><br><span class="line">Host                           System.Management.Automation.Internal.Host.InternalHost</span><br><span class="line">InformationPreference          SilentlyContinue</span><br><span class="line">input                          System.Collections.ArrayList+ArrayListEnumeratorSimple</span><br><span class="line">MaximumAliasCount              4096</span><br><span class="line">MaximumDriveCount              4096</span><br><span class="line">MaximumErrorCount              256</span><br><span class="line">MaximumFunctionCount           4096</span><br><span class="line">MaximumHistoryCount            4096</span><br><span class="line">MaximumVariableCount           4096</span><br><span class="line">MyInvocation                   System.Management.Automation.InvocationInfo</span><br><span class="line">NestedPromptLevel              0</span><br><span class="line">null</span><br><span class="line">OutputEncoding                 System.Text.ASCIIEncoding</span><br><span class="line">PID                            8796</span><br><span class="line">PROFILE                        C:\Users\aaaaa\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br><span class="line">ProgressPreference             Continue</span><br><span class="line">PSBoundParameters              &#123;&#125;</span><br><span class="line">PSCommandPath</span><br><span class="line">PSCulture                      zh-CN</span><br><span class="line">PSDefaultParameterValues       &#123;&#125;</span><br><span class="line">PSEdition                      Desktop</span><br><span class="line">PSEmailServer</span><br><span class="line">PSHOME                         C:\Windows\System32\WindowsPowerShell\v1.0</span><br><span class="line">PSScriptRoot</span><br><span class="line">PSSessionApplicationName       wsman</span><br><span class="line">PSSessionConfigurationName     http:&#x2F;&#x2F;schemas.microsoft.com&#x2F;powershell&#x2F;Microsoft.PowerShell</span><br><span class="line">PSSessionOption                System.Management.Automation.Remoting.PSSessionOption</span><br><span class="line">PSUICulture                    zh-CN</span><br><span class="line">PSVersionTable                 &#123;PSVersion, PSEdition, PSCompatibleVersions, BuildVersion...&#125;</span><br><span class="line">PWD                            C:\Users\aaaaa</span><br><span class="line">ShellId                        Microsoft.PowerShell</span><br><span class="line">StackTrace</span><br><span class="line">true                           True</span><br><span class="line">VerbosePreference              SilentlyContinue</span><br><span class="line">WarningPreference              Continue</span><br><span class="line">WhatIfPreference               False</span><br></pre></td></tr></table></figure><h4 id="查看变量类型"><a href="#查看变量类型" class="headerlink" title="查看变量类型"></a>查看变量类型</h4><p>变量可以自动存储任何<code>PowerShell</code>能够识别的类型信息，可以通过 <code>$变量名.GetType()</code> 查看和验证 <code>PowerShell</code> 分配给变量的数据类型</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$num</span>=<span class="number">10</span></span><br><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$num</span>.gettype() <span class="comment">#不区分大小写</span></span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                            BaseType</span><br><span class="line">-------- -------- ----                            --------</span><br><span class="line">True     True     Int32                           System.ValueType</span><br></pre></td></tr></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>如果不想继续使用自定义的变量，可以使用<code>del variable:变量名</code>的方法删除变量，注意此处无<code>$</code>符号</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="number">0</span></span><br><span class="line"><span class="variable">$a</span> <span class="operator">-eq</span> <span class="variable">$null</span></span><br><span class="line">False</span><br><span class="line"><span class="built_in">del</span> variable:a</span><br><span class="line"><span class="variable">$a</span> <span class="operator">-eq</span> <span class="variable">$null</span> </span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>PowerShell支持的变量类型和C#大体相同(没有了short、uint、ulong等)，大多都继承自<code>System.ValueType</code>类( .NET类)，其基本数据类型包括</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table><thead><tr><th>类型</th><th>名称</th><th>允许的值</th><th>所属类</th></tr></thead><tbody><tr><td>byte</td><td>无符号整数(1字节)</td><td>0~255之间的整数</td><td>System.Byte</td></tr><tr><td>sbyte</td><td>有符号整数(1字节)</td><td>-128~127之间的整数</td><td>System.SByte</td></tr><tr><td>int16</td><td>有符号短整型(2字节)</td><td>-32768~32767之间的整数</td><td>System.Int16</td></tr><tr><td>uint16</td><td>无符号短整型(2字节)</td><td>0~65535之间的整数</td><td>System.UInt16</td></tr><tr><td>int</td><td>有符号整型</td><td>-2147483648~2147483647之间的整数</td><td>System.Int32</td></tr><tr><td>uint32</td><td>无符号整型</td><td>0~4294967295之间的整数</td><td>System.UInt32</td></tr><tr><td>long</td><td>有符号长整数(8字节)</td><td>-9223372036854775808~9223372036854775807之间的整数</td><td>System.Int64</td></tr><tr><td>ulong</td><td>无符号长整数(8字节)</td><td>0~18446744073709551615之间的整数</td><td>System.UInt64</td></tr></tbody></table><p>其实 <code>int</code> 、<code>long</code> 、以及下面的 <code>float</code> 都是 .NET的语法糖，真正的原生类型名是<code>int32</code>、<code>int64</code>、<code>single</code> 之类的类名</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点数标准形式(<code>float</code>和<code>double</code>)<br>$+/-m×2^e$<br>其中m为尾数，e为阶码，尾数是一个非负数，阶码是一个整数<br>PowerShell还支持一个特别的浮点数类型 <code>decimal</code>，其形式为<br>$+/-m×10^e$</p><table><thead><tr><th>类型</th><th>名称</th><th>指数</th><th>m范围</th><th>e范围</th><th>近似最小值</th><th>近似最大值</th><th>所属类</th></tr></thead><tbody><tr><td>float</td><td>单精度浮点数</td><td>2</td><td>0~$2^{24}$</td><td>-149~104</td><td>$1.5×10^{-45}$</td><td>$3.4×10^{38}$</td><td>System.Single</td></tr><tr><td>double</td><td>双精度浮点数</td><td>2</td><td>0~$2^{53}$</td><td>-1075~970</td><td>$5.0×10^{-324}$</td><td>$1.7×10^{308}$</td><td>System.Double</td></tr><tr><td>decimal</td><td>16字节浮点数</td><td>10</td><td>0~$2^{96}$</td><td>-28~0</td><td>$1.0×10^{-28}$</td><td>$7.9×10^{28}$</td><td>System.Decimal</td></tr></tbody></table><h4 id="其他简单类型"><a href="#其他简单类型" class="headerlink" title="其他简单类型"></a>其他简单类型</h4><p>除了数值类型以外，还有3种基本类型</p><table><thead><tr><th>类型</th><th>名称</th><th>允许的值</th><th>所属类</th></tr></thead><tbody><tr><td>char</td><td>字符型</td><td>一个Unicode字符，存储0~65535之间的整数</td><td>System.Char</td></tr><tr><td>bool</td><td>布尔型</td><td>布尔值: <code>$true</code> 或 <code>$false</code>(必须加<code>$</code>符号)</td><td>System.Boolean</td></tr><tr><td>enum</td><td>枚举</td><td>限定取值一组命名常量的独特的值类型</td><td>System.Enum</td></tr><tr><td>datetime</td><td>时间型</td><td>包含日期、时间的类型</td><td>System.DateTime</td></tr><tr><td>string</td><td>字符串</td><td>一组字符</td><td>System.String</td></tr></tbody></table><p>注意 <strong>C/C++的 <code>char</code> 仅支持ASCII里面的256个字符, <code>PowerShell</code> 和 <code>C#</code> 的 <code>char</code> 是支持Unicode的</strong>，<br><strong>PowerShell和C#的<code>string</code>类型并不是继承自 <code>System.ValuType</code> 类，而是继承自 <code>System.Object</code> 类</strong>，因此严格来说 <code>string</code> 类型并非是简单类型。<br>**PowerShell的转义字符是 ` 而不是 \**，这也是和C#的一个区别</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用char</span></span><br><span class="line"><span class="built_in">PS</span> D:/&gt;[<span class="built_in">char</span>]<span class="variable">$c</span>=<span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="variable">$c</span></span><br><span class="line">A</span><br><span class="line"><span class="comment">#使用bool</span></span><br><span class="line"><span class="built_in">PS</span> D:/&gt;<span class="variable">$boolean</span>=<span class="variable">$true</span></span><br><span class="line"><span class="variable">$boolean</span></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用enum</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">fruit</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line">durian</span><br><span class="line">&#125;</span><br><span class="line">[<span class="type">fruit</span>]<span class="variable">$en</span>=[<span class="type">fruit</span>]::apple</span><br><span class="line"><span class="variable">$en</span></span><br><span class="line">apple</span><br><span class="line"><span class="variable">$item</span>=<span class="string">&quot;cherry&quot;</span></span><br><span class="line">[<span class="type">fruit</span>]<span class="variable">$enu</span>=[<span class="type">fruit</span>]::(<span class="variable">$item</span>)</span><br><span class="line"><span class="variable">$enu</span></span><br><span class="line">cherry</span><br><span class="line"></span><br><span class="line"><span class="comment">#这种使用方法是错误的</span></span><br><span class="line"><span class="built_in">PS</span> D:/&gt; [<span class="type">fruit</span>]<span class="variable">$enum</span>=banana</span><br><span class="line"></span><br><span class="line">banana : 无法将“banana”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">12</span></span><br><span class="line">+ [<span class="type">fruit</span>]<span class="variable">$en</span>=banana</span><br><span class="line">+            ~~~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (banana:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br><span class="line"></span><br><span class="line"><span class="comment">#当尝试使用非枚举值进行赋值时</span></span><br><span class="line"><span class="built_in">PS</span> D:/&gt; [<span class="type">fruit</span>]<span class="variable">$en</span>=[<span class="type">fruit</span>]::peach</span><br><span class="line"></span><br><span class="line">由于枚举值无效，无法将 Null 转换为类型“fruit”。请指定以下枚举值之一，然后重试。可能的枚举值为“apple,banana,cherry,durian”。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ [<span class="type">fruit</span>]<span class="variable">$en</span>=[<span class="type">fruit</span>]::peach</span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException</span><br><span class="line">    + FullyQualifiedErrorId : RuntimeException</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:/&gt; <span class="string">&quot;\n 123 `n 123&quot;</span></span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">\n 123</span></span><br><span class="line"><span class="comment"> 123</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:/&gt;<span class="variable">$date</span>=<span class="built_in">get-date</span></span><br><span class="line"><span class="variable">$date</span></span><br><span class="line"><span class="variable">$date</span>.gettype()</span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">2019年3月28日 19:32:30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">IsPublic IsSerial Name                            BaseType</span></span><br><span class="line"><span class="comment">-------- -------- ----                            --------</span></span><br><span class="line"><span class="comment">True     True     DateTime                        System.ValueType</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><h4 id="赋值和返回值"><a href="#赋值和返回值" class="headerlink" title="赋值和返回值"></a>赋值和返回值</h4><p>赋值操作符为 <code>=</code>，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令<br>，因为 <code>PowerShell</code> 支持面向对象，对象可以包罗万象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PS D:\powershell\test&gt; $item&#x3D;ls</span><br><span class="line">PS D:\powershell\test&gt; $item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\powershell\test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----       2017&#x2F;11&#x2F;24     12:52            136 4-3.cpp</span><br><span class="line">-a----        2019&#x2F;3&#x2F;27     15:13             65 anapple.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\powershell\test&gt; $item.gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                              BaseType</span><br><span class="line">-------- -------- ----                              --------</span><br><span class="line">True     True     Object[]                          System.Array</span><br><span class="line"></span><br><span class="line">$item为一个对象数组</span><br></pre></td></tr></table></figure><h4 id="弱类型与强类型"><a href="#弱类型与强类型" class="headerlink" title="弱类型与强类型"></a>弱类型与强类型</h4><p>一般对 <code>PowerShell</code> 变量重新赋值时，变量类型会自动改变，这是弱类型语言的特点；<br>而 <code>PowerShell</code> 依托的 .NET是强类型的，所以 <code>PowerShell</code> 可以使用强类型。<br>强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。<br>可以在变量前添加类型限定符使该变量变为强类型，可以确保变量的类型不会随着赋值而改变</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">int</span>]<span class="variable">$num</span>=<span class="number">123</span> <span class="comment">#正确</span></span><br><span class="line">[<span class="built_in">int</span>]<span class="variable">$num</span>=<span class="built_in">ls</span> <span class="comment">&lt;#错误</span></span><br><span class="line"><span class="comment">无法将“System.Object[]”类型的“System.Object[]”值转换为“System.Int32”类型。</span></span><br><span class="line"><span class="comment">所在位置 行:1 字符: 1</span></span><br><span class="line"><span class="comment">+ [int]$num=ls</span></span><br><span class="line"><span class="comment">+ ~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment">    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException</span></span><br><span class="line"><span class="comment">    + FullyQualifiedErrorId : RuntimeException</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>PowerShell</code> 能够非常方便地将字符串等基本类型转换成期望的类型。之所以神奇，是因为 <code>PowerShell</code> 本身做了很多辛苦的工作，按照优先级：</p><ol><li> <strong>直接赋值</strong>：输入类型和期望类型一致，可以直接交付。</li><li> <strong>基于语言的类型转换</strong>：当目标类型为<code>void</code>,<code>Boolean</code>,<code>String</code> , <code>Array</code> , <code>Hashtable</code> , <code>PSReference</code> (i.e.: [ref]), <code>XmlDocument</code> , <code>Delegate</code> 和 <code>Enum</code> 时，基于语言的类型转换开始工作。</li><li> <strong>Parse 转换</strong>：如果目标类型包含了 <code>Parse()</code> 方法，则采用它。</li><li> <strong>Static Create 转换</strong>：如果目标类型包含静态的Create，则采用它。</li><li> <strong>构造函数转换</strong>：如果目标类型定义了构造函数，采用它。</li><li> <strong>Cast 转换</strong>：如果目标类型定义了从源类型的显式或者隐式的操作符，则采用它。</li><li> <strong>IConvertible 接口转换</strong>：如果目标类型实现了支持源类型<code>IConvertible</code> 接口，则采用它。</li><li> <strong>IDictionary 转换</strong>：如果源类型是词典或者哈希表，会尝试创建一个实例，然后来填充name和value属性。</li><li> <strong>PSObject 属性转换</strong>：如果源类型是<code>PSObject</code>，通过目标类型的默认的构造函数创建一个实例，然后使用<code>PSObject</code>中的属性名称和值来填充实例的属性。</li><li> <strong>TypeConverter 转换</strong>：如果存在注册的 <code>TypeConverter</code> 或 <code>PSTypeConverter</code> 来处理转换，则使用它。</li></ol><p>注意<strong>对浮点数向整数进行类型转换时，会自动四舍五入！！</strong><br>如果要C++/C#那种向下取整的方法请使用 <code>[math]::Floor()</code> 函数<br>看几个转换的例子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="variable">$s</span>=<span class="number">12.56</span></span><br><span class="line"><span class="built_in">PS</span> D:/test&gt; [<span class="built_in">int</span>]<span class="variable">$s</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="built_in">PS</span> D:/test&gt; [<span class="type">convert</span>]::ToInt32(<span class="variable">$s</span>)</span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p><code>[convert]::ToInt32()</code> 是 .NET <code>System.Convert</code> 类提供的转换函数<br><code>convert</code> 类中的转换函数格式为:<code>TO</code>+<code>原生类型名()</code>，这里的原生类型名指的是各个类型实际类名<br>常用：</p><ul><li><code>[convert]::ToInt32()</code></li><li><code>[convert]::ToSingle()</code></li><li><code>[convert]::ToDouble()</code></li><li><code>[convert]::ToBoolean()</code></li><li><code>[convert]::ToString()</code></li></ul><p><code>convert</code> 类提供了一系列方法来完成不同变量之间的转换，获得函数列表及使用方法请参考微软的 .NET文档<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.convert?redirectedfrom=MSDN&view=netframework-4.7.2#%E6%96%B9%E6%B3%95">Convert类 方法列表</a></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>注意逻辑运算符和比较运算符的写法,不支持 <code>C#</code> 的<code>&amp;&amp;</code> <code>||</code> <code>！</code> <code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;=</code>这些运算符</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加 减 乘 除 取余</span></span><br><span class="line">+ - * / %</span><br><span class="line"><span class="comment">#自增、自减运算符，和C#或C++完全一致</span></span><br><span class="line">++<span class="variable">$i</span></span><br><span class="line"><span class="variable">$i</span>++</span><br><span class="line"><span class="variable">$i</span>--</span><br><span class="line">--<span class="variable">$i</span></span><br><span class="line"><span class="comment">#且</span></span><br><span class="line"><span class="operator">-and</span></span><br><span class="line"><span class="comment">#并</span></span><br><span class="line"><span class="operator">-or</span></span><br><span class="line"><span class="comment">#非</span></span><br><span class="line"><span class="operator">-not</span></span><br><span class="line">!</span><br><span class="line"><span class="comment">#样例</span></span><br><span class="line"><span class="variable">$true</span> <span class="operator">-and</span> <span class="variable">$false</span> <span class="operator">-or</span> <span class="operator">-not</span> <span class="number">0</span></span><br><span class="line">!<span class="variable">$true</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line"><span class="comment">#等于 (equal to)</span></span><br><span class="line"><span class="operator">-eq</span></span><br><span class="line"><span class="comment">#不等于 (not equal to)</span></span><br><span class="line"><span class="literal">-nq</span></span><br><span class="line"><span class="comment">#大于 (greater than)</span></span><br><span class="line"><span class="operator">-gt</span></span><br><span class="line"><span class="comment">#大于等于 (greater than or equal to)</span></span><br><span class="line"><span class="operator">-ge</span></span><br><span class="line"><span class="comment">#小于 (less than)</span></span><br><span class="line"><span class="operator">-lt</span></span><br><span class="line"><span class="comment">#小于等于 (less than or equal to)</span></span><br><span class="line"><span class="operator">-le</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于字符串类型，可以在比较运算符前加i或c表示是否区分大小写,</span></span><br><span class="line"><span class="comment">#i表示对大小写不敏感，c表示敏感，不写默认不敏感</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> <span class="operator">-eq</span> <span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="string">&quot;a&quot;</span> <span class="operator">-ceq</span> <span class="string">&quot;A&quot;</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断变量是否为兼容类型(同一类型或其父类型)，类型格式为 [类型名]</span></span><br><span class="line"><span class="operator">-is</span></span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span></span><br><span class="line"><span class="variable">$a</span> <span class="operator">-is</span> [<span class="built_in">int</span>]</span><br><span class="line"><span class="variable">$b</span>=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="variable">$b</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line"><span class="variable">$a</span> <span class="operator">-is</span> [<span class="type">ValueType</span>]</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True <span class="comment"># System.Int32类继承自System.ValueType类，因此int是其父类型ValueType的子类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><p><code>if</code> 和 <code>else</code> 用法和C#完全一样，除了大括号不允许省略，多分支时还多了个<code>elseif</code> 可用，和<code>Python</code> 的 <code>elif</code> 作用相同</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$true</span> <span class="operator">-and</span> <span class="variable">$true</span>) &#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$a</span> <span class="operator">-eq</span> <span class="variable">$b</span>) &#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>PowerShell的<code>switch</code>非常灵活，使用起来较为方便<br>相对C#或C++，PowerShell的switch不需要写`case:``，但是必须写大括号</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="string">&quot;Beijing&quot;</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="variable">$a</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;Beijing&quot;</span> &#123;<span class="variable">$res</span>=<span class="string">&quot;北京&quot;</span>&#125;</span><br><span class="line"><span class="string">&quot;Shanghai&quot;</span> &#123;<span class="variable">$res</span>=<span class="string">&quot;上海&quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认比较运算符为<code>-eq</code>，你也可以使用下面的例子自定义比较条件，必须保证表达式返回boolen类型($true和$false)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$v</span>=<span class="number">18</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="variable">$v</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="variable">$_</span> <span class="operator">-lt</span> <span class="number">10</span>&#125; &#123;<span class="string">&quot;小于10&quot;</span>&#125; <span class="comment"># $_ 表示当前的传入的变量 直接写的字符串会被输出</span></span><br><span class="line"><span class="number">10</span> &#123;<span class="string">&quot;等于10&quot;</span>&#125;</span><br><span class="line">&#123;<span class="variable">$_</span> <span class="operator">-gt</span> <span class="number">10</span>&#125; &#123;<span class="string">&quot;小于10&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">大于10</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>接下来介绍循环</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p><code>PowerShell</code> 的 <code>for</code> 循环类似于<code>C#</code>，看一个样例:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-lt</span> <span class="number">10</span>;<span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Write-Output</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p><code>Do</code> 和 <code>While</code> 可能产生死循环，为了防止死循环的发生，因此我们必须确切的指定循环终止的条件。指定了循环终止的条件后，一旦条件不满足就会退出循环。<br><code>do-while()</code> 会先执行再去判断，能保证循环至少执行一次。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="variable">$n</span>=<span class="built_in">Read-Host</span> <span class="string">&quot;请输入数字&quot;</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="operator">-ne</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">请输入数字: 1</span></span><br><span class="line"><span class="comment">请输入数字: 2</span></span><br><span class="line"><span class="comment">请输入数字: s</span></span><br><span class="line"><span class="comment">请输入数字: 0</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><h5 id="只使用while"><a href="#只使用while" class="headerlink" title="只使用while"></a>只使用while</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span>=<span class="number">5</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="operator">-gt</span> <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$n</span></span><br><span class="line">    <span class="variable">$n</span>=<span class="variable">$n</span><span class="literal">-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h5><p>使用 <code>continue</code> 关键字，可以终止当前循环，跳过 <code>continue</code> 后其它语句，重新下一次循环。<br>跳出循环语句使用 <code>break</code> 关键字</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="operator">-lt</span> <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$n</span> <span class="operator">-eq</span> <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$n</span>=<span class="variable">$n</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$n</span>=<span class="variable">$n</span>+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="variable">$n</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="operator">-lt</span> <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$n</span> <span class="operator">-eq</span> <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$n</span></span><br><span class="line">    <span class="variable">$n</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种循环 <code>foreach</code> ，等到我们讲到数组再说</p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><p>在 <code>PowerShell</code> 中创建数组可以使用逗号</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span>=<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>对于连续的数字数组可以使用一个更快捷的方法:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span>=<span class="number">1</span>..<span class="number">5</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h5 id="对象数组的多态"><a href="#对象数组的多态" class="headerlink" title="对象数组的多态"></a>对象数组的多态</h5><p>像变量一样，如果数组中元素的类型为弱类型，默认可以存储不同类型的值。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$array</span>=<span class="number">1</span>,<span class="string">&quot;2019&quot;</span>,([<span class="type">Guid</span>]::NewGuid()),(<span class="built_in">get-date</span>)</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$array</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2019</span></span><br><span class="line"></span><br><span class="line">Guid</span><br><span class="line">----</span><br><span class="line">ea5f17c6<span class="literal">-c0a2</span><span class="literal">-42ba</span><span class="literal">-9de4</span><span class="literal">-e4d03bebffaf</span></span><br><span class="line"></span><br><span class="line">DisplayHint : DateTime</span><br><span class="line">Date        : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">29</span> <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Day         : <span class="number">29</span></span><br><span class="line">DayOfWeek   : Friday</span><br><span class="line">DayOfYear   : <span class="number">88</span></span><br><span class="line">Hour        : <span class="number">23</span></span><br><span class="line">Kind        : Local</span><br><span class="line">Millisecond : <span class="number">120</span></span><br><span class="line">Minute      : <span class="number">23</span></span><br><span class="line">Month       : <span class="number">3</span></span><br><span class="line">Second      : <span class="number">39</span></span><br><span class="line">Ticks       : <span class="number">636894986191207086</span></span><br><span class="line">TimeOfDay   : <span class="number">23</span>:<span class="number">23</span>:<span class="number">39.1207086</span></span><br><span class="line">Year        : <span class="number">2019</span></span><br><span class="line">DateTime    : <span class="number">2019</span>年<span class="number">3</span>月<span class="number">29</span>日 <span class="number">23</span>:<span class="number">23</span>:<span class="number">39</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$array</span>|<span class="keyword">foreach</span>&#123;<span class="variable">$_</span>.gettype()&#125;</span><br><span class="line"><span class="comment">#查看数组各元素类型</span></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     Int32                                    System.ValueType</span><br><span class="line">True     True     String                                   System.Object</span><br><span class="line">True     True     Guid                                     System.ValueType</span><br><span class="line">True     True     DateTime                                 System.ValueType</span><br></pre></td></tr></table></figure><h5 id="空数组和单元素数组"><a href="#空数组和单元素数组" class="headerlink" title="空数组和单元素数组"></a>空数组和单元素数组</h5><p>对数组元素可以查看它的公有属性，比如长度<br>只需要输入<code>$数组名.Count</code>即可显示数组长度</p><h6 id="空数组"><a href="#空数组" class="headerlink" title="空数组"></a>空数组</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$a</span>=<span class="selector-tag">@</span>()</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$a</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line">True</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$a</span>.Count</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h6 id="单元素数组"><a href="#单元素数组" class="headerlink" title="单元素数组"></a>单元素数组</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:Powershell&gt; <span class="variable">$a</span>=,<span class="string">&quot;moss&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:Powershell&gt; <span class="variable">$a</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line">True</span><br><span class="line"><span class="built_in">PS</span> C:Powershell&gt; <span class="variable">$a</span>.Count</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><h6 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h6><p>将数组作为单独一行将会自动遍历这个数组的所有元素</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$a</span>=<span class="number">1</span>..<span class="number">10</span></span><br><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$a</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h6 id="for-循环遍历"><a href="#for-循环遍历" class="headerlink" title="for 循环遍历"></a><code>for</code> 循环遍历</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="variable">$a</span>=<span class="number">1</span>..<span class="number">5</span></span><br><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> <span class="operator">-lt</span> <span class="number">5</span>;<span class="variable">$i</span>++) &#123;</span><br><span class="line">&gt;&gt; <span class="variable">$a</span>[<span class="variable">$i</span>] &#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="foreach-遍历法"><a href="#foreach-遍历法" class="headerlink" title="foreach 遍历法"></a><code>foreach</code> 遍历法</h6><p>还有一种遍历的方法，用到了之前提到的 <code>foreach</code> 语句<br>意思是使用变量 <code>$n</code> 对 <code>$a</code> 元素进行迭代，这实际上是一种对可迭代对象的访问算法<br>在 <code>C#</code> 也有这种语法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$n</span> <span class="keyword">in</span> <span class="variable">$a</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$n</span>+<span class="string">&quot; &quot;</span>+<span class="variable">$n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">A A</span><br><span class="line">B B</span><br><span class="line">C C</span><br><span class="line">D D</span><br><span class="line">E E</span><br></pre></td></tr></table></figure><p><code>foreach</code>还有一种遍历的写法</p><p>这里我们需要先了解一下<strong>管道</strong><br>管道的符号 |<br>管道允许将它左侧命令的输出结果发送到右侧做命令的参数<br>管道并不是什么新事物，以前的Cmd控制台也有重定向的命令，例如Dir | More可以将结果分屏显示。<br>传统的Cmd管道是基于文本的，但是 <code>PowerShell</code> 是基于对象的</p><p>列出当前目录下的目录和文件，然后根据文件名降序排列，再投影(数据库术语)文件名，文件大小，文件的修改时间:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="built_in">ls</span> | <span class="built_in">Sort-Object</span> <span class="literal">-Descending</span> Name | <span class="built_in">Select-Object</span> Name,Length,LastWriteTime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:/test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name        Length LastWriteTime</span><br><span class="line">----        ------ -------------</span><br><span class="line">out.txt        <span class="number">523</span> <span class="number">2019</span>/<span class="number">2</span>/<span class="number">24</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">35</span></span><br><span class="line">lang.json     <span class="number">6415</span> <span class="number">2019</span>/<span class="number">2</span>/<span class="number">16</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">24</span></span><br><span class="line">anapple.txt     <span class="number">65</span> <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">15</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line"><span class="number">4</span><span class="literal">-3</span>.cpp        <span class="number">136</span> <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">52</span>:<span class="number">28</span></span><br></pre></td></tr></table></figure><p>可迭代对象(比如数组)可以由管道送到一些命令上进一步处理<br><code>foreach</code>就可以接受管道送来的可迭代对象，并进行遍历</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$array</span>=<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span></span><br><span class="line"><span class="variable">$array</span>|<span class="keyword">foreach</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$_</span>+<span class="string">&quot;s&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">As</span><br><span class="line">Bs</span><br><span class="line">Cs</span><br><span class="line">Ds</span><br><span class="line">Es</span><br></pre></td></tr></table></figure><h5 id="将数组逆序输出"><a href="#将数组逆序输出" class="headerlink" title="将数组逆序输出"></a>将数组逆序输出</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>=<span class="string">&quot;A1&quot;</span>,<span class="string">&quot;B2&quot;</span>,<span class="string">&quot;C3&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>[(<span class="variable">$books</span><span class="type">.Count</span>)<span class="type">..0</span>]</span><br><span class="line">C3</span><br><span class="line">B2</span><br><span class="line">A1</span><br></pre></td></tr></table></figure><h5 id="访问某些元素"><a href="#访问某些元素" class="headerlink" title="访问某些元素"></a>访问某些元素</h5><p>与C#相同，数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是 <code>PowerShell</code> 为了使用方便，直接可以将 -1 作为最后的一个元素的索引(参考了 <code>Python</code> 的语法)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>=<span class="string">&quot;1A&quot;</span>,<span class="string">&quot;2B&quot;</span>,<span class="string">&quot;3C&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span>A</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span>B</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>[(<span class="variable">$book</span><span class="type">.Count</span>-<span class="number">1</span>)]</span><br><span class="line"><span class="number">3</span>C</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>[-<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span>C</span><br></pre></td></tr></table></figure><h5 id="从数组中选择多个元素"><a href="#从数组中选择多个元素" class="headerlink" title="从数组中选择多个元素"></a>从数组中选择多个元素</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$result</span>=<span class="built_in">ls</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$result</span>[<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>]</span><br><span class="line">    Directory: C:Powershell</span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime     Length Name</span><br><span class="line">----                -------------     ------ ----</span><br><span class="line">d----        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">23</span>     <span class="number">17</span>:<span class="number">25</span>            ABC</span><br><span class="line"><span class="literal">-a</span>---        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">20</span>:<span class="number">04</span>      <span class="number">26384</span> a.txt</span><br><span class="line"><span class="literal">-a</span>---        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">20</span>:<span class="number">27</span>      <span class="number">12060</span> alias.ps1</span><br><span class="line"><span class="literal">-a</span>---        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">17</span>:<span class="number">37</span>       <span class="number">7420</span> name.html</span><br></pre></td></tr></table></figure><h5 id="给数组添加元素"><a href="#给数组添加元素" class="headerlink" title="给数组添加元素"></a>给数组添加元素</h5><p>因为PowerShell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用 <code>+=</code> 操作符。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>=<span class="string">&quot;A1&quot;</span>,<span class="string">&quot;B2&quot;</span>,<span class="string">&quot;C3&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span>+=<span class="string">&quot;D4&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$books</span></span><br><span class="line">A1</span><br><span class="line">B2</span><br><span class="line">C3</span><br><span class="line">D4</span><br></pre></td></tr></table></figure><h5 id="删除指定位置元素"><a href="#删除指定位置元素" class="headerlink" title="删除指定位置元素"></a>删除指定位置元素</h5><p>采用截断重连法删除指定元素</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$num</span>=<span class="number">1</span>..<span class="number">4</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$num</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$num</span>=<span class="variable">$num</span>[<span class="number">0</span><span class="type">..1</span>]+<span class="variable">$num</span>[<span class="number">3</span>] <span class="comment">#相当于删掉了第三项</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$num</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><p>数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用 <code>Clone()</code> 方法( <code>System.Array</code> 类的成员函数)，除非有特殊需求。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chs</span>=<span class="selector-tag">@</span>(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chsBak</span>=<span class="variable">$chs</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chsBak</span>[<span class="number">1</span>]=<span class="string">&quot;H&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chs</span></span><br><span class="line">A</span><br><span class="line"><span class="built_in">H</span></span><br><span class="line">C</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chs</span>.Equals(<span class="variable">$chsBak</span>)</span><br><span class="line">True</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chsNew</span>=<span class="variable">$chs</span>.Clone()</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chsNew</span>[<span class="number">1</span>]=<span class="string">&quot;Good&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chs</span>.Equals(<span class="variable">$chsNew</span>)</span><br><span class="line">False</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$chs</span></span><br><span class="line">A</span><br><span class="line"><span class="built_in">H</span></span><br><span class="line">C</span><br></pre></td></tr></table></figure><h4 id="强类型数组"><a href="#强类型数组" class="headerlink" title="强类型数组"></a>强类型数组</h4><p><code>PowerShell</code> 数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常，这样的数组被称为强类型数组<br>定义方法<code>[类型[]]$数组名=初值</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; [<span class="built_in">int</span>[]] <span class="variable">$nums</span>=<span class="selector-tag">@</span>()</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="number">2012</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="number">12.3</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="string">&quot;999&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="string">&quot;can not convert&quot;</span></span><br><span class="line">Cannot convert value <span class="string">&quot;can not convert&quot;</span> to <span class="built_in">type</span> <span class="string">&quot;System.Int32&quot;</span>. Error: <span class="string">&quot;Input string was not in a correct format.&quot;</span></span><br><span class="line">At line:<span class="number">1</span> char:<span class="number">6</span></span><br><span class="line">+ <span class="variable">$nums</span> &lt;&lt;&lt;&lt; +=<span class="string">&quot;can not convert&quot;</span></span><br><span class="line">    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException</span><br><span class="line">    + FullyQualifiedErrorId : RuntimeException</span><br></pre></td></tr></table></figure><h4 id="命令返回数组"><a href="#命令返回数组" class="headerlink" title="命令返回数组"></a>命令返回数组</h4><p>当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。<br>但是，事实上 <code>PowerShell</code> 会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时， <code>PowerShell</code> 也会自动把结果存储为数组</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$IPcfg</span>=ipconfig</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$IPcfg</span></span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Windows IP 配置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以太网适配器 以太网:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . : lan</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无线局域网适配器 本地连接* 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无线局域网适配器 本地连接* 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . :</span></span><br><span class="line"><span class="comment">   本地链接 IPv6 地址. . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   IPv4 地址 . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   子网掩码  . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   默认网关. . . . . . . . . . . . . :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以太网适配器 VMware Network Adapter VMnet8:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . :</span></span><br><span class="line"><span class="comment">   本地链接 IPv6 地址. . . . . . . . : fe80::f88d:cd97:5343:9713%16</span></span><br><span class="line"><span class="comment">   IPv4 地址 . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   子网掩码  . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   默认网关. . . . . . . . . . . . . :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无线局域网适配器 WLAN:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   本地链接 IPv6 地址. . . . . . . . : fe80::954:3964:3731:997e%18</span></span><br><span class="line"><span class="comment">   IPv4 地址 . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   子网掩码  . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   默认网关. . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$IPcfg</span>.Count</span><br><span class="line"><span class="number">37</span></span><br></pre></td></tr></table></figure><h5 id="使用数组存储结果"><a href="#使用数组存储结果" class="headerlink" title="使用数组存储结果"></a>使用数组存储结果</h5><p>判断一个变量是否为数组</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$ip</span>=ipconfig</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$ip</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line">True</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="string">&quot;abac&quot;</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line">False</span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$str</span>=<span class="string">&quot;字符串&quot;</span></span><br><span class="line"><span class="built_in">PS</span> C:/Powershell&gt; <span class="variable">$str</span>.ToCharArray() <span class="operator">-is</span> [<span class="built_in">array</span>] <span class="comment">#转换为字符数组</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h5 id="使用真实的对象操作"><a href="#使用真实的对象操作" class="headerlink" title="使用真实的对象操作"></a>使用真实的对象操作</h5><p>为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令(事实上ipconfig是一个单独的程序)，真正的 <code>PowerShell</code> 命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="variable">$list</span>=<span class="built_in">ls</span></span><br><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="variable">$list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:/test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line"><span class="literal">-a</span>----       <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">12</span>:<span class="number">52</span>            <span class="number">136</span> <span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line"><span class="literal">-a</span>----        <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span>     <span class="number">15</span>:<span class="number">13</span>             <span class="number">65</span> anapple.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="variable">$list</span>.gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     Object[]                                 System.Array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="keyword">foreach</span>(<span class="variable">$i</span> <span class="keyword">in</span> <span class="variable">$list</span>)&#123;<span class="variable">$i</span>.name&#125;</span><br><span class="line"><span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line">anapple.txt</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="variable">$list</span>[<span class="number">0</span>].gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     FileInfo                                 System.IO.FileSystemInfo</span><br></pre></td></tr></table></figure><p>上面的例子中数组的每一个元素存放的是一个 <code>System.IO.DirectoryInfo</code> 对象。<br>当我们输出这些对象时，<code>PowerShell</code> 会自动帮我们把它转换成友好的文本格式。<br>对于任何一个对象都可以使用 <code>Format-List *</code> 来查看它所有的属性和方法。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> D:/test&gt; <span class="variable">$list</span>[<span class="number">0</span>]|<span class="built_in">fl</span> * </span><br><span class="line"><span class="comment"># &quot;|&quot;符号是管道符，将左边返回结果做参数发送到右侧，fl是Format-List的简称</span></span><br><span class="line"></span><br><span class="line">PSPath            : Microsoft.PowerShell.Core\FileSystem::D:test\<span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line">PSParentPath      : Microsoft.PowerShell.Core\FileSystem::D:\test</span><br><span class="line">PSChildName       : <span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line">PSDrive           : D</span><br><span class="line">PSProvider        : Microsoft.PowerShell.Core\FileSystem</span><br><span class="line">PSIsContainer     : False</span><br><span class="line">Mode              : <span class="literal">-a</span>----</span><br><span class="line">VersionInfo       : File:             D:\test\<span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line">                    InternalName:</span><br><span class="line">                    OriginalFilename:</span><br><span class="line">                    FileVersion:</span><br><span class="line">                    FileDescription:</span><br><span class="line">                    Product:</span><br><span class="line">                    ProductVersion:</span><br><span class="line">                    Debug:            False</span><br><span class="line">                    Patched:          False</span><br><span class="line">                    PreRelease:       False</span><br><span class="line">                    PrivateBuild:     False</span><br><span class="line">                    SpecialBuild:     False</span><br><span class="line">                    Language:</span><br><span class="line"></span><br><span class="line">BaseName          : <span class="number">4</span><span class="literal">-3</span></span><br><span class="line">Target            : &#123;&#125;</span><br><span class="line">LinkType          :</span><br><span class="line">Name              : <span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line">Length            : <span class="number">136</span></span><br><span class="line">DirectoryName     : D:\test</span><br><span class="line">Directory         : D:\test</span><br><span class="line">IsReadOnly        : False</span><br><span class="line">Exists            : True</span><br><span class="line">FullName          : D:\test\<span class="number">4</span><span class="literal">-3</span>.cpp</span><br><span class="line">Extension         : .cpp</span><br><span class="line">CreationTime      : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">CreationTimeUtc   : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">7</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">LastAccessTime    : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">LastAccessTimeUtc : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">7</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">LastWriteTime     : <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">52</span>:<span class="number">28</span></span><br><span class="line">LastWriteTimeUtc  : <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span> <span class="number">4</span>:<span class="number">52</span>:<span class="number">28</span></span><br><span class="line">Attributes        : Archive</span><br></pre></td></tr></table></figure><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是自定义的 <code>Powershell</code> 代码，有三个原则：  </p><ul><li><strong>简短</strong>：函数名简短，并且显而易见。  </li><li><strong>聚合</strong>：函数可以完成多个操作。  </li><li><strong>封装和扩展</strong>：将一批 <code>Powershell</code> 语句进行封装，实现全新的功能需求。<br>函数的结构由三部分组成：函数名，参数，函数体</li></ul><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><h5 id="脚本中函数的定义方法"><a href="#脚本中函数的定义方法" class="headerlink" title="脚本中函数的定义方法"></a>脚本中函数的定义方法</h5><p>函数可以在文本编辑器上编写，写完以后复制进 <code>PowerShell</code> 控制台即可。如果控制台设置为快速编辑模式，从记事本复制后，直接在控制台鼠标右键即可完成粘贴(Windows 10默认开启了快速编辑模式)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FuncName</span><span class="params">(args[])</span> #括号可省略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">&lt;#代码段#&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="控制台上多行输入定义函数"><a href="#控制台上多行输入定义函数" class="headerlink" title="控制台上多行输入定义函数"></a>控制台上多行输入定义函数</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="function"><span class="keyword">function</span> <span class="title">MyPing</span></span></span><br><span class="line">&gt;&gt; &#123;</span><br><span class="line">&gt;&gt; PING.EXE  <span class="literal">-n</span> <span class="number">1</span> <span class="variable">$args</span></span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt;</span><br></pre></td></tr></table></figure><h5 id="把函数精简成一行"><a href="#把函数精简成一行" class="headerlink" title="把函数精简成一行"></a>把函数精简成一行</h5><p>我们可以将一个函数定义在一行上，但是这样阅读和理解起来就不方便，所以要在每条命令后加分号进行分割(最后一句可以不写<code>;</code>)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="function"><span class="keyword">function</span> <span class="title">cd</span>...</span>&#123; <span class="built_in">cd</span>.. ; <span class="built_in">cd</span>.. &#125;</span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="built_in">cd</span>...</span><br></pre></td></tr></table></figure><h5 id="使用函数作为别名"><a href="#使用函数作为别名" class="headerlink" title="使用函数作为别名"></a>使用函数作为别名</h5><p>假如 <code>PowerShell</code> 不支持 <code>Get-SystemVersion</code> 命令，你可以通过定义函数实现这个功能：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get-systemversion</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$psversiontable</span>.BuildVersion</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Get-SystemVersion</span></span><br><span class="line"></span><br><span class="line">Major  Minor  Build  Revision</span><br><span class="line">-----  -----  -----  --------</span><br><span class="line"><span class="number">10</span>     <span class="number">0</span>      <span class="number">17134</span>  <span class="number">590</span></span><br></pre></td></tr></table></figure><h5 id="更新函数"><a href="#更新函数" class="headerlink" title="更新函数"></a>更新函数</h5><p>如果要更新已经定义好的函数，简单的方法是重新定义，这样新的定义会覆盖旧的定义。但是如果函数代码没有保存副本，可以先将函数定义导出到ps文件，然后就可以编辑了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="function"><span class="keyword">function</span> <span class="title">MyPing</span></span></span><br><span class="line">&gt;&gt; &#123;</span><br><span class="line">&gt;&gt; PING.EXE  <span class="literal">-n</span> <span class="number">1</span> <span class="variable">$args</span></span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="variable">$function:MyPing</span> | <span class="built_in">Out-File</span> myPing.ps1</span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="variable">$function:MyPing</span></span><br><span class="line"></span><br><span class="line">PING.EXE  <span class="literal">-n</span> <span class="number">1</span> <span class="variable">$args</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; <span class="variable">$function:MyPing</span> | <span class="built_in">Out-File</span> myPing.ps1</span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; .myPing.ps1</span><br><span class="line">必须指定 IP 地址。</span><br><span class="line"><span class="built_in">PS</span> C:/PowerShell&gt; notepad.exe <span class="variable">$</span><span class="variable">$</span></span><br></pre></td></tr></table></figure><h5 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h5><p>控制台定义的函数只会在当前会话生效，一旦控制台退出，会自动消失。在不关闭控制台的条件下删除一个已经定义好的函数，可是使用虚拟驱动器的方法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cc</span></span>&#123;<span class="string">&quot;hello&quot;</span>&#125;</span><br><span class="line"><span class="built_in">PS</span> C:/&gt; cc</span><br><span class="line">hello</span><br><span class="line"><span class="built_in">PS</span> C:/&gt; <span class="built_in">del</span> function:cc</span><br><span class="line"><span class="built_in">PS</span> C:/&gt; cc</span><br><span class="line">cc : 无法将“cc”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ cc</span><br><span class="line">+ ~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (cc:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br></pre></td></tr></table></figure><h4 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h4><p>用于脚本文件的编写</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>PowerShell提供了 <code>Read-Host</code> 命令，可以接收返回用户在控制台输入的字符</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>=<span class="built_in">read-host</span> <span class="string">&quot;请输入你的名字&quot;</span> </span><br><span class="line"><span class="comment">#会把提示信息打印到PS控制台，也可以不写提示信息</span></span><br><span class="line"><span class="comment">&lt;#执行+输入 结果:</span></span><br><span class="line"><span class="comment">请输入你的名字: Nougat </span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="variable">$name</span></span><br><span class="line">Nougat</span><br></pre></td></tr></table></figure><p>注意到</p><ol><li>提示信息(如果有)后面自动加了个冒号；</li><li>用户键入任何信息都被作为该命令的返回结果；</li><li>可以把键入的信息传递给一个变量；</li></ol><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>有两种输出命令<br><code>Write-Host</code>和<code>Write-Output</code><br>若输出字符串不包含空白字符可以不加引号</p><h6 id="Write-Host"><a href="#Write-Host" class="headerlink" title="Write-Host"></a><code>Write-Host</code></h6><p>当需要展示一个特定信息，比如使用其他颜色来吸引人们的注意力的时候，可使用 <code>Write-Host</code> 命令<br> <code>Write-Host</code> 和其他Cmdlets一样使用管道，但是它不放置任何数据道管道中。反而会直接写到宿主应用程序的界面。正如此，可以使用<code>-ForegroundColor</code> 和 <code>-BackgroundColor</code> 参数将前景和背景设置为其他颜色：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write-host</span> <span class="string">&quot;啊哈&quot;</span> <span class="literal">-ForegroundColor</span> White <span class="literal">-BackgroundColor</span> Red</span><br><span class="line">啊哈</span><br></pre></td></tr></table></figure><p>注：<strong>不是每个使用PowerShell的应用程序都支持其他颜色，也并不是每个应用程序都支持所有颜色</strong>。<br>该输出方法<strong>不适用于常规的输出结果</strong>，因为 <code>Write-Host</code> 命令输出到屏幕的任何东西都无法被捕捉。若执行远程命令或无人值守命令(纯自动化)， <code>Write-Host</code> 可能不会按照你的预期工作。因此，此命令仅仅用于与人进行直接交互。</p><h6 id="Write-Output"><a href="#Write-Output" class="headerlink" title="Write-Output"></a><code>Write-Output</code></h6><p><code>Write-Output</code>命令会将对象发送给管道。由于它不会直接发送到显示界面，所以不允许你指定其他任何的颜色。</p><p>它是<code>PowerShell</code>默认使用的一个Cmdlets，默认输出方式即使用该命令，即使你没有指定，<code>PowerShell</code>会在底层将信息传递给<code>Write-Output</code>命令(就是一行直接写一个变量就能直接输出的情况)，另外这个命令还有两个别名 <code>write</code> 和 <code>echo</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write-host</span> ACB <span class="comment">#无空白字符可以不写引号 </span></span><br><span class="line">ACB</span><br><span class="line"><span class="built_in">write</span> <span class="string">&quot;ABC&quot;</span></span><br><span class="line">ABC</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ABD&quot;</span></span><br><span class="line">ABD</span><br></pre></td></tr></table></figure><p><code>Write-Output</code>输出基本过程为：</p><blockquote><ol><li><code>Write-Output</code>命令将<code>string</code>类型的对象<code>Hello World!</code>放入管道中；</li><li>管道中只有这个<code>string</code>对象，其会直接到达管道的末端，也就是<code>Out-Default</code>命令；</li><li><code>Out-Default</code>命令将对象传递给<code>Out-Host</code>命令；</li><li><code>Out-Host</code>命令要求<code>PowerShell</code>的格式化系统格式化该对象。</li><li><code>Out-Host</code>将格式化的结果集放在显示界面上</li></ol></blockquote><p>还有一点，在输出多个对象时，<code>Write-Host</code>会以空格隔开各对象<br><code>Write-Output</code>会以换行隔开各对象</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write-host</span> <span class="string">&quot;ABC&quot;</span> <span class="string">&quot;23232&quot;</span></span><br><span class="line">ABC <span class="number">23232</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write-output</span> <span class="string">&quot;ABC&quot;</span> <span class="string">&quot;23232&quot;</span></span><br><span class="line">ABC </span><br><span class="line"><span class="number">23232</span></span><br></pre></td></tr></table></figure><h6 id="其他的输出方式"><a href="#其他的输出方式" class="headerlink" title="其他的输出方式"></a>其他的输出方式</h6><p><code>Write-Warning/Verbose/Debug/Error</code></p><p>具体参考：<a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/write-debug?view=powershell-3.0">微软官方文档</a></p><h4 id="处理函数参数"><a href="#处理函数参数" class="headerlink" title="处理函数参数"></a>处理函数参数</h4><p><code>PowerShell</code> 函数可以接受参数，并对参数进行处理。函数的参数有3个特性：</p><ol><li>任意参数：内部变量<code>$args</code> 接受函数调用时接受的参数，<code>$args</code>是一个数组类型；</li><li>命名参数：函数的每一个参数可以分配一个名称，在调用时通过名称指定对应的参数；</li><li>预定义参数：函数在定义参数时可以指定默认值，如果调用时没有专门指定参数的值，就会保持默认值；</li></ol><h5 id="args-万能参数"><a href="#args-万能参数" class="headerlink" title="$args 万能参数"></a>$args 万能参数</h5><p>给一个函数定义参数最简单的是使用<code>$args</code>这个内置的参数。它可以识别任意个参数。尤其适用那些参数可有可无的函数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$args</span>.Count <span class="operator">-eq</span> <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;No argument!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$args</span> | <span class="keyword">foreach</span> &#123;<span class="string">&quot;Hello,<span class="variable">$</span>(<span class="variable">$_</span>)&quot;</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#无参调用</span></span><br><span class="line">sayhello</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">No argument!</span><br><span class="line"></span><br><span class="line"><span class="comment">#一参调用</span></span><br><span class="line">sayhello <span class="string">&quot;World!&quot;</span> <span class="comment">#也可以写成sayhello(&quot;World!&quot;)</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Hello,World!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#多参数调用</span></span><br><span class="line"><span class="variable">$str</span>=<span class="string">&quot;it&#x27;s me.&quot;</span></span><br><span class="line">sayhello <span class="number">123</span> <span class="string">&quot;aha&quot;</span> <span class="variable">$str</span> <span class="comment">#如果字符串不包含空白字符(比如空格)，引号可以不写</span></span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">Hello,123</span></span><br><span class="line"><span class="comment">Hello,aha</span></span><br><span class="line"><span class="comment">Hello,it&#x27;s me.</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><p>因为 <code>$arg</code> 是一个数组,可以用它很方便的写出求和函数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$sum</span>=<span class="number">0</span></span><br><span class="line"><span class="variable">$args</span> | <span class="keyword">foreach</span> &#123;<span class="variable">$sum</span>=<span class="variable">$sum</span>+<span class="variable">$_</span>&#125;</span><br><span class="line"><span class="variable">$sum</span></span><br><span class="line">&#125;</span><br><span class="line">Add <span class="number">10</span> <span class="number">7</span> <span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="comment">#120</span></span><br></pre></td></tr></table></figure><h5 id="使用固定参数"><a href="#使用固定参数" class="headerlink" title="使用固定参数"></a>使用固定参数</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">StringContact</span><span class="params">(<span class="variable">$str1</span>,<span class="variable">$str2</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str1</span>+<span class="variable">$str2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StringContact LN P</span><br><span class="line"><span class="comment">#StringContact -str1 word -str2 press</span></span><br><span class="line"><span class="comment">#StringContact(&quot;word&quot;,&quot;press&quot;)</span></span><br><span class="line">LNP</span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure><h5 id="给参数定义默认值"><a href="#给参数定义默认值" class="headerlink" title="给参数定义默认值"></a>给参数定义默认值</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringContact</span><span class="params">(<span class="variable">$str1</span>=&quot;LN&quot;,<span class="variable">$str2</span>=&quot;P&quot;)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str1</span>+<span class="variable">$str2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringContact</span><br><span class="line">LNP</span><br></pre></td></tr></table></figure><h5 id="使用强类型参数"><a href="#使用强类型参数" class="headerlink" title="使用强类型参数"></a>使用强类型参数</h5><p>通过之前的例子发现将用户的参数传递给函数显得比较混乱。罪魁祸首就是<code>PowerShell</code>的参数解释器，它可以自动处理和分配参数给函数。<br>函数的参数解释器比较傲慢，它对你提供的参数的信息完全不关心。它只会粗略地将参数进行分割，并且最大限度的进行自动类型转换。事实上，这种类型转换很多时候并不完美。所以<strong>最好提前能够对参数进行强类型限制</strong></p><h5 id="限制数字类型"><a href="#限制数字类型" class="headerlink" title="限制数字类型"></a>限制数字类型</h5><p>下面的函数执行后，会抛出异常<br>因为 <code>subtract</code> 的参数定义了强类型，参数的类型可能引起函数的处理结果改变。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span><span class="params">([int]<span class="variable">$value1</span>,[int]<span class="variable">$value2</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$value1</span>-<span class="variable">$value2</span></span><br><span class="line">&#125;</span><br><span class="line">subtract LN P</span><br><span class="line"><span class="comment">#执行结果报错</span></span><br><span class="line">subtract : 无法处理对参数“value1”的参数转换。无法将值“LN”转换为类型“System.Int32”。错误:“输入字符串的格式不正确。”</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">10</span></span><br><span class="line">+ subtract LN P</span><br><span class="line">+          ~~</span><br><span class="line">    + CategoryInfo          : InvalidData: (:) [<span class="type">subtract</span>]，ParameterBindingArgumentTransformationException</span><br><span class="line">    + FullyQualifiedErrorId : ParameterArgumentTransformationError,subtract</span><br><span class="line"></span><br><span class="line">subtract <span class="number">8.1</span> <span class="number">7.9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">&lt;#结果为0，这是因为PowerShell对结果整型化时进行了四舍五入</span></span><br><span class="line"><span class="comment">但是如果将上面的函数的参数定义为Double型#&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span><span class="params">([double]<span class="variable">$value1</span>,[double]<span class="variable">$value2</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$value1</span>-<span class="variable">$value2</span></span><br><span class="line">&#125;</span><br><span class="line">subtract <span class="number">8.1</span>  <span class="number">7.9</span></span><br><span class="line"><span class="number">0.199999999999999</span></span><br><span class="line"><span class="comment">&lt;#输出 0.199999999999999的原因就是 .NET使用IEEE754标准存储浮点数，</span></span><br><span class="line"><span class="comment">由于这些小数转化二进制会无限循环，会根据一定精度截取尾数，</span></span><br><span class="line"><span class="comment">这个问题引发了这种奇怪的结果，</span></span><br><span class="line"><span class="comment">其实著名的0.1+0.2!=0.3也是这个原因导致的#&gt;</span></span><br></pre></td></tr></table></figure><h5 id="限制日期类型"><a href="#限制日期类型" class="headerlink" title="限制日期类型"></a>限制日期类型</h5><p>函数的参数解释器会自动尝试将字符串转换成日期类型，如果转换失败就是抛出异常<br>看下面的例子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DayOfWeek</span><span class="params">([datetime]<span class="variable">$date</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="variable">$date</span>.DayOfWeek</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DayofWeek <span class="string">&#x27;1927-8-1&#x27;</span></span><br><span class="line">Monday</span><br><span class="line"></span><br><span class="line">DayofWeek <span class="number">2008</span><span class="literal">-8</span><span class="literal">-1</span></span><br><span class="line">Friday</span><br><span class="line"></span><br><span class="line">DayofWeek <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">DayOfWeek : 无法处理对参数“date”的参数转换。无法将值“abc”转换为类型“System.DateTime”。错误:“该字符串未被识别为有效的 DateTime。有一个未知单词(从索引 <span class="number">0</span> 处开始)。”</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">12</span></span><br><span class="line">+  DayofWeek <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">+            ~~~~~</span><br><span class="line">    + CategoryInfo          : InvalidData: (:) [<span class="type">DayOfWeek</span>]，ParameterBindingArgumentTransformationException</span><br><span class="line">    + FullyQualifiedErrorId : ParameterArgumentTransformationError,DayOfWeek</span><br></pre></td></tr></table></figure><h5 id="Switch-参数"><a href="#Switch-参数" class="headerlink" title="Switch 参数"></a>Switch 参数</h5><p><code>Powershell</code> 函数最简单的参数类型为布尔类型，除了使用 <code>Bool</code> 类型，也可以使用 <code>Switch</code> 关键字。<br>下面的函数逆转字符串，但是可以通过 <code>$try</code> 参数进行控制，如果没有指定 <code>$try</code> 的值，默认值为 <code>$false</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>  <span class="title">tryReverse</span><span class="params">( [switch]<span class="variable">$try</span> , [string]<span class="variable">$source</span> )</span> </span></span><br><span class="line"><span class="comment">#此处switch完全可以换成bool</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">string</span>]<span class="variable">$target</span>=<span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$try</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( [<span class="built_in">int</span>]<span class="variable">$i</span> = <span class="variable">$source</span>.length <span class="literal">-1</span>; <span class="variable">$i</span> <span class="operator">-ge</span> <span class="number">0</span> ;<span class="variable">$i</span>--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$target</span> += <span class="variable">$source</span>[<span class="variable">$i</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$target</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$source</span></span><br><span class="line">&#125;</span><br><span class="line">tryReverse <span class="literal">-source</span> www.google.com</span><br><span class="line">tryReverse <span class="literal">-try</span> <span class="variable">$true</span> <span class="literal">-source</span> www.google.com</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">www.google.com</span><br><span class="line">moc.eloog.www</span><br></pre></td></tr></table></figure><h4 id="指定函数的返回值"><a href="#指定函数的返回值" class="headerlink" title="指定函数的返回值"></a>指定函数的返回值</h4><h5 id="一个或多个返回值"><a href="#一个或多个返回值" class="headerlink" title="一个或多个返回值"></a>一个或多个返回值</h5><p><code>PowerShell</code> 不像其它的编程语言，它的函数可以有多个返回值。如果你直接调用函数，返回值会在控制台输出。当然你也可以将结果存储在一个变量中进一步处理<br>下面的例子演示返回一个值：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span><span class="params">([double]<span class="variable">$num</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$num</span>*<span class="variable">$num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在控制台输出结果</span></span><br><span class="line">Square <span class="number">9.87</span></span><br><span class="line"><span class="number">97.4169</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#将结果赋值给变量</span></span><br><span class="line"><span class="variable">$value</span>=Square <span class="number">9.87</span></span><br><span class="line"><span class="variable">$value</span></span><br><span class="line"><span class="number">97.4169</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#返回值为Double类型</span></span><br><span class="line"><span class="variable">$value</span>.GetType().FullName</span><br><span class="line">System.Double</span><br></pre></td></tr></table></figure><p>下面的例子演示返回多个值</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gbMeasure</span><span class="params">(<span class="variable">$amount</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;<span class="variable">$amount</span> GB=<span class="variable">$</span>(<span class="variable">$amount</span>) GB&quot;</span></span><br><span class="line">    <span class="string">&quot;<span class="variable">$amount</span> GB=<span class="variable">$</span>(<span class="variable">$amount</span>*1gb/1mb) MB&quot;</span></span><br><span class="line">    <span class="string">&quot;<span class="variable">$amount</span> GB=<span class="variable">$</span>(<span class="variable">$amount</span>*1gb/1kb) KB&quot;</span></span><br><span class="line">    <span class="string">&quot;<span class="variable">$amount</span> GB=<span class="variable">$</span>(<span class="variable">$amount</span>*1gb) B&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#函数返回4个值</span></span><br><span class="line">gbMeasure <span class="number">1</span></span><br><span class="line"><span class="number">1</span> GB=<span class="number">1</span> GB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1048576</span> KB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1073741824</span> B</span><br><span class="line"> </span><br><span class="line"><span class="comment">#将所有的返回值存储在一个变量中</span></span><br><span class="line"><span class="variable">$result</span>=gbMeasure <span class="number">1</span></span><br><span class="line"><span class="variable">$result</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> GB=<span class="number">1</span> GB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1048576</span> KB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1073741824</span> B</span><br><span class="line"> </span><br><span class="line"><span class="comment">#所有的返回值会自动存储在一个数组中</span></span><br><span class="line"><span class="variable">$result</span>=gbMeasure <span class="number">1</span></span><br><span class="line"><span class="variable">$result</span>.GetType().Name</span><br><span class="line">Object[]</span><br><span class="line"> </span><br><span class="line"><span class="comment">#通过索引访问每个返回值</span></span><br><span class="line"><span class="variable">$result</span>=gbMeasure <span class="number">1</span></span><br><span class="line"><span class="variable">$result</span>[<span class="number">3</span>]</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1073741824</span> B</span><br></pre></td></tr></table></figure><p>总结一下，如果一个函数返回一个值，像其它编程语言一样，这个值包括它的类型信息会直接返回。但是如果遇到多个返回值，PowerShell会将所有的返回值自动构造成一个对象数组。<br>可以通过索引访问数组</p><h5 id="Return语句"><a href="#Return语句" class="headerlink" title="Return语句"></a>Return语句</h5><p><code>Powershell</code> 会将函数中所有的输出作为返回值，但是也可以通过return语句指定具体的返回值。<br>Return 语句会将指定的值返回，同时也会中断函数的执行，<strong>return后面的语句会被忽略</strong></p><p>看一个例子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(<span class="variable">$num</span>)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">&lt;# 1 和 9 作为输出会返回</span></span><br><span class="line"><span class="comment">return语句中的10 也会返回</span></span><br><span class="line"><span class="comment">return 语句后的4和6会被忽略#&gt;</span></span><br></pre></td></tr></table></figure><h5 id="访问返回值"><a href="#访问返回值" class="headerlink" title="访问返回值"></a>访问返回值</h5><p>一个函数返回了一个值还是多个值，是可以验证的。下面的例子会产生随机数，如果没有指定个数，默认会返回一个随机数，否则会返回指定个数的随机数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lottery</span><span class="params">([int]<span class="variable">$number</span>=1)</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$rand</span> = <span class="built_in">New-Object</span> system.random</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span> <span class="operator">-le</span> <span class="variable">$number</span>; <span class="variable">$i</span>++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$rand</span>.next(<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数为空时，返回值不是数组:</span></span><br><span class="line"><span class="variable">$result</span> = lottery</span><br><span class="line"><span class="variable">$result</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定多个随机数时，返回值是数组类型:</span></span><br><span class="line"><span class="variable">$result</span> = lottery <span class="number">10</span></span><br><span class="line"><span class="variable">$result</span> <span class="operator">-is</span> [<span class="built_in">array</span>]</span><br><span class="line">True</span><br><span class="line"><span class="variable">$result</span>.count</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h5 id="从函数的返回值中消除输出"><a href="#从函数的返回值中消除输出" class="headerlink" title="从函数的返回值中消除输出"></a>从函数的返回值中消除输出</h5><p>函数默认会将函数中的所有输出作为函数的返回值返回，这样很方便。但有时可能会将不必要的输出误以为返回值。写脚本程序时，可能需要自定义一些函数，这个函数可能只需要一个返回值，但是为了提高函数的可读性，可能会在函数增加一些注释输出行，或者使用<code>write-host</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;Try to calculate.&quot;</span></span><br><span class="line">    <span class="string">&quot;3.1415926&quot;</span></span><br><span class="line">    <span class="string">&quot;Done.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#保存在变量中输出,</span></span><br><span class="line"><span class="variable">$value</span>=Test</span><br><span class="line"><span class="variable">$value</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="keyword">Try</span> to calculate.</span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line">Done.</span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果要过滤注释，只输出，不作为返回值，</span></span><br><span class="line"><span class="comment">#可以使用Write-Host命令</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Try to calculate.&quot;</span></span><br><span class="line">    <span class="string">&quot;3.1415926&quot;</span></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">&quot;Done.&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在变量值中保存返回值，在控制台输出注释行</span></span><br><span class="line"><span class="variable">$value</span>=Test</span><br><span class="line"><span class="comment">#控制台输出</span></span><br><span class="line"><span class="keyword">Try</span> to calculate.</span><br><span class="line">Done.</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试返回值</span></span><br><span class="line"><span class="variable">$value</span></span><br><span class="line"><span class="number">3.1415926</span></span><br></pre></td></tr></table></figure><p>恭喜你！到此 <code>PowerShell</code> 基础入门算是完成了！<br>之后将介绍 <code>PowerShell</code> 的进阶使用</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="PowerShell-Math类常用函数表"><a href="#PowerShell-Math类常用函数表" class="headerlink" title="PowerShell Math类常用函数表"></a>PowerShell Math类常用函数表</h5><table><thead><tr><th>函数名</th><th>调用写法</th><th>所在类</th><th>重载</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td>sin</td><td>[math]::sin(x)</td><td>System.Math</td><td>1</td><td>返回x弧度的正弦值</td><td>double</td></tr><tr><td>cos</td><td>[math]::cos(x)</td><td>System.Math</td><td>1</td><td>返回x弧度的余弦值</td><td>double</td></tr><tr><td>abs</td><td>[math]::abs(x)</td><td>System.Math</td><td>7</td><td>返回x的绝对值</td><td>所有数值型</td></tr><tr><td>sqrt</td><td>[math]::sqrt(x)</td><td>System.Math</td><td>1</td><td>返回x的平方根</td><td>double</td></tr><tr><td>pow</td><td>[math]::pow(x,n)</td><td>System.Math</td><td>1</td><td>返回x的n次幂</td><td>两参数都是double</td></tr><tr><td>log</td><td>[math]::log(x)</td><td>System.Math</td><td>1</td><td>返回x的自然对数</td><td>double</td></tr><tr><td>log</td><td>[math]::log(x,n)</td><td>System.Math</td><td>1</td><td>返回x的以n为底的对数</td><td>double</td></tr><tr><td>min</td><td>[math]::min(x,y)</td><td>System.Math</td><td>11</td><td>返回x，y中的最小值</td><td>所有数值型</td></tr><tr><td>max</td><td>[math]::max(x,y)</td><td>System.Math</td><td>11</td><td>返回x，y中的最大值</td><td>所有数值型</td></tr><tr><td>floor</td><td>[math]::ceiling(x)</td><td>System.Math</td><td>2</td><td>返回x向下取整的结果</td><td>double、decimal</td></tr><tr><td>ceiling</td><td>[math]::ceiling(x)</td><td>System.Math</td><td>2</td><td>返回x向上取整的结果</td><td>double、decimal</td></tr><tr><td><code>math</code> 类其他函数及详细用法参见微软文档: <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.math?view=netframework-4.7.2#%E6%96%B9%E6%B3%95">Math类</a></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;PowerShell入门指南-三-·一门新的编程语言&quot;&gt;&lt;a href=&quot;#PowerShell入门指南-三-·一门新的编程语言&quot; class=&quot;headerlink&quot; title=&quot;PowerShell入门指南(三)·一门新的编程语言&quot;&gt;&lt;/a&gt;PowerShell入门指南(三)·一门新的编程语言&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;作为独立的编程语言&quot;&gt;&lt;a href=&quot;#作为独立的编程语言&quot; class=&quot;headerlink&quot; title=&quot;作为独立的编程语言&quot;&gt;&lt;/a&gt;作为独立的编程语言&lt;/h4&gt;&lt;p&gt;作为一门独立的语言来说，&lt;code&gt;PowerShell&lt;/code&gt; 是非常地Powerful，我们先来了解一下它的特点:&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"/>
    
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>记一次express后端的搭建</title>
    <link href="https://www.lollipopnougat.top/2019/04/30/%E8%AE%B0%E4%B8%80%E6%AC%A1express%E5%90%8E%E7%AB%AF%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://www.lollipopnougat.top/2019/04/30/%E8%AE%B0%E4%B8%80%E6%AC%A1express%E5%90%8E%E7%AB%AF%E7%9A%84%E6%90%AD%E5%BB%BA/</id>
    <published>2019-04-30T12:21:25.000Z</published>
    <updated>2021-04-26T07:27:24.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>作为网工人怎么能不会搭后端呢？<br>今天就拿 Node.js 下的 Express 搭一个后端</p><span id="more"></span><h3 id="Node-js-是什么东西"><a href="#Node-js-是什么东西" class="headerlink" title="Node.js 是什么东西"></a>Node.js 是什么东西</h3><p>你可能没听说过 <code>Node.js</code>，但是应该听说过 <code>JavaScript</code>，你也应该知道 <code>Chrome</code>(谷歌浏览器) 吧</p><blockquote><ul><li><code>Node.js</code> 是一个基于 <code>Chrome V8</code> 引擎的 <code>JavaScript</code> 运行环境(Runtime，即运行时)。<br></li><li><code>Node.js</code> 使用了一个事件驱动、非阻塞式 <code>I/O</code> 的模型，使其轻量又高效。</li></ul></blockquote><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><code>Node</code> 是一个让 <code>JavaScript</code> 运行在服务端的开发平台，它让 <code>JavaScript</code> 成为与<code>PHP</code>、<code>Python</code>、<code>Perl</code>、<code>Ruby</code> 等服务端语言平起平坐的脚本语言。它发布于 2009 年 5 月，由 Ryan Dahl 开发，实质是对 Chrome V8 引擎进行了封装(底层调用 C/C++的相关库)。<br><br>Node 对一些特殊用例进行优化，提供替代的 API，使得 V8 在非浏览器环境下运行得更好。V8 引擎执行 Javascript 的速度非常快，性能非常好。常用于用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞 I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h3 id="Express-js"><a href="#Express-js" class="headerlink" title="Express.js"></a>Express.js</h3><p>这是一个基于 <code>Node.js</code> 平台，快速、开放、极简的 Web 开发框架，为 Web 和移动应用程序提供一组强大的功能。其实就是一个 node 下很完善的一个后端框架，在众多 js 后端框架中 Express 是做到大而全的。</p><h3 id="为什么选择-Express"><a href="#为什么选择-Express" class="headerlink" title="为什么选择 Express"></a>为什么选择 Express</h3><p>首先是因为<code>node</code> 相比 <code>java</code> 下的 <code>spring</code>，<code>python</code> 下的 <code>django</code> 之类开发效率高。<code>node</code> 平台编程语言还是 <code>js</code>，对于前端也很友好，即使想要面向对象也有 <code>ECMA6</code> 和 <code>Typescript</code> 可选；还有完善的包管理工具 <code>npm</code> 或者 <code>yarn</code>;<br><br>express 框架非常易于使用，即使没有使用经验也能很快上手。而且其大而全的特性也是功能强大的表现，相关需求的插件很多，使用文档和教程也是不计其数，可以说是各种流行后端框架中最高效最轻量的一个了。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>首先假定你已经安装了 <code>Node.js</code>，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp</span><br><span class="line"><span class="built_in">cd</span> myapp</span><br></pre></td></tr></table></figure><p>通过 <code>npm init</code> 命令为你的应用创建一个 <code>package.json</code> 文件。 欲了解 <code>package.json</code> 是如何起作用的，请参考 <a href="https://docs.npmjs.com/files/package.json">Specifics of npm’s package.json handling</a>.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受大部分默认设置即可，下面这个除外：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry point: (index.js)</span><br></pre></td></tr></table></figure><p>键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。<br></p><p>接下来在 myapp 目录下安装 Express 并将其保存到依赖列表中。如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><p>如果只是临时安装 Express，不想将它添加到依赖列表中，可执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --no-save</span><br></pre></td></tr></table></figure><blockquote><p>npm 5.0+ 版本在默认情况下会将安装的模块添加到 <code>package.json</code> 文件中的 <code>dependencies</code> 列表中。对于较老的 npm 版本，你就必须指定 <code>--save</code> 参数。然后，照旧执行 <code>npm install</code> 命令即可自动安装依赖列表中所列出的所有模块。</p></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="最简单的示例"><a href="#最简单的示例" class="headerlink" title="最简单的示例"></a>最简单的示例</h4><h5 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;应用实例，访问地址为 http://%s:%s&#x27;</span>, host, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="甚至可以这样写-ES-6"><a href="#甚至可以这样写-ES-6" class="headerlink" title="甚至可以这样写(ES 6)"></a>甚至可以这样写(ES 6)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript 6 支持了 let, const 关键字、类 class、lambda 表达式、字符串模板(`$&#123;&#125;`)、异步关键字async, await、解构赋值、模块的导入(import)和导出(export default/export)、Promise (异步的同步代码)、set和map的实现等好多特性，有时间我会更一期文章讲这个</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> res.send(<span class="string">&#x27;Hello World!&#x27;</span>));</span><br><span class="line"><span class="comment">// 采用了lambda表达式的写法非常简洁不是吗</span></span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><p>通过 <code>npm 文件名</code> 就可以启动。</p><h4 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h4><p><code>Express</code> 应用使用回调函数的参数： <code>request</code> 和 <code>response</code> 对象来处理请求和响应的数据。<br></p><h5 id="处理-GET-请求示例"><a href="#处理-GET-请求示例" class="headerlink" title="处理 GET 请求示例"></a>处理 GET 请求示例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理访问&#x27;/&#x27;目录的回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设用户访问的是 /?name=string 执行结果就是输出 string</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;您通过query指定的参数是 %s&#x27;</span>, req.query.name)</span><br><span class="line">  <span class="comment">// 返回json响应</span></span><br><span class="line">  res.json(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="处理-POST-请求示例"><a href="#处理-POST-请求示例" class="headerlink" title="处理 POST 请求示例"></a>处理 POST 请求示例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 为了省事，函数我用lambda表达式表示了</span></span><br><span class="line">  <span class="comment">// 假设用户向 &#x27;/&#x27; POST 一个 &#123; name: &#x27;string&#x27; &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;您提交的name字段值是 %s&#x27;</span>, req.body.name) <span class="comment">// 返回结果就是 string</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="使用命令行生成器"><a href="#使用命令行生成器" class="headerlink" title="使用命令行生成器"></a>使用命令行生成器</h4><p>通过应用生成器工具 <code>express-generator</code> 可以快速创建一个应用的基本框架。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要求 node.js 版本在 8.2.0 及以上</span></span><br><span class="line">npx express-generator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果低于 8.2.0 可以使用</span></span><br><span class="line">npm install -g express-generator</span><br><span class="line"><span class="comment"># 安装完成后再执行</span></span><br><span class="line">express</span><br></pre></td></tr></table></figure><p>详细信息请看<a href="https://www.expressjs.com.cn/starter/generator.html">教程</a></p><h4 id="使用路由功能"><a href="#使用路由功能" class="headerlink" title="使用路由功能"></a>使用路由功能</h4><p><a href="https://www.expressjs.com.cn/starter/basic-routing.html">教程</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h3&gt;&lt;p&gt;作为网工人怎么能不会搭后端呢？&lt;br&gt;今天就拿 Node.js 下的 Express 搭一个后端&lt;/p&gt;</summary>
    
    
    
    <category term="后端" scheme="https://www.lollipopnougat.top/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="Nodejs" scheme="https://www.lollipopnougat.top/categories/%E5%90%8E%E7%AB%AF/Nodejs/"/>
    
    
    <category term="网站搭建" scheme="https://www.lollipopnougat.top/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Node.js" scheme="https://www.lollipopnougat.top/tags/Node-js/"/>
    
    <category term="Express" scheme="https://www.lollipopnougat.top/tags/Express/"/>
    
    <category term="后端" scheme="https://www.lollipopnougat.top/tags/%E5%90%8E%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(2)</title>
    <link href="https://www.lollipopnougat.top/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(2)/"/>
    <id>https://www.lollipopnougat.top/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(2)/</id>
    <published>2019-03-29T06:41:14.000Z</published>
    <updated>2021-04-26T07:44:20.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PowerShell入门指南-二-·挑战CMD和Bash的PowerShell"><a href="#PowerShell入门指南-二-·挑战CMD和Bash的PowerShell" class="headerlink" title="PowerShell入门指南(二)·挑战CMD和Bash的PowerShell"></a>PowerShell入门指南(二)·挑战CMD和Bash的PowerShell</h3><h4 id="作为CMD-Bash的代替使用"><a href="#作为CMD-Bash的代替使用" class="headerlink" title="作为CMD/Bash的代替使用"></a>作为CMD/Bash的代替使用</h4><p>如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用</p><span id="more"></span><hr><table><thead><tr><th>PowerShell 命令</th><th>PowerShell 简称</th><th>CMD 命令</th><th>UNIX 命令</th><th>描述</th></tr></thead><tbody><tr><td>Get-ChildItem</td><td>gci,dir,ls</td><td>dir</td><td>ls</td><td>显示当前目录下的所有文件和文件夹</td></tr><tr><td>Test-Connection</td><td>ping</td><td>ping</td><td>ping</td><td>向目标站点发送一个ICMP接受响应，检查网络连通性</td></tr><tr><td>Get-Content</td><td>gc,type,cat</td><td>type</td><td>cat</td><td>获取文件内容</td></tr><tr><td>Get-Command</td><td>gcm</td><td>help</td><td>type, which, compgen</td><td>列出可用的命令</td></tr><tr><td>Get-Help</td><td>help,man</td><td>help</td><td>apropos,man</td><td>在控制台列出命令的使用文档</td></tr><tr><td>Clear-Host</td><td>cls,clear</td><td>cls</td><td>clear</td><td>清除屏幕内容</td></tr><tr><td>Copy-Item</td><td>cpi,copy,cp</td><td>copy,xcopy,robocopy</td><td>cp</td><td>拷贝文件/文件夹到指定位置</td></tr><tr><td>Move-Item</td><td>mi,move,mv</td><td>move</td><td>mv</td><td>移动文件/文件夹到新位置</td></tr><tr><td>Remove-Item</td><td>ri,del,erase,rmdir,rd,rm</td><td>del,erase,rmdir,rd</td><td>rm,rmdir</td><td>删除文件/文件夹</td></tr><tr><td>Rename-Item</td><td>rni,ren,mv</td><td>ren,rename</td><td>mv</td><td>重命名文件/文件夹</td></tr><tr><td>Get-Location</td><td>gl,cd,pwd</td><td>cd</td><td>pwd</td><td>显示当前工作目录</td></tr><tr><td>Pop-Location</td><td>popd</td><td>popd</td><td>popd</td><td>将工作路径更改为最近压入堆栈的位置</td></tr><tr><td>Push-Location</td><td>pushd</td><td>pushd</td><td>pushd</td><td>将工作路径存储到堆栈上</td></tr><tr><td>Set-Location</td><td>sl,cd,chdir</td><td>cd,chdir</td><td>cd</td><td>更改当前工作目录</td></tr><tr><td>Tee-Object</td><td>tee</td><td>不支持</td><td>tee</td><td>将输入通过管道传递到文件或变量</td></tr><tr><td>Write-Output</td><td>echo,write</td><td>echo</td><td>echo</td><td>将字符或其他对象输出到标准输出流上</td></tr><tr><td>Get-Process</td><td>gps,ps</td><td>tlist,tasklist</td><td>ps</td><td>列出当前全部进程</td></tr><tr><td>Stop-Process</td><td>spps,kill</td><td>kill,taskkill</td><td>kill</td><td>终止指定进程</td></tr><tr><td>Select-String</td><td>sls</td><td>findstr</td><td>find,grep</td><td>打印匹配的字符行</td></tr><tr><td>Set-Variable</td><td>sv,set</td><td>set</td><td>env,export,set,setenv</td><td>创建或更改环境变量的内容</td></tr><tr><td>Invoke-WebRequest</td><td>iwr,<del>curl,wget</del>[^1]</td><td>不支持</td><td>wget,curl</td><td>从Internet上的网页获取内容</td></tr></tbody></table><hr><p>[^1]:curl和wget不在PowerShell Core中，因此不会干扰调用非Windows操作系统的同名组件。</p><hr><h3 id="功能键和快捷键"><a href="#功能键和快捷键" class="headerlink" title="功能键和快捷键"></a>功能键和快捷键</h3><h4 id="先来了解一下功能键和快捷键"><a href="#先来了解一下功能键和快捷键" class="headerlink" title="先来了解一下功能键和快捷键"></a>先来了解一下功能键和快捷键</h4><ul><li><kbd>ALT</kbd>+<kbd>F7</kbd>    清除命令的历史记录</li><li><kbd>PgUp</kbd> <kbd>PgDn</kbd>    显示当前会话的第一个命令和最后一个命令</li><li><kbd>Enter</kbd>    执行当前命令</li><li><kbd>End</kbd>    将光标移至当前命令的末尾</li><li><kbd>Del</kbd>    从右开始删除输入的命令字符</li><li><kbd>Esc</kbd>    清空当前命令行</li><li><kbd>F2</kbd>    自动补充历史命令至指定字符<br>(例如历史记录中存在Get-Process，按<kbd>F2</kbd>，提示”Enter char to copy up to”，键入 <kbd>S</kbd>，自动补齐命令:Get-Proce)</li><li><kbd>F4</kbd>    删除命令行至光标右边指定字符处</li><li><kbd>F7</kbd>    对话框显示命令行历史记录</li><li><kbd>F8</kbd>    检索包含指定字符的命令行历史记录</li><li><kbd>F9</kbd>    根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看</li><li><kbd>←</kbd>/<kbd>→</kbd>    左右移动光标</li><li><kbd>↑</kbd>/<kbd>↓</kbd>    切换命令行的历史记录</li><li><kbd>Home</kbd>    光标移至命令行最左端</li><li><kbd>Backspace</kbd>    从右删除命令行字符</li><li><kbd>Ctrl</kbd>+<kbd>C</kbd>    取消正在执行的命令</li><li><kbd>Ctrl</kbd>+<kbd>←</kbd>/<kbd>→</kbd>    在单词之间移动光标</li><li><kbd>Ctrl</kbd>+<kbd>Home</kbd>    删除光标最左端的所有字符</li><li><kbd>Tab</kbd>    自动补齐命令或者文件名</li></ul><h3 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h3><p>我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">0</span>xABCD</span><br><span class="line"><span class="number">43981</span></span><br><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">3.14</span>*<span class="number">10</span>*<span class="number">10</span></span><br><span class="line"><span class="number">314</span></span><br><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">1</span>+<span class="number">3</span>-(<span class="number">2.4</span><span class="literal">-5</span>)*(<span class="number">7.899</span><span class="literal">-4</span>.<span class="number">444</span>)</span><br><span class="line"><span class="number">12.983</span></span><br></pre></td></tr></table></figure><p>PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">1</span>pb/<span class="number">1</span>tb</span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">1</span>tb/<span class="number">1</span>gb</span><br><span class="line"><span class="number">1024</span></span><br><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">1</span>gb/<span class="number">1</span>kb</span><br><span class="line"><span class="number">1048576</span></span><br><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">1</span>gb/<span class="number">20</span>mb*<span class="number">10</span>kb</span><br><span class="line"><span class="number">524288</span></span><br></pre></td></tr></table></figure><p>假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:/pstest&gt; <span class="number">10</span>GB/(<span class="number">80</span>KB*<span class="number">5</span>)/<span class="number">30</span></span><br><span class="line"><span class="number">873.813333333333</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;PowerShell入门指南-二-·挑战CMD和Bash的PowerShell&quot;&gt;&lt;a href=&quot;#PowerShell入门指南-二-·挑战CMD和Bash的PowerShell&quot; class=&quot;headerlink&quot; title=&quot;PowerShell入门指南(二)·挑战CMD和Bash的PowerShell&quot;&gt;&lt;/a&gt;PowerShell入门指南(二)·挑战CMD和Bash的PowerShell&lt;/h3&gt;&lt;h4 id=&quot;作为CMD-Bash的代替使用&quot;&gt;&lt;a href=&quot;#作为CMD-Bash的代替使用&quot; class=&quot;headerlink&quot; title=&quot;作为CMD/Bash的代替使用&quot;&gt;&lt;/a&gt;作为CMD/Bash的代替使用&lt;/h4&gt;&lt;p&gt;如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"/>
    
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(1)</title>
    <link href="https://www.lollipopnougat.top/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%971/"/>
    <id>https://www.lollipopnougat.top/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%971/</id>
    <published>2019-03-29T06:32:58.000Z</published>
    <updated>2021-04-26T07:37:53.576Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Powershell入门指南-一-·PowerShell及CLI发展"><a href="#Powershell入门指南-一-·PowerShell及CLI发展" class="headerlink" title="Powershell入门指南(一)·PowerShell及CLI发展"></a>Powershell入门指南(一)·PowerShell及CLI发展</h3><p>不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。</p><span id="more"></span><hr><p>也许你也曾经打开过它，但是不知道它有什么用;<br>或者你了解一些CMD命令，但是你发现在这个PowerShell里面有些命令好像不能执行了。<br>而且这个PowerShell相比CMD启动也不算快，<strong>微软为什么要拿这个替换CMD呢</strong>？<br>这要从早期的Windows的命令行背景说起：</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>用于个人计算机的每个Windows版本都包含一个用于管理操作系统的命令行解释程序(CLI)；Windows系统的前身，即MS-DOS，完全依赖CLI支持。在MS-DOS和Windows9x系列系统里面提供CLI功能的程序是<code>COMMAND.COM</code>，在Windows NT以及之后的各种系统是<code>CMD.exe</code>提供CLI支持的。这两者都支持一些内部命令。<br>它们还包括基本的脚本语言(batch file)支持，这些脚本可以完成多种自动化工作，但是对于用户交互界面(GUI)的自动化工作，它们就完全无能为力了。这是因为对GUI这些操作对应脚本的等价操作来说是受限的，毕竟这是最基本的脚本环境，支持的功能不全。到了Windows Sever 2003发布的时候，这一情况有所改善，但是仍令人不满意。</p><p>其实Microsoft在1998年就试图通过对Windows 98引入Windows脚本宿主(WSH)来解决其中一些缺点，这个程序在系统中名叫<code>cscript.exe</code>，它集成了Active script[^1]脚本引擎，可以使用兼容的<code>VBscript</code>和<code>JScript</code>来编写，调用其他应用程序的API或者COM。然而，它有其自身的不足之处：<br>的文档不是很容易获得，并且在几个有名的计算机病毒利用其安全协议中的弱点之后，迅速获得了作为脆弱的系统漏洞荣誉(大雾)。不同版本的Windows提供了各种专用命令行解释器（例如netsh和WMIC）及其只适用自己的命令，但它们之间不可互操作。</p><hr><h4 id="开发人员的设想"><a href="#开发人员的设想" class="headerlink" title="开发人员的设想"></a>开发人员的设想</h4><p>在9月13日发表的一次采访中，Jeffrey Snover(PowerShell之父)解释了开发该项目的动机:</p><blockquote><p>“我一直推动管理的变更，然后我开始把一些UNIX工具适配到Windows平台，结果它们却不能工作，对吧？因为Windows 和Linux的核心架构有很大区别。在Linux上，一切都是ASCII文本文件，因此所有支持这种文件的软件都可以作为管理软件。想想看，使用AWK(文本处理工具)、grep(文本搜索工具)、sed(类似于AWK)管理你的系统是多么美好的事请！<br>我把这些工具移植到Windows，结果它们对于系统的管理没有任何作用，因为所有的API返回的都是结构化的数据，因此那些UNIX软件没什么帮助。<br>……<br>我突然有了就是现在powershell这样子的想法，告诉别人说：‘嘿！没准我们可以把这个做得更好！’”</p></blockquote><hr><h3 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h3><ul><li><p>2002年，微软开始开发一种新的命令行管理方法，名为Monad（也称为Microsoft Shell或MSH）的CLI。其背后的想法于2002年8月发表在一份名为Monad Manifesto的白皮书中。Monad将成为一个新的可扩展CLI，其设计新颖，能够自动执行各种核心管理任务。</p></li><li><p>微软于2003年10月在洛杉矶举行的专业发展大会上首次展示Monad。几个月后开始私人测试计划，最终推出公共测试计划。</p></li><li><p>Microsoft 于2005年6月17日发布了第一个Monad公共测试版，</p></li><li><p>2005年9月11日发布了Beta 2</p></li><li><p>2006年1月10日发布了Beta 3。</p></li><li><p>不久之后，2006年4月25日，Microsoft正式宣布Monad已重命名为Windows PowerShell，将其定位为其管理技术产品的重要组成部分。 名称更改和RC的一个重要方面是，它现在是Windows的一个组件，而不是附加产品。</p></li><li><p>PowerShell版本1的候选版本2于2006年9月26日发布，最终发布于2006年11月14日，并在TechEd Barcelona上发布。</p></li><li><p>早期版本的Windows PowerShell于2007年1月30日发布。</p></li><li><p>PowerShell v2.0开发在PowerShell v1.0发布之前就开始了。在开发过程中，Microsoft发布了三个社区技术预览（CTP）。Microsoft向公众提供了这些版本。</p></li><li><p>Windows PowerShell v2.0的最后一个CTP版本于2008年12月推出。</p></li><li><p>适用于Ubuntu 14.04 x64 上的Linux 6.0 Alpha 9的PowerShell</p></li><li><p>PowerShell v2.0已于2009年8月完成并发布，作为Windows 7和Windows Server 2008 R2的组成部分。适用于Windows XP，Windows Server 2003，Windows Vista和Windows Server 2008的PowerShell版本于2009年10月发布，可供32位和64位平台下载。</p></li><li><p>Windows 10提供了PowerShell的测试框架</p></li><li><p>2016年8月18日，微软宣布他们开发了PowerShell开源和跨平台，支持Windows，macOS，CentOS和Ubuntu。源代码发布在GitHub上。转向开源创建了PowerShell的第二个版本，称为“PowerShell Core”，它运行在 .NET Core上。它与“Windows PowerShell”不同，后者在完整的 .NET Framework上运行。</p></li><li><p>从版本5.1开始，PowerShell Core与Windows Server 2016 Nano Server捆绑在一起</p></li></ul><hr><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>PowerShell是Microsoft的<strong>任务自动化和配置管理框架</strong>，由命令行shell和相关的脚本语言组成。最初只是一个Windows组件，称为Windows PowerShell，它于2016年8月18日通过PowerShell Core的推出而成为开源和跨平台。前者构建于 .NET Framework上，后者构建于 .NET Core上。</p><p>在PowerShell中，管理任务通常由<code>cmdlet</code>（发音为command-lets）执行，<strong>cmdlet是实现特定操作的专用 .NET 类</strong>。这些工作通过访问不同数据存储中的数据（如文件系统或注册表），这些数据存储通过提供程序提供给PowerShell 。第三方开发人员可以向PowerShell添加cmdlet和提供程序。自定义的脚本可以使用Cmdlet ，还可以打包成模块作为新的Cmdlet使用。</p><p>PowerShell提供对COM和WMI的完全访问，使管理员能够在本地和远程Windows系统以及WS-Management和CIM上执行管理任务，从而实现远程对Linux系统和网络设备的管理。PowerShell还提供了一个托管API，PowerShell运行时可以使用该API嵌入到其他应用程序中。然后，这些应用程序可以使用PowerShell功能来实现某些操作，包括通过图形界面公开的操作。Microsoft Exchange Server 2007 使用此功能将其管理功能公开为PowerShell指令和提供程序并实现作为PowerShell主机的图形管理工具，可通过调用必要的cmdlet来使用Exchange Sever 2007。其他Microsoft应用程序（包括Microsoft SQL Server 2008）也通过PowerShell cmdlet公开其管理界面。</p><p>PowerShell含有广泛的，基于控制台的自身帮助（类似于手册页在Unix外壳）通过键入<code>Get-Help</code>命令即可轻松获取使用方法。你可以通过<code>Update-Help</code> cmdlet 从Internet升级本地帮助内容，还能通过<code>Get-Help &lt;命令名&gt; -online</code>获取来自网络的帮助。</p><hr><blockquote><p>以上内容来自<a href="https://en.wikipedia.org/wiki/PowerShell#Background">PowerShell - Wikipedia</a>，背景和开发人员设想部分为笔者翻译(翻译如有问题欢迎指出)，开发历程和简介由Google提供翻译服务，笔者进行了校对。</p></blockquote><hr><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><blockquote><p>了解更多请参考： <a href="https://en.wikipedia.org/w/index.php?title=PowerShell#Versions">PowerShell - Wikipedia</a></p></blockquote><p>最初使用代号“Monad”，PowerShell于2003年9月首次在专业开发者大会上公开展示。所有主要版本仍然受支持，并且每个主要版本都具有与先前版本的向后兼容性。</p><ul><li><p>PowerShell 1.0</p><p>PowerShell 1.0于2006年11月发布，适用于Windows XP SP2，Windows Server 2003 SP1和Windows Vista。它还是Windows Server 2008的可选组件。</p></li><li><p>PowerShell 2.0</p><p>PowerShell 2.0与Windows 7和Windows Server 2008 R2集成，适用于Windows XP Service Pack 3，Windows Server 2003 Service Pack 2和Windows Vista Service Pack 1. </p><p>PowerShell v2除了包含240多个新cmdlet之外，还包括对脚本语言和托管API的更改。</p></li><li><p>PowerShell 3.0</p><p>PowerShell 3.0与Windows 8和Windows Server 2012集成在一起。Microsoft还为Windows 7 Service Pack 1，Windows Server 2008 Service Pack 1和Windows Server 2008 R2 Service Pack 1 提供了PowerShell 3.0 。</p><p>PowerShell 3.0是更大的软件包Windows Management Framework 3.0（WMF3）的一部分，它还包含支持远程处理的WinRM服务。Windows Management Framework 3.0的早期社区技术预览2（CTP 2）版本于2011年12月2日发布。 Windows Management Framework 3.0于2012年12月发布，并默认包含在Windows 8和Windows Server 2012中。</p></li><li><p>PowerShell 4.0</p><p>PowerShell 4.0与Windows 8.1和Windows Server 2012 R2集成在一起。Microsoft还为Windows 7 SP1，Windows Server 2008 R2 SP1和Windows Server 2012提供了PowerShell 4.0。</p></li><li><p>PowerShell 5.0</p><p>包含PowerShell 5.0的Windows Management Framework（WMF）5.0 RTM于2016年2月24日在发布严重错误的初始版本后重新发布到Web。主要功能包括OneGet PowerShell cmdlet，支持Chocolatey基于存储库的包管理，并将对交换机管理的支持扩展到第2层网络交换机。</p></li><li><p>PowerShell 5.1</p><p>它与2016年8月2日的Windows 10 周年更新以及Windows Server 2016一起发布。PackageManagement现在支持代理，PSReadLine现在支持ViMode，并添加了两个新的cmdlet：Get-TimeZone和Set-TimeZone。LocalAccounts模块允许添加/删除本地用户帐户。 PowerShell 5.1的预览版已于2016年7月16日针对Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Server 2012和Windows Server 2012 R2 发布，并于2017年1月19日发布正式版。</p><p>PowerShell 5.1是第一个有两个版本的PowerShell，包括“桌面”和“核心”版本。“桌面”版本是在完整的 .NET Framework堆栈上运行的传统Windows PowerShell的延续。“Core”版本在 .NET Core上运行，并与Windows Server 2016 Nano Server捆绑在一起。为了减少占用空间，后者缺少一些功能，例如用于管理剪贴板的cmdlet或将计算机加入域，WMI版本1 cmdlet，事件日志cmdlet和配置文件。这是专为Windows制作的PowerShell的最终版本。</p></li><li><p>PowerShell 6.0</p><p>PowerShell Core 6.0于2016年8月18日首次发布，当时微软公布了PowerShell Core并决定使该产品跨平台，独立于Windows，而且是免费和开源的。</p><p>它于2018年1月10日实现了Windows，macOS和Linux的普遍可用性。它有自己的支持生命周期，并遵循Windows 10引入的Microsoft生命周期策略：仅支持最新版本的PowerShell Core。微软希望每六个月为PowerShell Core 6.0发布一个次要版本。</p><p>此版本PowerShell中最重要的变化是扩展到其他平台。对于Windows管理员，此版本的PowerShell没有任何主要的新功能。在2018年1月11日的社区访谈中，PowerShell团队被要求列出将从Windows PowerShell 5.1迁移到PowerShell Core 6.0的Windows IT专业人员可能发生的十大最令人兴奋的事情。作为回应，微软的Angel Calvo只能说出两个：跨平台和开源(这两个就足够了)。</p></li><li><p>PowerShell 7.0</p><p>PowerShell 7.0 GA 正式发布了。 除了常见的新 cmdlet/API 和错误修复之外，PowerShell 7.0 还引入了许多新功能，主要包括： </p><ul><li>使用 <code>ForEach-Object -Parallel</code> 进行管道并行化</li><li>新的运算符</li><li>三元运算符： <code>a ? b : c</code></li><li>Pipeline 主运算符：<code>||</code> 和 <code>&amp;&amp;</code> </li><li>空分配和合并运算符 ：<code>??</code> 和 <code>??=</code></li><li>简化的动态错误视图和 <code>Get-Error cmdlet</code>，可更轻松地调查错误</li><li>兼容性层，使用户能够在隐式 Windows PowerShell 会话中导入模块</li><li>自动化新版本通知</li><li>直接从 PowerShell 7 调用以调用 DSC 资源的能力（实验性）</li><li>从 PowerShell Core 6.x 到 7.0 的转变也标志着从 .NET Core 2.x 到 3.1 的转变。.NET Core 3.1 带来了许多 .NET Framework API（特别是在 Windows 上），从而使与现有 Windows PowerShell 模块的向后兼容性大大提高。这包括 Windows 上需要 GUI 功能的许多模块，例如 <code>Out-GridView</code> 和 <code>Show-Command</code>，以及 Windows 附带的许多角色管理模块。更多信息可查看 PowerShell 7.0 的模块兼容性表。</li></ul><p>官方表示，PowerShell 7 标志着与 Windows PowerShell 的向后兼容性最大化的旅程已完成，“PowerShell 7 及其以后的版本将是真正的 PowerShell ”。</p></li></ul><h5 id="目前Windows-10-上自带的版本是5-1"><a href="#目前Windows-10-上自带的版本是5-1" class="headerlink" title="目前Windows 10 上自带的版本是5.1"></a>目前Windows 10 上自带的版本是5.1</h5><p>[^1]:一种可以采用各种语言以及固定格式等实现、并能与其他 ActiveX 控件(可以理解为一种互联网插件)交互的脚本</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Powershell入门指南-一-·PowerShell及CLI发展&quot;&gt;&lt;a href=&quot;#Powershell入门指南-一-·PowerShell及CLI发展&quot; class=&quot;headerlink&quot; title=&quot;Powershell入门指南(一)·PowerShell及CLI发展&quot;&gt;&lt;/a&gt;Powershell入门指南(一)·PowerShell及CLI发展&lt;/h3&gt;&lt;p&gt;不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。&lt;/p&gt;</summary>
    
    
    
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>春节快乐</title>
    <link href="https://www.lollipopnougat.top/2019/02/04/%E6%98%A5%E8%8A%82%E5%BF%AB%E4%B9%90/"/>
    <id>https://www.lollipopnougat.top/2019/02/04/%E6%98%A5%E8%8A%82%E5%BF%AB%E4%B9%90/</id>
    <published>2019-02-04T12:38:56.000Z</published>
    <updated>2021-04-26T07:26:36.643Z</updated>
    
    <content type="html"><![CDATA[<h3 id="春节快乐"><a href="#春节快乐" class="headerlink" title="春节快乐"></a>春节快乐</h3><p>祝各位春节快乐,新的一年大家也要继续努力鸭!<br>笔者还准备了礼物送给大家，点击下面的阅读全文查看</p><span id="more"></span><h3 id="献上笔者绘制的Peppa-Pig-社会猪佩奇"><a href="#献上笔者绘制的Peppa-Pig-社会猪佩奇" class="headerlink" title="献上笔者绘制的Peppa Pig(社会猪佩奇)"></a>献上笔者绘制的Peppa Pig(社会猪佩奇)</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/SpF.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/SpF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Happy New Year!"></p><h3 id="送上猪年祝福语"><a href="#送上猪年祝福语" class="headerlink" title="送上猪年祝福语"></a>送上猪年祝福语</h3><ul><li>春风初度到猪年，欢歌声声震云天。千家万户乐翩翩，迎福纳财笑开颜。我有祝福在心田，悄悄送到你身边。愿你猪年爱情甜，合家快乐福无边。</li><li>朝霞映满天，盛世耀猪年。歌美舞翩翩，快乐太平年。瑞雪一片片，幸福绕猪年。春风暖心田，欢度团圆年。猪年到了，愿你快乐绵绵！</li><li>猪年好，猪年妙，猪年的歌声满天飘；猪年灿，猪年暖，猪年的幸福享不完；猪年旺，猪年香，猪年的祝福分外长。愿你猪年心飞扬，万事皆顺畅！</li><li>除夕到来菩萨忙，各路神仙送吉祥：财神送你金元宝，寿星保你身安康，文殊给你大智慧，观音佑你幸福长，弥勒让你乐不断，福星伴你走四方！春节快乐！</li><li>春风叩开猪年的门扉，对联贴满猪年的庭院，欢畅陶醉猪年的日子，幸福温暖猪年的时光，情意铺满猪年的道路。猪年到了，愿你的生活灿烂美满。</li><li>猪年就要到了，新春祝福提前到。祝你有人缘，事业顺利不心烦；祝你有情缘，爱情甜蜜心也甜；祝你有财源，腰包鼓鼓金钱花不完。最后祝你猪年大吉！</li><li>一张圆桌，合家团座笑呵呵；一顿晚餐，美味家肴喜庆多；一杯美酒，装满幸福和快乐；一个除夕，张灯结彩好喜气；一条祝福，愿你多财又多福；新年到，愿你全家幸福乐逍遥！</li><li>春节到处乐洋洋，祝福语先到身旁，心意情意都献上，愿您接纳永收藏，愿您事业财源广，愿您暖和体安康，愿您烦恼忧愁散，愿您春节安康！</li></ul><h4 id="绘制佩奇使用的是PS的钢笔"><a href="#绘制佩奇使用的是PS的钢笔" class="headerlink" title="绘制佩奇使用的是PS的钢笔"></a>绘制佩奇使用的是PS的钢笔</h4><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/PeppaPig1.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/PeppaPig1.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Happy New Year!"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;春节快乐&quot;&gt;&lt;a href=&quot;#春节快乐&quot; class=&quot;headerlink&quot; title=&quot;春节快乐&quot;&gt;&lt;/a&gt;春节快乐&lt;/h3&gt;&lt;p&gt;祝各位春节快乐,新的一年大家也要继续努力鸭!&lt;br&gt;笔者还准备了礼物送给大家，点击下面的阅读全文查看&lt;/p&gt;</summary>
    
    
    
    <category term="节日祝福" scheme="https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
    <category term="春节" scheme="https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/%E6%98%A5%E8%8A%82/"/>
    
    
    <category term="节日祝福" scheme="https://www.lollipopnougat.top/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
    <category term="春节" scheme="https://www.lollipopnougat.top/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>HTML (一)</title>
    <link href="https://www.lollipopnougat.top/2019/01/25/HTML%20(%E4%B8%80)/"/>
    <id>https://www.lollipopnougat.top/2019/01/25/HTML%20(%E4%B8%80)/</id>
    <published>2019-01-25T13:36:08.000Z</published>
    <updated>2021-04-25T15:24:25.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML 指超文本标记语言</p><blockquote><p>HTML 是通向 WEB 技术世界的钥匙。</p></blockquote><span id="more"></span><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTML是现在世界通用的超文本标记语言，通过它，可以实现图片、链接、音乐以及程序等等多种元素。<br>现如今，HTML已经是程序员必须掌握的一项基本功。</p><h2 id="HTML发展史"><a href="#HTML发展史" class="headerlink" title="HTML发展史"></a>HTML发展史</h2><p>HTML没有1.0，因为关于它的初版存在争议，1995年HTML 2.0面世，<br>1997年由国际官方组织W3C推出了HTML 3.2以及HTML 4.0标准，<br>后面W3C(万维网联盟)也渐渐变成Web技术领域的权威，经过漫长的演变，2014年，HTML 5标准最终面世。</p><blockquote><p>*HTML 2.0——1995年11月，RFC 1866发布<br>*HTML 3.2——1997年1月14日，W3C发布推荐标准<br>*HTML 4.0——1997年12月18日，W3C发布推荐标准<br>*HTML 4.01——1999年12月24日，W3C发布推荐标准<br>*HTML 5——2014年10月28日，W3C发布推荐标准</p></blockquote><h2 id="HTML5编辑规范"><a href="#HTML5编辑规范" class="headerlink" title="HTML5编辑规范"></a>HTML5编辑规范</h2><ol><li>文件拓展名默认使用htm或者html，便于操作系统或者程序辨认文件，而图片则基本上存为gif或jpg</li><li>浏览器默认忽视回车符，不过为了方便阅览，人们还是会习惯地在写完一段代码后进行回车</li><li>标记符号用尖括号括起来，带斜杠的元素表示该标记说明结束，大多数标记符必须成对使用，用以说明起始和结束。</li><li>必须使用半角而不是全角字符</li><li>HTML注释<code>&lt;!--注释内容--&gt;</code>的内容不给予显示。</li></ol><h2 id="这是笔者写的较为详细的一个入门页面"><a href="#这是笔者写的较为详细的一个入门页面" class="headerlink" title="这是笔者写的较为详细的一个入门页面"></a>这是笔者写的较为详细的一个入门页面</h2><p><a href="https://lollipopnougat.github.io/website-calculator/html/HTML1.html">HTML入门·一</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h3&gt;&lt;p&gt;HTML 指超文本标记语言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML 是通向 WEB 技术世界的钥匙。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="前端" scheme="https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="HTML" scheme="https://www.lollipopnougat.top/categories/%E5%89%8D%E7%AB%AF/HTML/"/>
    
    
    <category term="HTML" scheme="https://www.lollipopnougat.top/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell (一)</title>
    <link href="https://www.lollipopnougat.top/2019/01/17/PowerShell%20(%E4%B8%80)/"/>
    <id>https://www.lollipopnougat.top/2019/01/17/PowerShell%20(%E4%B8%80)/</id>
    <published>2019-01-17T11:48:41.000Z</published>
    <updated>2021-04-25T09:03:23.906Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>PowerShell 是一种命令行外壳程序和脚本环境，<br>使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，<br>PowerShell需要.NET环境的支持，借助 <strong>.NET Framework</strong>平台强大的类库，几乎让一切都成为可能。<br>微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。</p><h2 id="受众"><a href="#受众" class="headerlink" title="受众"></a>受众</h2><p>Windows PowerShell 入门主要面向IT 专业人员、程序员和高级用户。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>通过解决长期存在的问题并添加一些新的功能，Windows PowerShell 旨在改进命令行和脚本环境。<br>PowerShell以 <strong>.NET Framework</strong>为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。<br>PowerShell推出了一个功能强大的命令叫做<code>cmdlet</code>,所有的cmdlet命令都遵循动词-名词这样语法结构。<br>如<code>Get-Command</code>, <code>Get-Process</code>等，<br>即使从来没有接触过PowerShell，也很容易能够明白命令的作用。<br>如<code>Get-Process</code>命令的意思就是获取所有的进程。</p><h2 id="新的脚本语言"><a href="#新的脚本语言" class="headerlink" title="新的脚本语言"></a>新的脚本语言</h2><p>由于以下原因，Windows PowerShell 使用它自己的语言，而不是重用现有的语言：<br>Windows PowerShell 需要用于管理.NET 对象的语言。该语言需要为使用cmdlet 提供一致的环境。<br>该语言需要支持复杂的任务，而不会使简单的任务变得更复杂。 该语言需要与在.NET编程中使用的高级语言（如C#）一致。</p><ol><li><p>PS1文件<br>一个PowerShell脚本其实就是一个简单的文本文件，这个文件包含了一系列PowerShell命令，<br>每个命令显示为独立的一行，对于被视为PowerShell脚本的文本文件，它的文件名需要使用.PS1扩展。</p></li><li><p>执行权限<br>为防止恶意脚本的执行，PowerShell有一个执行策略，默认情况下，这个执行策略被设为受限的（<code>Restricted</code>），<br>意味着PowerShell脚本无法执行，你可以使用下面的cmdlet命令确定当前的执行策略：</p><blockquote><ul><li><code>Get-ExecutionPolicy </code>你可以选择使用的执行策略有：</li><li><code>Restricted</code> -脚本不能运行。 </li><li><code>RemoteSigned</code> - 本地创建的脚本可以运行，但网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）。 </li><li><code>AllSigned</code> – 仅当脚本由受信任的发布者签名才能运行。 </li><li><code>Unrestricted</code> –脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</li></ul></blockquote></li></ol><p>你可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>运行脚本<br>如果你想从命令行运行一个可执行文件，多年来一个永恒不变的方法是，<br>在命令行转到该执行文件所在的位置，然后键入该执行文件的名称，<br>但这个古老的方法现在却不能适用于PowerShell可执行脚本了。<br>如果你想执行一个PowerShell脚本，通常必须键入完整的路径和文件名，<br>例如，假设你要运行一个名为a.ps1的脚本，你可以键入：<br><code>C:\Scripts\aps1</code><br>最大的例外是，如果PowerShell脚本文件刚好位于你的系统目录中，<br>那么你可以直接在命令提示符后键入脚本文件名即可运行，如：<br><code>.\a.ps1</code> 注意前面需要加上<code>.\</code>，这和Linux下执行Shell脚本的方法如出一辙。</p></li><li><p>管道<br>管道的作用是将一个命令的输出作为另一个命令的输入，两个命令（或cmdlet）之间只需要用管道符号（<code>|</code>）连接即可。<br>为了帮助你了解管道是如何工作的，我们以一个例子进行说明，假设你想创建运行在服务器上的进程列表，并按进程的ID号进行排序，<br>可以使用<code>Get-Process</code> cmdlet命令获得进程列表，但默认情况下列表不会排序，<br>如果将这个cmdlet命令的输出用管道输送给<code>Sort-Object ID</code>命令，进程列表将会按进程ID号进行排序，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> ID</span><br></pre></td></tr></table></figure></li><li><p>变量<br>虽然可以使用管道将一个命令的输出输送给另一个命令，<br>但管道本身也是有限制的，当你用管道从一个命令向另一个命令传递输出结果时，输出结果立即被使用，<br>但有时候，你可能需要保存输出结果一段时间，以便以后可以使用（或重用），这个时候管道就应该下场，轮到变量上场了。<br>人们很容易将变量想象成一个仓库，但在PowerShell中，变量可以保存命令的完整输出，<br>例如，假设你想保存服务器处于运行中的进程列表，你可以将它赋给一个变量，如：<br><code>$a = Get-Process</code><br>在这里，变量被命名为$a，如果你想使用这个变量，只需要简单地调用它的名称即可，<br>例如，键入$a便可在屏幕上打印变量的内容。<br>你可以将多个用管道连接的命令的最终输出赋给一个变量，只需要用一对小括号将命令括起来即可，<br>例如，假设你想按进程ID对运行中的进程进行排序，然后将结果输出给一个变量，你可以使用下面这个命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = (<span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> ID)</span><br></pre></td></tr></table></figure></li><li><p>@符号<br>通过使用@符号，你可以将列表内容转换成一个数组，<br>例如，下面的代码创建了一个名为$Procs的变量，它包含多行文本内容（一个数组）：<br><code>$procs = @&#123;name=&quot;explorer&quot;,&quot;svchost&quot;&#125;</code><br>使用变量时你也可以使用@符号，为了确保它作为数组而不是单个值处理，<br>例如，下面的代码将在我前面定义的变量上运行<code>Get-Process</code> cmdlet命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> @procsWindows</span><br></pre></td></tr></table></figure><p>将显示Windows资源管理器和Svchost使用的所有进程，注意变量前使用的<code>@</code>符号，而不是常见的<code>$</code>符号。</p></li><li><p>Split<br>Split操作符根据你指定的字符拆分一个文本字符串，例如，假设你想将一个句子拆分成一个单词组成的一个数组，你可以使用下面的命令做到：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is a test&quot;</span> <span class="operator">-split</span> <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><p>拆分后的结果如下：<br><code>This is a test</code></p></li><li><p>Join<br>就像Split可以将一个文本字符串拆分成多块一样，Join的操作则是逆向的，将多个独立的块连接成一个整体，<br>例如，下面这行代码将会创建一个文本字符串，由我的名字和姓氏组成：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Brien&quot;</span>,<span class="string">&quot;Posey&quot;</span> <span class="operator">-join</span> <span class="string">&quot; &quot;</span></span><br></pre></td></tr></table></figure><p>命令末尾双引号之间的空格告诉Windows在两个文本字符串之间插入一个空格。</p></li><li><p>断点<br>运行一个新创建的PowerShell脚本时，如果脚本有Bug，会遇到意想不到的后果，<br>保护自己的一个方法是在脚本的关键位置插入断点，这样你就可以确保脚本正常运行先，然后再处理可能存在的问题。<br>插入断点最简单的方法是根据行号插入，例如，假设你要在第10行插入一个断点，可以使用下面的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">New-PSBreakpoint</span> <span class="literal">-Script</span> C:\Scripts\a.ps1 <span class="literal">-Line</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#你也可以将断点绑定到变量上，如果你希望你的脚本任何时候都可以修改a$的内容，可以使用下面的命令：</span></span><br><span class="line"><span class="built_in">New-PSBreakpoint</span> <span class="literal">-Script</span> C:\scripts\a.ps1 <span class="literal">-variables</span> a </span><br><span class="line"><span class="comment">#注意，在变量名后并没有包括美元符号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以和`PSBreakpoint`一起使用的动词包括`New`，`Get`，`Enable`，`Disable`和`Remove`。</span></span><br></pre></td></tr></table></figure></li></ol><ol start="10"><li>Step<br>调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用<code>Step-Into</code> cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用<code>Step-Out</code> cmdlet命令即可，<br>但需要注意的是，使用<code>Step-Out</code> cmdlet命令后，断点仍然有效。<br>顺便说一句，如果你的脚本使用了函数，你可能对<code>Step-Out</code> cmdlet更感兴趣，<code>Step-Out</code> 的工作方式和<code>Step-Into</code> 一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。</li></ol><h3 id="因此PowerShell实际是一门独立的脚本语言了"><a href="#因此PowerShell实际是一门独立的脚本语言了" class="headerlink" title="因此PowerShell实际是一门独立的脚本语言了"></a>因此PowerShell实际是一门独立的脚本语言了</h3><h2 id="PowerShell能干什么？"><a href="#PowerShell能干什么？" class="headerlink" title="PowerShell能干什么？"></a>PowerShell能干什么？</h2><h3 id="PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，"><a href="#PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，" class="headerlink" title="PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，"></a>PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，</h3><p>为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。</p><p>PowerShell能做下面这些事:</p><blockquote><p>.NET/.NET CORE编程, Registry, COM, WMI, ADSI. Exchange, Sharepoint,<br> Systems Center, Hyper-V, SQL. VMware vCenter, Cisco UCS,<br> Citrix XenApp and XenDesktop.，Azure, Excel 和 Office applications.<br> 基本上所有的微软产品都提供PowerShell接口。</p></blockquote><h4 id="1、管理进程"><a href="#1、管理进程" class="headerlink" title="1、管理进程"></a>1、管理进程</h4><p>前面已经提过管理系统进程的命令，管理进程常用命令就是<code>get-process</code>和<code>stop-process</code>，<code>get-process</code>获取进程之后可以直接用管道发送给<code>stop-process</code>结束进程。<br>比如，关闭打开的记事本，可以使用下面的命令很方便的关闭记事本。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-process</span> <span class="literal">-Name</span> notepad | <span class="built_in">stop-process</span></span><br></pre></td></tr></table></figure><h4 id="2、处理文件和文件夹"><a href="#2、处理文件和文件夹" class="headerlink" title="2、处理文件和文件夹"></a>2、处理文件和文件夹</h4><p>PowerShell使用<code>Get-ChildItem</code>获取文件夹中直接包含的所有项，<br>它有系统内置别名<code>dir</code>和<code>ls</code>，使用CMD和BASH的用户均可以轻松上手。<br>如果想查看<code>C:</code>中的文件夹和文件，直接使用<code>dir c:</code>，PowerShell立刻就会列出<code>C:</code>中的文件和文件夹。<br>其它处理文件和文件夹的命令有<code>Copy-Item</code>、<code>New-Item</code>、<code>Remove-Item</code>等，<br>具体用法可以使用<code>get-help</code>然后跟命令名称即可查询。</p><h4 id="3、处理系统服务"><a href="#3、处理系统服务" class="headerlink" title="3、处理系统服务"></a>3、处理系统服务</h4><p>可以像管理进程一样管理系统服务，</p><ul><li><code>Get-Service</code>命令获取服务列表，</li><li><code>Stop-Service</code>命令停止服务，</li><li><code>Start-Service</code>命令启动服务，</li><li><code>Suspend-Service</code>命令挂起服务，</li><li><code>Restart-Service</code>命令重启服务，</li><li><code>Set-Service</code>服务设置服务属性。<br>如果想一次性启动已经停止的服务，可以使用以下命令：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-service</span> | <span class="built_in">where-object</span> &#123;<span class="variable">$_</span>.Status <span class="operator">-eq</span> <span class="string">&quot;Stopped&quot;</span>&#125; <span class="literal">-exclude</span></span><br></pre></td></tr></table></figure></li><li><em>下面这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。</em>*<br><code>wisvc | start-service</code></li></ul><h4 id="4、处理注册表"><a href="#4、处理注册表" class="headerlink" title="4、处理注册表"></a>4、处理注册表</h4><p>PowerShell可以非常方便的处理注册表项目，<br>与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，<br>这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。<br>由于注册表对系统<strong>非常重要</strong>，<strong>错误处理注册表也许会导致系统出问题</strong>，<br>处理注册表，特别是删除注册表项目要<strong>非常小心</strong>，<br>最好能在处理注册表项目之前先<strong>备份</strong>要处理的项目。<strong>没有管理员权限也能处理部分注册表项目</strong>，<br>这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。</p><h4 id="5、处理其它任务"><a href="#5、处理其它任务" class="headerlink" title="5、处理其它任务"></a>5、处理其它任务</h4><p>PowerShell还可以处理证书、防火墙、appx应用、打印机等任务，篇幅所限，不具体举例。大家可以使用get-command命令查找相关命令。</p><h4 id="6、编写脚本程序"><a href="#6、编写脚本程序" class="headerlink" title="6、编写脚本程序"></a>6、编写脚本程序</h4><p>借助于.Net/.Net Core 实际上来说其他的编程语言能干什么，<br>PowerShell都可以做到，PowerShell能够充分利用.Net类型和COM对象，<br>来简单地与各种系统交互，完成各种复杂的、自动化的操作，因此PowerShell现在也是很不错的编程语言了，<br>有人还做出了ps1 to exe的脚本，可以将PowerShell编写的脚本文件编译成exe可执行文件。</p><h2 id="一个有趣的例子"><a href="#一个有趣的例子" class="headerlink" title="一个有趣的例子"></a>一个有趣的例子</h2><p>这是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。<br>有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的excel com对象</span></span><br><span class="line"><span class="variable">$objExcel</span> = <span class="built_in">New-Object</span> <span class="literal">-comobject</span> Excel.Application</span><br><span class="line"><span class="variable">$objExcel</span>.Visible = <span class="variable">$True</span></span><br><span class="line"><span class="variable">$objWorkbook</span> = <span class="variable">$objExcel</span>.Workbooks.Add()</span><br><span class="line"><span class="variable">$objWorksheet</span> = <span class="variable">$objWorkbook</span>.Worksheets.Item(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把信息写入excel</span></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span></span><br><span class="line"><span class="variable">$first10</span> = (<span class="built_in">ps</span> | <span class="built_in">sort</span> ws <span class="literal">-Descending</span> | <span class="built_in">select</span> <span class="literal">-first</span> <span class="number">10</span>)</span><br><span class="line"><span class="variable">$first10</span> | <span class="keyword">foreach</span> <span class="literal">-Process</span> &#123;<span class="variable">$i</span>++; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="variable">$i</span>,<span class="number">1</span>) = <span class="variable">$_</span>.name; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="variable">$i</span>,<span class="number">2</span>) = <span class="variable">$_</span>.ws&#125;</span><br><span class="line"><span class="variable">$otherMem</span> = (<span class="built_in">ps</span> | <span class="built_in">measure</span> ws <span class="literal">-s</span>).Sum - (<span class="variable">$first10</span> | <span class="built_in">measure</span> ws <span class="literal">-s</span>).Sum</span><br><span class="line"><span class="variable">$objWorksheet</span>.Cells.Item(<span class="number">11</span>,<span class="number">1</span>) = <span class="string">&quot;Others&quot;</span>; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="number">11</span>,<span class="number">2</span>) = <span class="variable">$otherMem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画饼图</span></span><br><span class="line"><span class="variable">$objCharts</span> = <span class="variable">$objWorksheet</span>.ChartObjects()</span><br><span class="line"><span class="variable">$objChart</span> = <span class="variable">$objCharts</span>.Add(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>)</span><br><span class="line"><span class="variable">$objChart</span>.Chart.SetSourceData(<span class="variable">$objWorksheet</span>.range(<span class="string">&quot;A1:B11&quot;</span>), <span class="number">2</span>)</span><br><span class="line"><span class="variable">$objChart</span>.Chart.ChartType = <span class="number">70</span></span><br><span class="line"><span class="variable">$objChart</span>.Chart.ApplyDataLabels(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#暂停</span></span><br><span class="line">pause</span><br><span class="line"><span class="variable">$objExcel</span>.Quit()</span><br><span class="line"><span class="variable">$objExcel</span> = <span class="variable">$null</span></span><br><span class="line">[<span class="type">GC</span>]::Collect()</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果:"></a>执行结果:</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/screenshot.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/screenshot.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="执行结果"></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Powershell&quot;&gt;&lt;a href=&quot;#Powershell&quot; class=&quot;headerlink&quot; title=&quot;Powershell&quot;&gt;&lt;/a&gt;Powershell&lt;/h3&gt;&lt;p&gt;PowerShell 是一种命令行外壳程序和脚本环境，&lt;br&gt;使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/PowerShell/"/>
    
    
    <category term="PowerShell" scheme="https://www.lollipopnougat.top/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>元旦快乐</title>
    <link href="https://www.lollipopnougat.top/2019/01/01/%E5%85%83%E6%97%A6%E5%BF%AB%E4%B9%90/"/>
    <id>https://www.lollipopnougat.top/2019/01/01/%E5%85%83%E6%97%A6%E5%BF%AB%E4%B9%90/</id>
    <published>2018-12-31T16:12:12.000Z</published>
    <updated>2021-04-26T07:41:39.670Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019元旦快乐"><a href="#2019元旦快乐" class="headerlink" title="2019元旦快乐"></a>2019元旦快乐</h3><span id="more"></span><div class="note quote"><p>相逢是首悠扬的歌，相识是杯醇香的酒，</p></div><div class="note quote"><p>相处是那南飞的雁，相知是根古老的藤。</p></div><div class="note quote"><p>健康是最佳的礼物，知足是最大的财富，</p></div><div class="note quote"><p>信心是最可贵的品德，关心是最真挚的问候，</p></div><div class="note quote"><p>牵挂是最无私的思念，祝福是最美好的话语！</p></div><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/HappyNewYear.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/HappyNewYear.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Happy New Year!"></p><h3 id="在此献上最美好的祝福"><a href="#在此献上最美好的祝福" class="headerlink" title="在此献上最美好的祝福"></a>在此献上最美好的祝福</h3><h4 id="祝各位朋友们2019年新年快乐！平安幸福！"><a href="#祝各位朋友们2019年新年快乐！平安幸福！" class="headerlink" title="祝各位朋友们2019年新年快乐！平安幸福！"></a>祝各位朋友们2019年新年快乐！平安幸福！</h4>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;2019元旦快乐&quot;&gt;&lt;a href=&quot;#2019元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;2019元旦快乐&quot;&gt;&lt;/a&gt;2019元旦快乐&lt;/h3&gt;</summary>
    
    
    
    <category term="节日祝福" scheme="https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
    <category term="元旦" scheme="https://www.lollipopnougat.top/categories/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/%E5%85%83%E6%97%A6/"/>
    
    
    <category term="节日祝福" scheme="https://www.lollipopnougat.top/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
    <category term="元旦" scheme="https://www.lollipopnougat.top/tags/%E5%85%83%E6%97%A6/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计</title>
    <link href="https://www.lollipopnougat.top/2018/12/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://www.lollipopnougat.top/2018/12/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2018-12-30T07:06:15.000Z</published>
    <updated>2021-04-26T07:28:17.196Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。<br>对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据<strong>封装</strong>其中，以提高软件的<strong>重用性</strong>、<strong>灵活性</strong>和<strong>扩展性</strong>。</p><p>面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，<br>传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。</p><span id="more"></span><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个个体，即对象。<br>目前已经被证实的是，面向对象程序设计推广了程序的<strong>灵活性</strong>和<strong>可维护性</strong>，并且在大型项目设计中广为应用。<br>此外，面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p><h3 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h3><p>面向对象是在结构化设计方法出现很多问题的情况下应运而生的。</p><p>结构化设计方法求解问题的基本策略是从功能的角度审视问题域。<br>它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。<br>在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。<br>面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。</p><h5 id="1-审视问题域的视角"><a href="#1-审视问题域的视角" class="headerlink" title="1. 审视问题域的视角"></a>1. 审视问题域的视角</h5><blockquote><p>在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校学生管理系统来说，无论是简单还是复杂，始终是围绕学生和老师这两个客体实施。在自然界，每个客体都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。 </p></blockquote><p>通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在客体之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的客体，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。 </p><p>结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行程序设计的时候，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，客体是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个客体，但管理图书的方法可能是截然不同的。结构化设计方法将审视问题的视角定位于不稳定的操作之上，并将描述客体的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。</p><h5 id="2-抽象级别"><a href="#2-抽象级别" class="headerlink" title="2. 抽象级别"></a>2. 抽象级别</h5><blockquote><p>抽象是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性。抽象主要包括过程抽象和数据抽象。结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种抽象级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个客体属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。</p></blockquote><h5 id="3-封装体"><a href="#3-封装体" class="headerlink" title="3. 封装体"></a>3. 封装体</h5><blockquote><p>封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。这样做既可以实现对客体属性的保护作用，又可以提高软件系统的可维护性。只要用户接口不改变，任何封装体内部的改变都不会对软件系统的其他部分造成影响。结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。</p></blockquote><h5 id="4-可重用性"><a href="#4-可重用性" class="headerlink" title="4. 可重用性"></a>4. 可重用性</h5><blockquote><p>可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用构件，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，结构化程序设计方法的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在C语言编写程序时使用大量的标准函数。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些数据类型发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用构件是如今应用领域对软件开发提出的新需求。</p></blockquote><p>上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对软件开发的更高要求，面向对象由此产生。</p><p>面向对象程序设计从80年代以后成为了一种主导思想，这主要归功于C++在编写图形界面的应用。<br>在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地<em>适应了潮流</em>。<br>面向对象程序设计的思想也使<strong>事件处理式</strong>的程序设计更加广泛被应用</p><h3 id="抽象的示例"><a href="#抽象的示例" class="headerlink" title="抽象的示例"></a>抽象的示例</h3><p>假如我们要写一个程序模拟一只羊，使用C语言面向过程的方法，<br>首先想到的是开一个结构体，然后定义几个变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sheep</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sheep Jeff; <span class="comment">//定义一只叫Jeff的羊</span></span><br></pre></td></tr></table></figure><p>很容易，现在Jeff要跑，怎么办？<br>于是就用一个run函数，把Jeff作为一个参数传递来实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Sheep sheep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(Jeff);</span><br></pre></td></tr></table></figure><p>也很容易是吧，现在我们的Jeff遇到了羊大侠，羊大侠是站着跑的，怎么描述羊大侠站着跑呢？<br>再写一个函数，站着跑？那假如又遇到穿鞋跑的怎么办？</p><p>这时候如果使用面向对象的方法，将跑步作为对象的成员函数，把跑步的方法作为参数传递；<br>这样，所有的羊都有了一种叫跑步的方法，就方便多了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(string method=<span class="string">&quot;default&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mie</span><span class="params">()</span></span>;<span class="comment">//咩</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height,weight;</span><br><span class="line">&#125;;<span class="comment">//定义一个Sheep类</span></span><br><span class="line"></span><br><span class="line">Sheep Jeff;</span><br><span class="line">Jeff.<span class="built_in">run</span>(); <span class="comment">//Jeff使用默认的方法跑步</span></span><br><span class="line"></span><br><span class="line">Sheep YangDaXia;</span><br><span class="line">YangDaXia.<span class="built_in">run</span>(<span class="string">&quot;onFoot&quot;</span>); <span class="comment">//羊大侠站着跑</span></span><br><span class="line"></span><br><span class="line">Sheep XiYangYang;</span><br><span class="line">XiYangYang.<span class="built_in">run</span>(<span class="string">&quot;shoes&quot;</span>); <span class="comment">//喜羊羊穿鞋跑</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;面向对象的程序设计&quot;&gt;&lt;a href=&quot;#面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;面向对象的程序设计&quot;&gt;&lt;/a&gt;面向对象的程序设计&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。&lt;br&gt;对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据&lt;strong&gt;封装&lt;/strong&gt;其中，以提高软件的&lt;strong&gt;重用性&lt;/strong&gt;、&lt;strong&gt;灵活性&lt;/strong&gt;和&lt;strong&gt;扩展性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，&lt;br&gt;传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。&lt;/p&gt;</summary>
    
    
    
    <category term="面向对象" scheme="https://www.lollipopnougat.top/categories/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    
    <category term="面向对象" scheme="https://www.lollipopnougat.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
    <category term="C/C++" scheme="https://www.lollipopnougat.top/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>The first one</title>
    <link href="https://www.lollipopnougat.top/2018/12/30/The-first-one/"/>
    <id>https://www.lollipopnougat.top/2018/12/30/The-first-one/</id>
    <published>2018-12-30T03:44:32.000Z</published>
    <updated>2021-04-25T09:04:20.446Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试用页面"><a href="#测试用页面" class="headerlink" title="测试用页面"></a>测试用页面</h3><span id="more"></span><p>第一个第一个第一个哈哈哈哈哈哈哈哈哈哈![^1]<br>[^1]: 这是脚注</p><h1 id="这是1级标题"><a href="#这是1级标题" class="headerlink" title="这是1级标题"></a>这是1级标题</h1><p><em>这是斜体</em><br><strong>这是加粗</strong><br><em><strong>这是斜体加粗</strong></em></p><p><del>这是删除</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello,world!&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这是代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这是2级标题"><a href="#这是2级标题" class="headerlink" title="这是2级标题"></a>这是2级标题</h2><p><code>这是代码块</code></p><h3 id="这是3级标题"><a href="#这是3级标题" class="headerlink" title="这是3级标题"></a>这是3级标题</h3><blockquote><p>这是引述</p><blockquote><p>这是引述嵌套</p></blockquote></blockquote><p><img src="https://www.baidu.com/img/dong_418ce2c6c5171fb4cb0d4d1edb4fab68.gif" class="lazyload" data-srcset="https://www.baidu.com/img/dong_418ce2c6c5171fb4cb0d4d1edb4fab68.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="这是图片"> </p><hr><h4 id="这是4级标题"><a href="#这是4级标题" class="headerlink" title="这是4级标题"></a>这是4级标题</h4><p><a href="http://www.baidu.com/">这是百度一下</a></p><p>-[x] 选项一<br>-[ ] 选项二<br>-[ ] 选项三</p><hr><h5 id="这是5级标题"><a href="#这是5级标题" class="headerlink" title="这是5级标题"></a>这是5级标题</h5><ul><li>这是无序列表</li><li>这是无序列表</li><li>这是无序列表</li></ul><ol><li>这是有序列表</li><li>这是有序列表</li><li>这是有序列表</li></ol>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;测试用页面&quot;&gt;&lt;a href=&quot;#测试用页面&quot; class=&quot;headerlink&quot; title=&quot;测试用页面&quot;&gt;&lt;/a&gt;测试用页面&lt;/h3&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
