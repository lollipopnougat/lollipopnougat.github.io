<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LNP</title>
  
  
  <link href="/Crepeblog/atom.xml" rel="self"/>
  
  <link href="https://lollipopnougat.github.io/"/>
  <updated>2020-02-28T15:01:02.133Z</updated>
  <id>https://lollipopnougat.github.io/</id>
  
  <author>
    <name>LNP.</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>肺炎疫情信息的获取</title>
    <link href="https://lollipopnougat.github.io/2020/02/05/%E8%82%BA%E7%82%8E%E7%96%AB%E6%83%85%E4%BF%A1%E6%81%AF%E7%9A%84%E8%8E%B7%E5%8F%96/"/>
    <id>https://lollipopnougat.github.io/2020/02/05/肺炎疫情信息的获取/</id>
    <published>2020-02-05T02:47:53.000Z</published>
    <updated>2020-02-28T15:01:02.133Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python-爬虫相关"><a href="#python-爬虫相关" class="headerlink" title="python 爬虫相关"></a>python 爬虫相关</h3><p>也算是练习一下好久没写的爬虫了</p><a id="more"></a><p>最近病毒肆虐，丁香园为了方便大众得知最新消息，开设了一个<a href="https://ncov.dxy.cn/ncovh5/view/pneumonia" target="_blank" rel="noopener">网页</a>,可以从中得知当前的最新感染数据信息，笔者在浏览此页面后看到数据是以 json 格式送到浏览器的，觉得不妨写一个爬虫获取数据写入文件来进行统计…</p><h4 id="爬取到的网页关键数据-全国"><a href="#爬取到的网页关键数据-全国" class="headerlink" title="爬取到的网页关键数据(全国)"></a>爬取到的网页关键数据(全国)</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">id</span>=<span class="string">"getStatisticsService"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.getStatisticsService = &#123;</span></span><br><span class="line"><span class="undefined">      id: 1,</span></span><br><span class="line"><span class="undefined">      createTime: 1579537899000,</span></span><br><span class="line"><span class="undefined">      modifyTime: 1580795061000,</span></span><br><span class="line"><span class="actionscript">      infectSource: <span class="string">'该字段已替换为说明2'</span>,</span></span><br><span class="line"><span class="actionscript">      passWay: <span class="string">'该字段已替换为说明3'</span>,</span></span><br><span class="line"><span class="undefined">      imgUrl:</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0201/450/3394153392393266839-135.png'</span>,</span></span><br><span class="line"><span class="undefined">      dailyPic:</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png,https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png,https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png,https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png,https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png'</span>,</span></span><br><span class="line"><span class="undefined">      dailyPics: [</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0204/552/3394712575660185843-135.png'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0204/249/3394712586397781099-135.png'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0204/446/3394712599282512495-135.png'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0204/414/3394712612167417469-135.png'</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="string">'https://img1.dxycdn.com/2020/0204/033/3394712622905006171-135.png'</span></span></span><br><span class="line"><span class="undefined">      ],</span></span><br><span class="line"><span class="actionscript">      summary: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">      deleted: <span class="literal">false</span>,</span></span><br><span class="line"><span class="actionscript">      countRemark: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">      confirmedCount: 20471,</span></span><br><span class="line"><span class="undefined">      suspectedCount: 23214,</span></span><br><span class="line"><span class="undefined">      curedCount: 657,</span></span><br><span class="line"><span class="undefined">      deadCount: 426,</span></span><br><span class="line"><span class="undefined">      seriousCount: 2788,</span></span><br><span class="line"><span class="undefined">      suspectedIncr: 5072,</span></span><br><span class="line"><span class="undefined">      confirmedIncr: 3235,</span></span><br><span class="line"><span class="undefined">      curedIncr: 182,</span></span><br><span class="line"><span class="undefined">      deadIncr: 65,</span></span><br><span class="line"><span class="undefined">      seriousIncr: 492,</span></span><br><span class="line"><span class="actionscript">      virus: <span class="string">'该字段已替换为说明1'</span>,</span></span><br><span class="line"><span class="undefined">      remark1:</span></span><br><span class="line"><span class="actionscript">        <span class="string">'易感人群：人群普遍易感。老年人及有基础疾病者感染后病情较重，儿童及婴幼儿也有发病'</span>,</span></span><br><span class="line"><span class="actionscript">      remark2: <span class="string">'潜伏期：一般为 3～7 天，最长不超过 14 天，潜伏期内存在传染性'</span>,</span></span><br><span class="line"><span class="actionscript">      remark3: <span class="string">'宿主：野生动物，可能为中华菊头蝠'</span>,</span></span><br><span class="line"><span class="actionscript">      remark4: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">      remark5: <span class="string">''</span>,</span></span><br><span class="line"><span class="actionscript">      note1: <span class="string">'病毒：新型冠状病毒 2019-nCoV'</span>,</span></span><br><span class="line"><span class="actionscript">      note2: <span class="string">'传染源：新型冠状病毒感染的肺炎患者'</span>,</span></span><br><span class="line"><span class="undefined">      note3:</span></span><br><span class="line"><span class="actionscript">        <span class="string">'传播途径：经呼吸道飞沫传播，亦可通过接触传播，存在粪-口传播可能性'</span>,</span></span><br><span class="line"><span class="undefined">      generalRemark:</span></span><br><span class="line"><span class="actionscript">        <span class="string">'疑似病例数来自国家卫健委数据，目前为全国数据，未分省市自治区等'</span>,</span></span><br><span class="line"><span class="actionscript">      abroadRemark: <span class="string">''</span>,</span></span><br><span class="line"><span class="undefined">      marquee: []</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="actionscript">  &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="爬取到的网页关键数据-各省，局部"><a href="#爬取到的网页关键数据-各省，局部" class="headerlink" title="爬取到的网页关键数据(各省，局部)"></a>爬取到的网页关键数据(各省，局部)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.getAreaStat = [</span><br><span class="line">    &#123;</span><br><span class="line">      provinceName: <span class="string">'湖北省'</span>,</span><br><span class="line">      provinceShortName: <span class="string">'湖北'</span>,</span><br><span class="line">      confirmedCount: <span class="number">13522</span>,</span><br><span class="line">      suspectedCount: <span class="number">0</span>,</span><br><span class="line">      curedCount: <span class="number">398</span>,</span><br><span class="line">      deadCount: <span class="number">414</span>,</span><br><span class="line">      comment: <span class="string">'待明确地区，治愈 96'</span>,</span><br><span class="line">      locationId: <span class="number">420000</span>,</span><br><span class="line">      cities: [</span><br><span class="line">        &#123;</span><br><span class="line">          cityName: <span class="string">'武汉'</span>,</span><br><span class="line">          confirmedCount: <span class="number">6384</span>,</span><br><span class="line">          suspectedCount: <span class="number">0</span>,</span><br><span class="line">          curedCount: <span class="number">307</span>,</span><br><span class="line">          deadCount: <span class="number">313</span>,</span><br><span class="line">          locationId: <span class="number">420100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 以下省略n个城市</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何从爬取的字符串中获取数据"><a href="#如何从爬取的字符串中获取数据" class="headerlink" title="如何从爬取的字符串中获取数据"></a>如何从爬取的字符串中获取数据</h4><p>经过一番分析，最终使用了正则和 BS 库获取了 json 字符串，剩下的就很好处理了。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pat1 = re.compile(<span class="string">'(\[[^\]]+?\])'</span>)</span><br><span class="line"><span class="comment">#原本写的是 pat2 = re.compile('(\&#123;[^\&#125;\&#123;]+?\&#125;)') 但丁香园发布了一条特殊格式的数据后不能用了，于是就换成了下面那个</span></span><br><span class="line">pat2 = re.compile(<span class="string">'=\s?(\&#123;.+)\&#125;catch'</span>)</span><br><span class="line">dat1 = str(soup.findAll(id=<span class="string">'getListByCountryTypeService1'</span>)[<span class="number">0</span>].string)</span><br><span class="line">dat2 = str(soup.findAll(id=<span class="string">'getStatisticsService'</span>)[<span class="number">0</span>].string)</span><br><span class="line"><span class="comment"># 各省</span></span><br><span class="line">st1 = pat1.findall(dat1)[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 全国</span></span><br><span class="line">st2 = pat2.findall(dat2)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>附赠一个可以显示目前各省累计确诊人数占全国比例的爬虫</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">as</span> req</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup <span class="keyword">as</span> bs</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://ncov.dxy.cn/ncovh5/view/pneumonia_peopleapp'</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">'User-Agent'</span>:</span><br><span class="line">    <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/79.0.3945.130 Safari/537.36'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pat1 = re.compile(<span class="string">'(\[[^\]]+?\])'</span>)</span><br><span class="line">pat2 = re.compile(<span class="string">'=\s?(\&#123;.+)\&#125;catch'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">()</span>:</span></span><br><span class="line">    res = req.get(url=url, headers=header)</span><br><span class="line"></span><br><span class="line">    print(res.status_code)</span><br><span class="line">    res.encoding = res.apparent_encoding</span><br><span class="line"></span><br><span class="line">    soup = bs(res.text, <span class="string">'html.parser'</span>)</span><br><span class="line">    dat1 = str(soup.findAll(id=<span class="string">'getListByCountryTypeService1'</span>)[<span class="number">0</span>].string)</span><br><span class="line">    dat2 = str(soup.findAll(id=<span class="string">'getStatisticsService'</span>)[<span class="number">0</span>].string)</span><br><span class="line">    st1 = pat1.findall(dat1)[<span class="number">0</span>]</span><br><span class="line">    st2 = pat2.findall(dat2)[<span class="number">0</span>]</span><br><span class="line">    js = json.loads(st1)</span><br><span class="line">    al = json.loads(st2)</span><br><span class="line">    prov_list = []</span><br><span class="line">    conf_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> js:</span><br><span class="line">        print(<span class="string">'%s 确诊数： %d， 治愈数： %d， 死亡数: %d'</span> %</span><br><span class="line">              (i[<span class="string">'provinceName'</span>], i[<span class="string">'confirmedCount'</span>], i[<span class="string">'curedCount'</span>],</span><br><span class="line">               i[<span class="string">'deadCount'</span>]))</span><br><span class="line">        prov_list.append(i[<span class="string">'provinceName'</span>])</span><br><span class="line">        conf_list.append(i[<span class="string">'confirmedCount'</span>])</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'全国确诊： %d， 疑似数： %d， 治愈数： %d， 死亡数： %d， 重症数： %d'</span> %</span><br><span class="line">          (al[<span class="string">'confirmedCount'</span>], al[<span class="string">'suspectedCount'</span>], al[<span class="string">'curedCount'</span>],</span><br><span class="line">           al[<span class="string">'deadCount'</span>], al[<span class="string">'seriousCount'</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 调用 matplotlib 准备绘图</span></span><br><span class="line">    font = &#123;<span class="string">'family'</span>: <span class="string">'MicroSoft YaHei'</span>, <span class="string">'weight'</span>: <span class="string">'light'</span>, <span class="string">'size'</span>: <span class="number">10</span>&#125;</span><br><span class="line">    matplotlib.rc(<span class="string">"font"</span>, **font)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">9</span>), dpi=<span class="number">80</span>)</span><br><span class="line">    fig.canvas.set_window_title(<span class="string">'全国各省感染人数占比'</span>)</span><br><span class="line">    plt.axes(aspect=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 饼图</span></span><br><span class="line">    plt.pie(x=conf_list,</span><br><span class="line">            labels=prov_list,</span><br><span class="line">            autopct=<span class="string">'%3.1f %%'</span>,</span><br><span class="line">            pctdistance=<span class="number">1.2</span>,</span><br><span class="line">            labeldistance=<span class="number">1.0</span>)</span><br><span class="line">    plt.title(<span class="string">'全国各省感染人数占比'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    input(<span class="string">'任意键继续'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    task()</span><br></pre></td></tr></table></figure><h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>完成整个脚本以后配置一下计划任务，再添加一个每一小时获取一次写入文件功能，省了不少事…其实还可以通过异步维护一个计时器，每隔一段时间运行一次(好像单线程就是用 sleep 也可以吧，嘛不管了)</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;python-爬虫相关&quot;&gt;&lt;a href=&quot;#python-爬虫相关&quot; class=&quot;headerlink&quot; title=&quot;python 爬虫相关&quot;&gt;&lt;/a&gt;python 爬虫相关&lt;/h3&gt;&lt;p&gt;也算是练习一下好久没写的爬虫了&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://lollipopnougat.github.io/tags/python/"/>
    
      <category term="爬虫" scheme="https://lollipopnougat.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>最近忙的很</title>
    <link href="https://lollipopnougat.github.io/2019/12/03/%E6%9C%80%E8%BF%91%E5%BF%99%E7%9A%84%E5%BE%88/"/>
    <id>https://lollipopnougat.github.io/2019/12/03/最近忙的很/</id>
    <published>2019-12-03T13:10:21.000Z</published>
    <updated>2020-02-25T05:44:15.313Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近事还挺多的…"><a href="#最近事还挺多的…" class="headerlink" title="最近事还挺多的…"></a>最近事还挺多的…</h3><p>也没顾的上更新博客</p><a id="more"></a><p>等到课近期的设完成大概就有时间了吧…<br>今天先鸽了，，，咕咕咕</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;最近事还挺多的…&quot;&gt;&lt;a href=&quot;#最近事还挺多的…&quot; class=&quot;headerlink&quot; title=&quot;最近事还挺多的…&quot;&gt;&lt;/a&gt;最近事还挺多的…&lt;/h3&gt;&lt;p&gt;也没顾的上更新博客&lt;/p&gt;
    
    </summary>
    
    
      <category term="吐槽" scheme="https://lollipopnougat.github.io/tags/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>网络安全协会网站的搭建(一)</title>
    <link href="https://lollipopnougat.github.io/2019/09/06/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A%E7%BD%91%E7%AB%99%E7%9A%84%E6%90%AD%E5%BB%BA(1)/"/>
    <id>https://lollipopnougat.github.io/2019/09/06/网络安全协会网站的搭建(1)/</id>
    <published>2019-09-06T15:20:37.000Z</published>
    <updated>2020-02-25T05:41:17.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络安全协会网站的搭建"><a href="#网络安全协会网站的搭建" class="headerlink" title="网络安全协会网站的搭建"></a>网络安全协会网站的搭建</h3><p>一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊<br>特别是看了ACM协会的网站之后，更加坚定了开发的想法<br>所以<a href="https://github.com/lollipopnougat/chdns" target="_blank" rel="noopener">这个</a>项目就出现了</p><p><a href="https://chdans.github.io" target="_blank" rel="noopener">网站预览</a></p><a id="more"></a><h2 id="Vue-js-与-Node-js"><a href="#Vue-js-与-Node-js" class="headerlink" title="Vue.js 与 Node.js"></a>Vue.js 与 Node.js</h2><blockquote><p>Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。</p></blockquote><p>早就在关注尤雨溪大佬和他的<a href="https://github.com/vuejs/vue" target="_blank" rel="noopener">Vue.js</a>项目。</p><p>今年年初曾尝试搞了一个demo，结果最后搞的一头雾水，也没弄懂…<br>最终结果就是弃了…</p><p>直到今年5月份我准备做数据库课设，才算稍微系统地学习了一下 <code>Node.js</code>，用 <code>Express</code> 熟悉了一下 <code>Node</code> 的项目结构和使用 <code>npm</code> 的方法，顺便提高了js的开发能力。我也学到了 <code>js</code> 的异步回调什么的，还有编写 <code>HTML</code> 和 <code>CSS</code> 的熟练度也得到了少许提高，暑假时又学习了一部分 <code>TypeScript</code> 和 <code>ES6</code> 的语法，勉强算是做了较多的铺垫。</p><p>这两天重新看 <code>vue</code> 的项目的时候终于明白那都是什么东西了，有点 <code>Express</code> 的感觉，但是 <code>router</code> 竟然可以 build 成静态的，默认采用的是 <code>Hash</code> 方式，一个网站可以做成单页的，有趣啊！</p><p>于是9月1日建立了项目仓库，9月3日提交了研究了两天的结果(一个 <code>Header</code> )，因为将来要放到新GitHub账号上，build出来的静态文件有开 Http 服务的要求，因此我专门开了我GitHub的托管根目录做预览，这周前前后后一共提交了7次，之后就正式迁移到 <a href="https://chdans.github.io" target="_blank" rel="noopener">chdans.github.io</a> 了，我修改了结构，我build好的项目提交到我fork出来的 chdans 创建的那个静态页项目下，然后再新建 <code>Pull Request</code>，提交到 chdans，再由 chdans来 <code>Merge</code> 请求，这就是一次完整的更新。</p><p>不得不说<a href="https://element.eleme.io" target="_blank" rel="noopener">element ui</a>做的真的既简介又漂亮，原版的配色我是很喜欢的，我一度把协会的宣传海报也采用相同配色，如图<br><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/picbed/neoposter.png" alt="海报"></p><p>之后会详细解释这个网站项目</p><p>今天就写这么多，明天还要迎新，7点就要去…</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;网络安全协会网站的搭建&quot;&gt;&lt;a href=&quot;#网络安全协会网站的搭建&quot; class=&quot;headerlink&quot; title=&quot;网络安全协会网站的搭建&quot;&gt;&lt;/a&gt;网络安全协会网站的搭建&lt;/h3&gt;&lt;p&gt;一个网络安全协会要体现自己的特色，必须要有自己的网站才行啊&lt;br&gt;特别是看了ACM协会的网站之后，更加坚定了开发的想法&lt;br&gt;所以&lt;a href=&quot;https://github.com/lollipopnougat/chdns&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这个&lt;/a&gt;项目就出现了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chdans.github.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;网站预览&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="网站搭建" scheme="https://lollipopnougat.github.io/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
      <category term="Vue.js" scheme="https://lollipopnougat.github.io/tags/Vue-js/"/>
    
      <category term="网络安全协会" scheme="https://lollipopnougat.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%8D%8F%E4%BC%9A/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(3)</title>
    <link href="https://lollipopnougat.github.io/2019/07/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(3)/"/>
    <id>https://lollipopnougat.github.io/2019/07/29/PowerShell入门指南(3)/</id>
    <published>2019-07-29T01:56:12.000Z</published>
    <updated>2020-02-25T05:39:10.655Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PowerShell入门指南-三-·一门新的编程语言"><a href="#PowerShell入门指南-三-·一门新的编程语言" class="headerlink" title="PowerShell入门指南(三)·一门新的编程语言"></a>PowerShell入门指南(三)·一门新的编程语言</h3><hr><h4 id="作为独立的编程语言"><a href="#作为独立的编程语言" class="headerlink" title="作为独立的编程语言"></a>作为独立的编程语言</h4><p>作为一门独立的语言来说，<code>PowerShell</code> 是非常地Powerful，我们先来了解一下它的特点:</p><a id="more"></a><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><h4 id="破天荒的方便"><a href="#破天荒的方便" class="headerlink" title="破天荒的方便"></a>破天荒的方便</h4><p>诸如存储计算中 <code>GB</code>， <code>MB</code>， <code>KB</code> 单位等；数组声明中的 <code>1..n</code> 和下标为 <code>-1</code> 的处理；还有所见即所得，通俗易懂的<strong>动词</strong>+<strong>名词</strong>结构的Cmdlet(PowerShell命令的称呼)。<br>还有自带的文档支持也很是丰富，只要熟练掌握 <code>Get-Help</code> 命令，其他命令的用法均可通过 <code>Get-Help</code> 查到</p></li><li><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>良心啊，这个语言竟然是面向对象的<br>与面向过程相比，面向对象更方便更容易描述现实世界，也算赶上了时髦。</p></li><li><h4 id="依托-NET"><a href="#依托-NET" class="headerlink" title="依托 .NET"></a>依托 .NET</h4><p>正所谓大树下面好乘凉，<code>PowerShell</code> 绑上 <code>.NET</code> 这个大款了，借助 <code>.NET</code> 平台强大的类库，几乎让一切都成为可能。</p></li><li><h4 id="强大的兼容性"><a href="#强大的兼容性" class="headerlink" title="强大的兼容性"></a>强大的兼容性</h4><p>完全兼容 <code>Windows</code> 平台上其它调用，如可执行文件(exe)，批处理bat/cmd和VBscript等, 在 <code>Linux</code> 和 <code>macOS</code> 上也能很好地工作。</p></li><li><h4 id="基于平台的可扩展性"><a href="#基于平台的可扩展性" class="headerlink" title="基于平台的可扩展性"></a>基于平台的可扩展性</h4><p>微软有个优点，与应用相比，它更喜欢做平台。<code>PowerShell</code> 早已变成一个平台，在 <code>PowerShell</code> 刚发布的第二年，微软的 System Center Operations Manager 和 SharePoint 就提供了针对该平台的组件，后来的活动目录，Hyper-V，Windows Azure，Office 365就更不用说了。除了微软，亚马逊的云平台管理，Dell的out-of-hand 管理，也都提供了基于 <code>PowerShell</code> 的管理组件。<code>PowerShell</code> 俨然变成了一个标准，变成了一个规范。</p></li></ul><hr><h3 id="使用Get-Help-快速入门"><a href="#使用Get-Help-快速入门" class="headerlink" title="使用Get-Help 快速入门"></a>使用<code>Get-Help</code> 快速入门</h3><p>下面用一个简单例子说明如何<code>Get-Help</code>，设想这样一个场景：<br>你想通过命令行查看所有进程，你第一个反应应该是用一个跟Process相关的命令来达到此目的，所以你可以会尝试执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Command</span> *<span class="keyword">Process</span></span><br><span class="line"><span class="comment">#结果</span></span><br><span class="line">CommandType     Name                   Version    Source</span><br><span class="line">-----------     ----                   -------    ------</span><br><span class="line">Cmdlet          <span class="built_in">Debug-Process</span>          <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          Enter-PSHostProcess    <span class="number">3.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Core</span><br><span class="line">Cmdlet          Exit-PSHostProcess     <span class="number">3.0</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Core</span><br><span class="line">Cmdlet          <span class="built_in">Get-Process</span>            <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Start-Process</span>          <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Stop-Process</span>           <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br><span class="line">Cmdlet          <span class="built_in">Wait-Process</span>           <span class="number">3.1</span>.<span class="number">0.0</span>    Microsoft.PowerShell.Management</span><br></pre></td></tr></table></figure><p>得知处理进程的命令有这些<br>然后再用 <code>Get-Help Get-Process -full</code> 就能得到 <code>Get-Process</code> 的详细用法以及使用范例</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><code>PowerShell</code> 是一个强类型(变量一旦定义，其本身类型不可改变就是强类型，反之就是弱类型)的动态脚本语言，支持面向对象，支持调用系统API和 <code>.NET</code> 库。<br>受到了 <code>Python</code>, <code>Ksh</code>, <code>Perl</code>, <code>C#</code>, <code>CL</code>, <code>DCL</code>, <code>SQL</code>, <code>Tcl</code>, <code>Tk</code>, <code>Chef</code>, <code>Puppet</code> 等语言的影响，结合了以上语言的部分特性。</p><p><code>PowerShell</code> 代码的外观和操作方式与C#的相似程度最高，不过也有它自己的特色。</p><h4 id="关于空白字符"><a href="#关于空白字符" class="headerlink" title="关于空白字符"></a>关于空白字符</h4><p>与 <code>Python</code> 等语言不同，<strong><code>PowerShell</code> 的解释器不会考虑代码中的空格或制表符</strong>(这些字符统称空白字符)。这样一来，格式化代码就有很大的自由度，但是遵循某些规则将有助于提高代码的可读性。</p><h4 id="代码块和代码基本结构"><a href="#代码块和代码基本结构" class="headerlink" title="代码块和代码基本结构"></a>代码块和代码基本结构</h4><p><code>PowerShell</code> 代码由一系列语句构成，每条语句可以使用一个分号结束，当然也可以不写。<strong>按照习惯是不写分号的，因此要用换行来区分不同的语句，如果必须写到一行中，那就在每一句后加个分号</strong>。</p><p>和C语系的大多数语言类似，<code>PowerShell</code> 是一种块结构的语言，这些块用 <code>{</code> 和 <code>}</code> 来界定，代码块可以包含任意多条语句，或者不包含任何语句，下面的示例还使用了缩进格式，这样能大大提高可读性，实际上编译器会自带缩进代码。一般情况下，每个代码块都有自己的缩进级别，代码块之间还能嵌套。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">&lt;#代码行1#&gt;</span></span><br><span class="line">    <span class="comment">&lt;#代码行2#&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">&lt;#代码行3#&gt;</span></span><br><span class="line">        <span class="comment">&lt;#代码行4#&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">&lt;#代码行5#&gt;</span>;<span class="comment">&lt;#代码行6#&gt;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然 <code>PowerShell</code> 的缩进不是强制的。</p><p>在 <code>PowerShell</code> 代码中，另一种常见的语句是注释，注释并不是能执行的语句，而是对代码的描述说明性文本。当代码运行时，解释器会忽略这些内容。<br>代码最好有注释，特别是处理较复杂的工作时，注释可以为正在进行的操作添加提示，例如“这行代码要求用户输入一个字符”、“此段代码是 LNP 编写的”。<br><code>PowerShell</code> 有两种添加注释方法</p><ul><li>行注释:  <code>#</code></li><li>块注释:  <code>&lt;#</code> 和 <code>#&gt;</code></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这是一行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;#</span></span><br><span class="line"><span class="comment">这是注释块</span></span><br><span class="line"><span class="comment">123ABC</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"></span><br><span class="line">ls <span class="comment">#列出当前目录下的文件和文件夹，是Get-ChildItem的别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#注意下面语句会产生错误</span></span><br><span class="line"><span class="comment">&lt;#块注释由"#&gt;</span><span class="string">"结尾#&gt;</span></span><br></pre></td></tr></table></figure><p>第一个 <code>#&gt;</code> 后面的部分会被认为是 <code>PowerShell</code> 代码，因此出现错误。</p><p>还有特别的注意一点，<strong><code>PowerShell</code> 代码是不区分大小写的</strong>，因此只要拼写正确的命令(或变量)，而无需关心大小写即可执行，不过最好还是有一定规范。</p><hr><h3 id="PowerShell-脚本的基本结构"><a href="#PowerShell-脚本的基本结构" class="headerlink" title="PowerShell 脚本的基本结构"></a><code>PowerShell</code> 脚本的基本结构</h3><p><code>PowerShell</code> 像 <code>Python</code> 一样，允许使用控制台直接输入命令进行交互，也可以事先把代码写入一个文件再作为脚本运行。<br>一个 <code>PowerShell</code> 脚本仅仅是一个包含 <code>PowerShell</code> 代码的文本文件。如果这个文本文件执行， <code>PowerShell</code> 解释器会逐行解释并执行它的的语句。<code>PowerShell</code> 脚本有点像以前 <code>CMD</code> 控制台上的批处理文件。可以通过非常简单的文本编辑工具创建 <code>PowerShell</code> 脚本。</p><p>PowerShell脚本文件的扩展名是 <code>.ps1</code></p><hr><h3 id="执行策略限制"><a href="#执行策略限制" class="headerlink" title="执行策略限制"></a>执行策略限制</h3><p><code>PowerShell</code> 一般初始化情况下都会禁止脚本执行。脚本能否执行取决于PowerShell的执行策略。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS E:&gt; ./MyScript.ps1</span><br><span class="line"></span><br><span class="line">无法加载文件 E:MyScript.ps1，因为在此系统中禁止执行脚本。有关详细信息，请参阅 <span class="string">"get-help about_signing"</span>。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">15</span></span><br><span class="line">+ .MyScript.ps1 &lt; &lt;&lt;&lt;</span><br><span class="line">    + CategoryInfo          : NotSpecified: (:) [], PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : RuntimeException</span><br></pre></td></tr></table></figure><p><strong>只有管理员才有权限更改这个策略。非管理员会报错。</strong></p><p>查看脚本执行策略，可以通过在 <code>PowerShell</code> 控制台直接输入:<br><code>Get-ExecutionPolicy</code><br><strong>更改脚本执行策略，可以管理员启动PowerShell，在控制台输入:</strong><br><code>Set-ExecutionPolicy &lt;策略&gt;</code><br>策略|解释<br>-|-<br>Unrestricted|权限最高，可以不受限制执行任何脚本。<br>Default|为Powershell默认的策略，即Restricted<br>Restricted|不允许任何脚本执行<br>AllSigned|所有脚本都必须经过签名才能在运行<br>RemoteSigned|本地脚本无限制，但是对来自网络的脚本必须经过签名</p><p>如果要使用脚本功能又要兼顾安全性，我们就选择RemoteSigned<br>即在以管理员身份允许的 <code>PowerShell</code> 输入<br><code>Set-ExecutionPolicy RemoteSigned</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行策略可以防止您执行不信任的脚本。更改执行策略可能会使您面临 about_Execution_Policies帮助主题中所述的安全风险。是否要更改执行策略?</span><br><span class="line">[Y] 是(Y)  [N] 否(N)  [S] 挂起(S)  [?] 帮助 (默认值为“Y”): y</span><br></pre></td></tr></table></figure><hr><h3 id="运行-PowerShell-脚本"><a href="#运行-PowerShell-脚本" class="headerlink" title="运行 PowerShell 脚本"></a>运行 <code>PowerShell</code> 脚本</h3><p>当您的脚本编写成功后您可能第一次会像下面的方式运行它，也就是只输入脚本的文件名，会报错。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS E:&gt; MyScript.ps1</span><br><span class="line"></span><br><span class="line">无法将“MyScript.ps1”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括</span><br><span class="line">路径，请确保路径正确，然后重试。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">13</span></span><br><span class="line">+ MyScript.ps1 &lt; &lt;&lt;&lt;</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (MyScript.ps1:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br><span class="line"></span><br><span class="line">Suggestion [<span class="number">3</span>,General]: 未找到命令 MyScript.ps1，但它确实存在于当前位置。Windows PowerShell 默认情况下不从当前位置加载命令。如果信任此命令，请改为键入 <span class="string">"./MyScript.ps1"</span>。有关更多详细信息，请参阅 <span class="string">"get-h</span></span><br><span class="line"><span class="string">elp about_Command_Precedence"</span>。</span><br></pre></td></tr></table></figure><p>解决办法很简单，如果脚本在当前工作目录，请在脚本文件明前添加<code>./</code>，或者使用绝对路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PS E:&gt; .\MyScript.ps1</span><br><span class="line"></span><br><span class="line">2019年3月27日 18:33:03</span><br><span class="line">C:\Program Files\Common Files</span><br><span class="line">files count</span><br><span class="line">20</span><br><span class="line"></span><br><span class="line">PS E:&gt; E:MyScript.ps1</span><br><span class="line"></span><br><span class="line">2019年3月27日 18:33:11</span><br><span class="line">C:\Program Files\Common Files</span><br><span class="line">files count</span><br><span class="line">20</span><br></pre></td></tr></table></figure><h5 id="通过重定向创建脚本"><a href="#通过重定向创建脚本" class="headerlink" title="通过重定向创建脚本"></a>通过重定向创建脚本</h5><p>如果想要执行的脚本不是很长，我们甚至可以直接在控制台中要执行的语句重定向给一个脚本文件。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS E:&gt; <span class="string">'"Hello,World!"'</span> &gt; MyScript.ps1</span><br><span class="line">PS E:&gt; ./MyScript.ps1</span><br><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><p>这样有个缺点，就是您的代码必须放在闭合的引号中。这样的书写方式一旦在脚本内部也有引号时，是一件很痛苦的事。甚至您还可能希望在脚本中换行。下面的Here-strings例子不错，也就是将脚本文件通过<code>@&#39; &#39;@</code>闭合起来。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PS E:&gt; <span class="string">@'</span></span><br><span class="line"><span class="string">&gt;&gt; Get-Date</span></span><br><span class="line"><span class="string">&gt;&gt; $Env:CommonProgramFiles</span></span><br><span class="line"><span class="string">&gt;&gt; #Script End</span></span><br><span class="line"><span class="string">&gt;&gt; "files count"</span></span><br><span class="line"><span class="string">&gt;&gt; (ls).Count</span></span><br><span class="line"><span class="string">&gt;&gt; #Script Really End</span></span><br><span class="line"><span class="string">&gt;&gt;</span></span><br><span class="line"><span class="string">&gt;&gt; '@ &gt; myscript.ps1</span></span><br><span class="line"><span class="string">&gt;&gt;</span></span><br><span class="line"><span class="string">PS E:&gt; .MyScript.ps1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">2019年3月27日 18:15:10</span></span><br><span class="line"><span class="string">C:\Program Files\Common Files</span></span><br><span class="line"><span class="string">files count</span></span><br><span class="line"><span class="string">20</span></span><br></pre></td></tr></table></figure><p>Here-String以 <code>@&#39;</code>开头，以<code>&#39;@</code>结束.任何文本都可以存放在里面，哪怕是一些特殊字符，空号，白空格。但是如果您不小心将单引号写成了双引号，<code>PowerShell</code> 将会把里面的变量进行解析。</p><h5 id="通过编辑器创建脚本"><a href="#通过编辑器创建脚本" class="headerlink" title="通过编辑器创建脚本"></a>通过编辑器创建脚本</h5><p>其实最方便的还是使用文本编辑器直接编写代码，保存成PS1文件，右键即可执行。<br>这里推荐使用Visual Studio Code(以下简称VSC)，VSC提供了PS1的自动补全(安装插件)、语法高亮、自动缩进、格式化代码、断点调试等功能。</p><hr><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量可以临时保存数据，因此可以把数据保存在变量中，以便进一步操作。<code>PowerShell</code> 的变量定义非常方便。<br>我们可以用 <code>$变量名=初值</code> 的方法定义变量，解释器会根据所赋的初值判断变量类型，类似于C#的 <code>var</code> 关键字或C++11中的 <code>auto</code> 关键字<code>PowerShell</code> 不需要显示地去声明，可以自动创建变量，只须记住变量的前缀为$.<br>创建好了变量后，可以通过变量名输出变量，也可以把变量名存在字符串中。但是有个例外:<strong>单引号中的字符串不会识别和处理变量名。</strong></p><h4 id="选择变量名"><a href="#选择变量名" class="headerlink" title="选择变量名"></a>选择变量名</h4><p>在 <code>PowerShell</code> 中变量名均是以美元符 <code>$</code> 开始，剩余字符可以是数字、字母、下划线的任意字符，并且PowerShell变量名也对大小写不敏感（<code>$a</code> 和 <code>$A</code> 是同一个变量)。<br>某些特殊的字符(比如<code>$</code>等)在 <code>PowerShell</code> 中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PS C:/&gt; $&#123;<span class="string">"I"</span>like $&#125;=<span class="number">5.1</span></span><br><span class="line">PS C:/&gt; $&#123;<span class="string">"I"</span>like $&#125;</span><br><span class="line"><span class="number">5.1</span></span><br></pre></td></tr></table></figure><p><strong>不能定义和保留变量名称相同的变量</strong><br>使用<code>ls variable:</code> 列出当前使用的所有变量，刚启动的 <code>PowerShell</code> 执行此命令能看到 <code>PowerShell</code> 的所有自动化变量(一旦打开 <code>Powershell</code> 就会自动加载的变量，后面将会详细解释这些变量的作用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Name                           Value</span><br><span class="line">----                           -----</span><br><span class="line">$</span><br><span class="line">?                              True</span><br><span class="line">^</span><br><span class="line">args                           &#123;&#125;</span><br><span class="line">ConfirmPreference              High</span><br><span class="line">ConsoleFileName</span><br><span class="line">DebugPreference                SilentlyContinue</span><br><span class="line">Error                          &#123;&#125;</span><br><span class="line">ErrorActionPreference          Continue</span><br><span class="line">ErrorView                      NormalView</span><br><span class="line">ExecutionContext               System.Management.Automation.EngineIntrinsics</span><br><span class="line">false                          False</span><br><span class="line">FormatEnumerationLimit         4</span><br><span class="line">HOME                           C:\Users\aaaaa</span><br><span class="line">Host                           System.Management.Automation.Internal.Host.InternalHost</span><br><span class="line">InformationPreference          SilentlyContinue</span><br><span class="line">input                          System.Collections.ArrayList+ArrayListEnumeratorSimple</span><br><span class="line">MaximumAliasCount              4096</span><br><span class="line">MaximumDriveCount              4096</span><br><span class="line">MaximumErrorCount              256</span><br><span class="line">MaximumFunctionCount           4096</span><br><span class="line">MaximumHistoryCount            4096</span><br><span class="line">MaximumVariableCount           4096</span><br><span class="line">MyInvocation                   System.Management.Automation.InvocationInfo</span><br><span class="line">NestedPromptLevel              0</span><br><span class="line">null</span><br><span class="line">OutputEncoding                 System.Text.ASCIIEncoding</span><br><span class="line">PID                            8796</span><br><span class="line">PROFILE                        C:\Users\aaaaa\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1</span><br><span class="line">ProgressPreference             Continue</span><br><span class="line">PSBoundParameters              &#123;&#125;</span><br><span class="line">PSCommandPath</span><br><span class="line">PSCulture                      zh-CN</span><br><span class="line">PSDefaultParameterValues       &#123;&#125;</span><br><span class="line">PSEdition                      Desktop</span><br><span class="line">PSEmailServer</span><br><span class="line">PSHOME                         C:\Windows\System32\WindowsPowerShell\v1.0</span><br><span class="line">PSScriptRoot</span><br><span class="line">PSSessionApplicationName       wsman</span><br><span class="line">PSSessionConfigurationName     http://schemas.microsoft.com/powershell/Microsoft.PowerShell</span><br><span class="line">PSSessionOption                System.Management.Automation.Remoting.PSSessionOption</span><br><span class="line">PSUICulture                    zh-CN</span><br><span class="line">PSVersionTable                 &#123;PSVersion, PSEdition, PSCompatibleVersions, BuildVersion...&#125;</span><br><span class="line">PWD                            C:\Users\aaaaa</span><br><span class="line">ShellId                        Microsoft.PowerShell</span><br><span class="line">StackTrace</span><br><span class="line">true                           True</span><br><span class="line">VerbosePreference              SilentlyContinue</span><br><span class="line">WarningPreference              Continue</span><br><span class="line">WhatIfPreference               False</span><br></pre></td></tr></table></figure><h4 id="查看变量类型"><a href="#查看变量类型" class="headerlink" title="查看变量类型"></a>查看变量类型</h4><p>变量可以自动存储任何<code>PowerShell</code>能够识别的类型信息，可以通过 <code>$变量名.GetType()</code> 查看和验证 <code>PowerShell</code> 分配给变量的数据类型</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:/&gt; <span class="variable">$num</span>=<span class="number">10</span></span><br><span class="line">PS C:/&gt; <span class="variable">$num</span>.gettype() <span class="comment">#不区分大小写</span></span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                            BaseType</span><br><span class="line">-------- -------- ----                            --------</span><br><span class="line">True     True     Int32                           System.ValueType</span><br></pre></td></tr></table></figure><h4 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h4><p>如果不想继续使用自定义的变量，可以使用<code>del variable:变量名</code>的方法删除变量，注意此处无<code>$</code>符号</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="number">0</span></span><br><span class="line"><span class="variable">$a</span> <span class="nomarkup">-eq</span> <span class="literal">$null</span></span><br><span class="line">False</span><br><span class="line">del variable:a</span><br><span class="line"><span class="variable">$a</span> <span class="nomarkup">-eq</span> <span class="literal">$null</span> </span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>PowerShell支持的变量类型和C#大体相同(没有了short、uint、ulong等)，大多都继承自<code>System.ValueType</code>类( .NET类)，其基本数据类型包括</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><table><thead><tr><th>类型</th><th>名称</th><th>允许的值</th><th>所属类</th></tr></thead><tbody><tr><td>byte</td><td>无符号整数(1字节)</td><td>0~255之间的整数</td><td>System.Byte</td></tr><tr><td>sbyte</td><td>有符号整数(1字节)</td><td>-128~127之间的整数</td><td>System.SByte</td></tr><tr><td>int16</td><td>有符号短整型(2字节)</td><td>-32768~32767之间的整数</td><td>System.Int16</td></tr><tr><td>uint16</td><td>无符号短整型(2字节)</td><td>0~65535之间的整数</td><td>System.UInt16</td></tr><tr><td>int</td><td>有符号整型</td><td>-2147483648~2147483647之间的整数</td><td>System.Int32</td></tr><tr><td>uint32</td><td>无符号整型</td><td>0~4294967295之间的整数</td><td>System.UInt32</td></tr><tr><td>long</td><td>有符号长整数(8字节)</td><td>-9223372036854775808~9223372036854775807之间的整数</td><td>System.Int64</td></tr><tr><td>ulong</td><td>无符号长整数(8字节)</td><td>0~18446744073709551615之间的整数</td><td>System.UInt64</td></tr></tbody></table><p>其实 <code>int</code> 、<code>long</code> 、以及下面的 <code>float</code> 都是 .NET的语法糖，真正的原生类型名是<code>int32</code>、<code>int64</code>、<code>single</code> 之类的类名</p><h4 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h4><p>浮点数标准形式(<code>float</code>和<code>double</code>) $+/-m×2^e$<br>其中m为尾数，e为阶码，尾数是一个非负数，阶码是一个整数<br>PowerShell还支持一个特别的浮点数类型 <code>decimal</code>，其形式为<br>$+/-m×10^e$</p><table><thead><tr><th>类型</th><th>名称</th><th>指数</th><th>m范围</th><th>e范围</th><th>近似最小值</th><th>近似最大值</th><th>所属类</th></tr></thead><tbody><tr><td>float</td><td>单精度浮点数</td><td>2</td><td>0~$2^{24}$</td><td>-149~104</td><td>$1.5×10^{-45}$</td><td>$3.4×10^{38}$</td><td>System.Single</td></tr><tr><td>double</td><td>双精度浮点数</td><td>2</td><td>0~$2^{53}$</td><td>-1075~970</td><td>$5.0×10^{-324}$</td><td>$1.7×10^{308}$</td><td>System.Double</td></tr><tr><td>decimal</td><td>16字节浮点数</td><td>10</td><td>0~$2^{96}$</td><td>-28~0</td><td>$1.0×10^{-28}$</td><td>$7.9×10^{28}$</td><td>System.Decimal</td></tr></tbody></table><h4 id="其他简单类型"><a href="#其他简单类型" class="headerlink" title="其他简单类型"></a>其他简单类型</h4><p>除了数值类型以外，还有3种基本类型</p><table><thead><tr><th>类型</th><th>名称</th><th>允许的值</th><th>所属类</th></tr></thead><tbody><tr><td>char</td><td>字符型</td><td>一个Unicode字符，存储0~65535之间的整数</td><td>System.Char</td></tr><tr><td>bool</td><td>布尔型</td><td>布尔值: <code>$true</code> 或 <code>$false</code>(必须加<code>$</code>符号)</td><td>System.Boolean</td></tr><tr><td>enum</td><td>枚举</td><td>限定取值一组命名常量的独特的值类型</td><td>System.Enum</td></tr><tr><td>datetime</td><td>时间型</td><td>包含日期、时间的类型</td><td>System.DateTime</td></tr><tr><td>string</td><td>字符串</td><td>一组字符</td><td>System.String</td></tr></tbody></table><p>注意 <strong>C/C++的 <code>char</code> 仅支持ASCII里面的256个字符, <code>PowerShell</code> 和 <code>C#</code> 的 <code>char</code> 是支持Unicode的</strong>，<strong>PowerShell和C#的<code>string</code>类型并不是继承自 <code>System.ValuType</code> 类，而是继承自 <code>System.Object</code> 类</strong>，因此严格来说 <code>string</code> 类型并非是简单类型。<br><strong>PowerShell的转义字符是 ` 而不是 \</strong>，这也是和C#的一个区别</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用char</span></span><br><span class="line">PS D:/&gt;[char]<span class="variable">$c</span>=<span class="string">"A"</span></span><br><span class="line"><span class="variable">$c</span></span><br><span class="line">A</span><br><span class="line"><span class="comment">#使用bool</span></span><br><span class="line">PS D:/&gt;<span class="variable">$boolean</span>=<span class="literal">$true</span></span><br><span class="line"><span class="variable">$boolean</span></span><br><span class="line">True</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用enum</span></span><br><span class="line">enum fruit</span><br><span class="line">&#123;</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">cherry</span><br><span class="line">durian</span><br><span class="line">&#125;</span><br><span class="line">[fruit]<span class="variable">$en</span>=[fruit]::apple</span><br><span class="line"><span class="variable">$en</span></span><br><span class="line">apple</span><br><span class="line"><span class="variable">$item</span>=<span class="string">"cherry"</span></span><br><span class="line">[fruit]<span class="variable">$enu</span>=[fruit]::(<span class="variable">$item</span>)</span><br><span class="line"><span class="variable">$enu</span></span><br><span class="line">cherry</span><br><span class="line"></span><br><span class="line"><span class="comment">#这种使用方法是错误的</span></span><br><span class="line">PS D:/&gt; [fruit]<span class="variable">$enum</span>=banana</span><br><span class="line"></span><br><span class="line">banana : 无法将“banana”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">12</span></span><br><span class="line">+ [fruit]<span class="variable">$en</span>=banana</span><br><span class="line">+            ~~~~~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (banana:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br><span class="line"></span><br><span class="line"><span class="comment">#当尝试使用非枚举值进行赋值时</span></span><br><span class="line">PS D:/&gt; [fruit]<span class="variable">$en</span>=[fruit]::peach</span><br><span class="line"></span><br><span class="line">由于枚举值无效，无法将 Null 转换为类型“fruit”。请指定以下枚举值之一，然后重试。可能的枚举值为“apple,banana,cherry,durian”。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ [fruit]<span class="variable">$en</span>=[fruit]::peach</span><br><span class="line">+ ~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line">    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException</span><br><span class="line">    + FullyQualifiedErrorId : RuntimeException</span><br><span class="line"></span><br><span class="line">PS D:/&gt; <span class="string">"\n 123 `n 123"</span></span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">\n 123</span></span><br><span class="line"><span class="comment"> 123</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"></span><br><span class="line">PS D:/&gt;<span class="variable">$date</span>=<span class="built_in">get-date</span></span><br><span class="line"><span class="variable">$date</span></span><br><span class="line"><span class="variable">$date</span>.gettype()</span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">2019年3月28日 19:32:30</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">IsPublic IsSerial Name                            BaseType</span></span><br><span class="line"><span class="comment">-------- -------- ----                            --------</span></span><br><span class="line"><span class="comment">True     True     DateTime                        System.ValueType</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><h4 id="赋值和返回值"><a href="#赋值和返回值" class="headerlink" title="赋值和返回值"></a>赋值和返回值</h4><p>赋值操作符为 <code>=</code>，几乎可以把任何数据赋值给一个变量，甚至一条cmdlet命令<br>，因为 <code>PowerShell</code> 支持面向对象，对象可以包罗万象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PS D:\powershell\test&gt; $item=ls</span><br><span class="line">PS D:\powershell\test&gt; $item</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:\powershell\test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----       2017/11/24     12:52            136 4-3.cpp</span><br><span class="line">-a----        2019/3/27     15:13             65 anapple.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:\powershell\test&gt; $item.gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                              BaseType</span><br><span class="line">-------- -------- ----                              --------</span><br><span class="line">True     True     Object[]                          System.Array</span><br><span class="line"></span><br><span class="line">$item为一个对象数组</span><br></pre></td></tr></table></figure><h4 id="弱类型与强类型"><a href="#弱类型与强类型" class="headerlink" title="弱类型与强类型"></a>弱类型与强类型</h4><p>一般对 <code>PowerShell</code> 变量重新赋值时，变量类型会自动改变，这是弱类型语言的特点；<br>而 <code>PowerShell</code> 依托的 .NET是强类型的，所以 <code>PowerShell</code> 可以使用强类型。<br>强类型语言在速度上略逊于弱类型语言，但是强类型定义语言带来的严谨性又能避免不必要的错误。<br>可以在变量前添加类型限定符使该变量变为强类型，可以确保变量的类型不会随着赋值而改变</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[int]<span class="variable">$num</span>=<span class="number">123</span> <span class="comment">#正确</span></span><br><span class="line">[int]<span class="variable">$num</span>=ls <span class="comment">&lt;#错误</span></span><br><span class="line"><span class="comment">无法将“System.Object[]”类型的“System.Object[]”值转换为“System.Int32”类型。</span></span><br><span class="line"><span class="comment">所在位置 行:1 字符: 1</span></span><br><span class="line"><span class="comment">+ [int]$num=ls</span></span><br><span class="line"><span class="comment">+ ~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment">    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException</span></span><br><span class="line"><span class="comment">    + FullyQualifiedErrorId : RuntimeException</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p><code>PowerShell</code> 能够非常方便地将字符串等基本类型转换成期望的类型。之所以神奇，是因为 <code>PowerShell</code> 本身做了很多辛苦的工作，按照优先级：</p><ol><li><strong>直接赋值</strong>：输入类型和期望类型一致，可以直接交付。</li><li><strong>基于语言的类型转换</strong>：当目标类型为<code>void</code>,<code>Boolean</code>,<code>String</code> , <code>Array</code> , <code>Hashtable</code> , <code>PSReference</code> (i.e.: [ref]), <code>XmlDocument</code> , <code>Delegate</code> 和 <code>Enum</code> 时，基于语言的类型转换开始工作。</li><li><strong>Parse 转换</strong>：如果目标类型包含了 <code>Parse()</code> 方法，则采用它。</li><li><strong>Static Create 转换</strong>：如果目标类型包含静态的Create，则采用它。</li><li><strong>构造函数转换</strong>：如果目标类型定义了构造函数，采用它。</li><li><strong>Cast 转换</strong>：如果目标类型定义了从源类型的显式或者隐式的操作符，则采用它。</li><li><strong>IConvertible 接口转换</strong>：如果目标类型实现了支持源类型<code>IConvertible</code> 接口，则采用它。</li><li><strong>IDictionary 转换</strong>：如果源类型是词典或者哈希表，会尝试创建一个实例，然后来填充name和value属性。</li><li><strong>PSObject 属性转换</strong>：如果源类型是<code>PSObject</code>，通过目标类型的默认的构造函数创建一个实例，然后使用<code>PSObject</code>中的属性名称和值来填充实例的属性。</li><li><strong>TypeConverter 转换</strong>：如果存在注册的 <code>TypeConverter</code> 或 <code>PSTypeConverter</code> 来处理转换，则使用它。</li></ol><p>注意<strong>对浮点数向整数进行类型转换时，会自动四舍五入！！</strong><br>如果要C++/C#那种向下取整的方法请使用 <code>[math]::Floor()</code> 函数<br>看几个转换的例子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS D:/test&gt; <span class="variable">$s</span>=<span class="number">12.56</span></span><br><span class="line">PS D:/test&gt; [int]<span class="variable">$s</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line">PS D:/test&gt; [convert]::ToInt32(<span class="variable">$s</span>)</span><br><span class="line"><span class="number">13</span></span><br></pre></td></tr></table></figure><p><code>[convert]::ToInt32()</code> 是 .NET <code>System.Convert</code> 类提供的转换函数<br><code>convert</code> 类中的转换函数格式为:<code>TO</code>+<code>原生类型名()</code>，这里的原生类型名指的是各个类型实际类名<br>常用：</p><ul><li><code>[convert]::ToInt32()</code></li><li><code>[convert]::ToSingle()</code></li><li><code>[convert]::ToDouble()</code></li><li><code>[convert]::ToBoolean()</code></li><li><code>[convert]::ToString()</code></li></ul><p><code>convert</code> 类提供了一系列方法来完成不同变量之间的转换，获得函数列表及使用方法请参考微软的 .NET文档<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.convert?redirectedfrom=MSDN&view=netframework-4.7.2#%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Convert类 方法列表</a></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>注意逻辑运算符和比较运算符的写法,不支持 <code>C#</code> 的<code>&amp;&amp;</code> <code>||</code> <code>！</code> <code>==</code> <code>!=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;=</code>这些运算符</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加 减 乘 除 取余</span></span><br><span class="line">+ - * / %</span><br><span class="line"><span class="comment">#自增、自减运算符，和C#或C++完全一致</span></span><br><span class="line">++<span class="variable">$i</span></span><br><span class="line"><span class="variable">$i</span>++</span><br><span class="line"><span class="variable">$i</span>--</span><br><span class="line">--<span class="variable">$i</span></span><br><span class="line"><span class="comment">#且</span></span><br><span class="line">-and</span><br><span class="line"><span class="comment">#并</span></span><br><span class="line">-or</span><br><span class="line"><span class="comment">#非</span></span><br><span class="line"><span class="nomarkup">-not</span></span><br><span class="line">!</span><br><span class="line"><span class="comment">#样例</span></span><br><span class="line"><span class="literal">$true</span> -and <span class="literal">$false</span> -or <span class="nomarkup">-not</span> <span class="number">0</span></span><br><span class="line">!<span class="literal">$true</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line"><span class="comment">#等于 (equal to)</span></span><br><span class="line"><span class="nomarkup">-eq</span></span><br><span class="line"><span class="comment">#不等于 (not equal to)</span></span><br><span class="line">-nq</span><br><span class="line"><span class="comment">#大于 (greater than)</span></span><br><span class="line"><span class="nomarkup">-gt</span></span><br><span class="line"><span class="comment">#大于等于 (greater than or equal to)</span></span><br><span class="line"><span class="nomarkup">-ge</span></span><br><span class="line"><span class="comment">#小于 (less than)</span></span><br><span class="line"><span class="nomarkup">-lt</span></span><br><span class="line"><span class="comment">#小于等于 (less than or equal to)</span></span><br><span class="line"><span class="nomarkup">-le</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对于字符串类型，可以在比较运算符前加i或c表示是否区分大小写,</span></span><br><span class="line"><span class="comment">#i表示对大小写不敏感，c表示敏感，不写默认不敏感</span></span><br><span class="line"><span class="string">"a"</span> <span class="nomarkup">-eq</span> <span class="string">"A"</span></span><br><span class="line"><span class="string">"a"</span> -ceq <span class="string">"A"</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"><span class="comment">#判断变量是否为兼容类型(同一类型或其父类型)，类型格式为 [类型名]</span></span><br><span class="line">-is</span><br><span class="line"><span class="comment">#示例</span></span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span></span><br><span class="line"><span class="variable">$a</span> -is [int]</span><br><span class="line"><span class="variable">$b</span>=<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line"><span class="variable">$b</span> -is [array]</span><br><span class="line"><span class="variable">$a</span> -is [ValueType]</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">True <span class="comment"># System.Int32类继承自System.ValueType类，因此int是其父类型ValueType的子类型</span></span><br></pre></td></tr></table></figure><hr><h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h4><p><code>if</code> 和 <code>else</code> 用法和C#完全一样，除了大括号不允许省略，多分支时还多了个<code>elseif</code> 可用，和<code>Python</code> 的 <code>elif</code> 作用相同</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">$true</span> -and <span class="literal">$true</span>) &#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span>(<span class="variable">$a</span> <span class="nomarkup">-eq</span> <span class="variable">$b</span>) &#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="variable">$a</span>=<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><p>PowerShell的<code>switch</code>非常灵活，使用起来较为方便<br>相对C#或C++，PowerShell的switch不需要写`case:``，但是必须写大括号</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="string">"Beijing"</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="variable">$a</span>) </span><br><span class="line">&#123;</span><br><span class="line"><span class="string">"Beijing"</span> &#123;<span class="variable">$res</span>=<span class="string">"北京"</span>&#125;</span><br><span class="line"><span class="string">"Shanghai"</span> &#123;<span class="variable">$res</span>=<span class="string">"上海"</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认比较运算符为<code>-eq</code>，你也可以使用下面的例子自定义比较条件，必须保证表达式返回boolen类型($true和$false)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$v</span>=<span class="number">18</span></span><br><span class="line"><span class="keyword">switch</span>(<span class="variable">$v</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="variable">$_</span> <span class="nomarkup">-lt</span> <span class="number">10</span>&#125; &#123;<span class="string">"小于10"</span>&#125; <span class="comment"># $_ 表示当前的传入的变量 直接写的字符串会被输出</span></span><br><span class="line"><span class="number">10</span> &#123;<span class="string">"等于10"</span>&#125;</span><br><span class="line">&#123;<span class="variable">$_</span> <span class="nomarkup">-gt</span> <span class="number">10</span>&#125; &#123;<span class="string">"小于10"</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">大于10</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>接下来介绍循环</p><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p><code>PowerShell</code> 的 <code>for</code> 循环类似于<code>C#</code>，看一个样例:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> <span class="nomarkup">-lt</span> <span class="number">10</span>;<span class="variable">$i</span>++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">Write-Output</span> <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h4><p><code>Do</code> 和 <code>While</code> 可能产生死循环，为了防止死循环的发生，因此我们必须确切的指定循环终止的条件。指定了循环终止的条件后，一旦条件不满足就会退出循环。<br><code>do-while()</code> 会先执行再去判断，能保证循环至少执行一次。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="variable">$n</span>=<span class="built_in">Read-Host</span> <span class="string">"请输入数字"</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="nomarkup">-ne</span> <span class="number">0</span>)</span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">请输入数字: 1</span></span><br><span class="line"><span class="comment">请输入数字: 2</span></span><br><span class="line"><span class="comment">请输入数字: s</span></span><br><span class="line"><span class="comment">请输入数字: 0</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><h5 id="只使用while"><a href="#只使用while" class="headerlink" title="只使用while"></a>只使用while</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span>=<span class="number">5</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="nomarkup">-gt</span> <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$n</span></span><br><span class="line">    <span class="variable">$n</span>=<span class="variable">$n</span>-<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h5><p>使用 <code>continue</code> 关键字，可以终止当前循环，跳过 <code>continue</code> 后其它语句，重新下一次循环。<br>跳出循环语句使用 <code>break</code> 关键字</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$n</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="nomarkup">-lt</span> <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$n</span> <span class="nomarkup">-eq</span> <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$n</span>=<span class="variable">$n</span>+<span class="number">1</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$n</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$n</span>=<span class="variable">$n</span>+<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="variable">$n</span>=<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="variable">$n</span> <span class="nomarkup">-lt</span> <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$n</span> <span class="nomarkup">-eq</span> <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$n</span></span><br><span class="line">    <span class="variable">$n</span>++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一种循环 <code>foreach</code> ，等到我们讲到数组再说</p><hr><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><p>在 <code>PowerShell</code> 中创建数组可以使用逗号</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span>=<span class="number">2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>对于连续的数字数组可以使用一个更快捷的方法:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span>=<span class="number">1</span>..<span class="number">5</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h5 id="对象数组的多态"><a href="#对象数组的多态" class="headerlink" title="对象数组的多态"></a>对象数组的多态</h5><p>像变量一样，如果数组中元素的类型为弱类型，默认可以存储不同类型的值。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$array</span>=<span class="number">1</span>,<span class="string">"2019"</span>,([Guid]::NewGuid()),(<span class="built_in">get-date</span>)</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$array</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2019</span></span><br><span class="line"></span><br><span class="line">Guid</span><br><span class="line">----</span><br><span class="line">ea5f17c6-c0a2-<span class="number">42</span>ba-<span class="number">9</span>de4-e4d03bebffaf</span><br><span class="line"></span><br><span class="line">DisplayHint : DateTime</span><br><span class="line">Date        : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">29</span> <span class="number">0</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">Day         : <span class="number">29</span></span><br><span class="line">DayOfWeek   : Friday</span><br><span class="line">DayOfYear   : <span class="number">88</span></span><br><span class="line">Hour        : <span class="number">23</span></span><br><span class="line">Kind        : Local</span><br><span class="line">Millisecond : <span class="number">120</span></span><br><span class="line">Minute      : <span class="number">23</span></span><br><span class="line">Month       : <span class="number">3</span></span><br><span class="line">Second      : <span class="number">39</span></span><br><span class="line">Ticks       : <span class="number">636894986191207086</span></span><br><span class="line">TimeOfDay   : <span class="number">23</span>:<span class="number">23</span>:<span class="number">39.1207086</span></span><br><span class="line">Year        : <span class="number">2019</span></span><br><span class="line">DateTime    : <span class="number">2019</span>年<span class="number">3</span>月<span class="number">29</span>日 <span class="number">23</span>:<span class="number">23</span>:<span class="number">39</span></span><br><span class="line"></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$array</span>|<span class="keyword">foreach</span>&#123;<span class="variable">$_</span>.gettype()&#125;</span><br><span class="line"><span class="comment">#查看数组各元素类型</span></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     Int32                                    System.ValueType</span><br><span class="line">True     True     String                                   System.Object</span><br><span class="line">True     True     Guid                                     System.ValueType</span><br><span class="line">True     True     DateTime                                 System.ValueType</span><br></pre></td></tr></table></figure><h5 id="空数组和单元素数组"><a href="#空数组和单元素数组" class="headerlink" title="空数组和单元素数组"></a>空数组和单元素数组</h5><p>对数组元素可以查看它的公有属性，比如长度<br>只需要输入<code>$数组名.Count</code>即可显示数组长度</p><h6 id="空数组"><a href="#空数组" class="headerlink" title="空数组"></a>空数组</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$a</span>=@()</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$a</span> -is [array]</span><br><span class="line">True</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$a</span>.Count</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h6 id="单元素数组"><a href="#单元素数组" class="headerlink" title="单元素数组"></a>单元素数组</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:Powershell&gt; <span class="variable">$a</span>=,<span class="string">"moss"</span></span><br><span class="line">PS C:Powershell&gt; <span class="variable">$a</span> -is [array]</span><br><span class="line">True</span><br><span class="line">PS C:Powershell&gt; <span class="variable">$a</span>.Count</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h4><h5 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h5><h6 id="直接法"><a href="#直接法" class="headerlink" title="直接法"></a>直接法</h6><p>将数组作为单独一行将会自动遍历这个数组的所有元素</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS C:/&gt; <span class="variable">$a</span>=<span class="number">1</span>..<span class="number">10</span></span><br><span class="line">PS C:/&gt; <span class="variable">$a</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h6 id="for-循环遍历"><a href="#for-循环遍历" class="headerlink" title="for 循环遍历"></a><code>for</code> 循环遍历</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS C:/&gt; <span class="variable">$a</span>=<span class="number">1</span>..<span class="number">5</span></span><br><span class="line">PS C:/&gt; <span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> <span class="nomarkup">-lt</span> <span class="number">5</span>;<span class="variable">$i</span>++) &#123;</span><br><span class="line">&gt;&gt; <span class="variable">$a</span>[<span class="variable">$i</span>] &#125;</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="foreach-遍历法"><a href="#foreach-遍历法" class="headerlink" title="foreach 遍历法"></a><code>foreach</code> 遍历法</h6><p>还有一种遍历的方法，用到了之前提到的 <code>foreach</code> 语句<br>意思是使用变量 <code>$n</code> 对 <code>$a</code> 元素进行迭代，这实际上是一种对可迭代对象的访问算法<br>在 <code>C#</code> 也有这种语法</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span>=<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$n</span> <span class="keyword">in</span> <span class="variable">$a</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$n</span>+<span class="string">" "</span>+<span class="variable">$n</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">A A</span><br><span class="line">B B</span><br><span class="line">C C</span><br><span class="line">D D</span><br><span class="line">E E</span><br></pre></td></tr></table></figure><p><code>foreach</code>还有一种遍历的写法</p><p>这里我们需要先了解一下<strong>管道</strong><br>管道的符号 |<br>管道允许将它左侧命令的输出结果发送到右侧做命令的参数<br>管道并不是什么新事物，以前的Cmd控制台也有重定向的命令，例如Dir | More可以将结果分屏显示。<br>传统的Cmd管道是基于文本的，但是 <code>PowerShell</code> 是基于对象的</p><p>列出当前目录下的目录和文件，然后根据文件名降序排列，再投影(数据库术语)文件名，文件大小，文件的修改时间:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS D:/test&gt; ls | <span class="built_in">Sort-Object</span> -Descending Name | <span class="built_in">Select-Object</span> Name,Length,LastWriteTime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:/test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Name        Length LastWriteTime</span><br><span class="line">----        ------ -------------</span><br><span class="line">out.txt        <span class="number">523</span> <span class="number">2019</span>/<span class="number">2</span>/<span class="number">24</span> <span class="number">22</span>:<span class="number">46</span>:<span class="number">35</span></span><br><span class="line">lang.json     <span class="number">6415</span> <span class="number">2019</span>/<span class="number">2</span>/<span class="number">16</span> <span class="number">23</span>:<span class="number">49</span>:<span class="number">24</span></span><br><span class="line">anapple.txt     <span class="number">65</span> <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">15</span>:<span class="number">13</span>:<span class="number">52</span></span><br><span class="line"><span class="number">4</span>-<span class="number">3</span>.cpp        <span class="number">136</span> <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">52</span>:<span class="number">28</span></span><br></pre></td></tr></table></figure><p>可迭代对象(比如数组)可以由管道送到一些命令上进一步处理<br><code>foreach</code>就可以接受管道送来的可迭代对象，并进行遍历</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$array</span>=<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span></span><br><span class="line"><span class="variable">$array</span>|<span class="keyword">foreach</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$_</span>+<span class="string">"s"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">As</span><br><span class="line">Bs</span><br><span class="line">Cs</span><br><span class="line">Ds</span><br><span class="line">Es</span><br></pre></td></tr></table></figure><h5 id="将数组逆序输出"><a href="#将数组逆序输出" class="headerlink" title="将数组逆序输出"></a>将数组逆序输出</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>=<span class="string">"A1"</span>,<span class="string">"B2"</span>,<span class="string">"C3"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>[(<span class="variable">$books</span>.Count)..<span class="number">0</span>]</span><br><span class="line">C3</span><br><span class="line">B2</span><br><span class="line">A1</span><br></pre></td></tr></table></figure><h5 id="访问某些元素"><a href="#访问某些元素" class="headerlink" title="访问某些元素"></a>访问某些元素</h5><p>与C#相同，数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是 <code>PowerShell</code> 为了使用方便，直接可以将 -1 作为最后的一个元素的索引(参考了 <code>Python</code> 的语法)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>=<span class="string">"1A"</span>,<span class="string">"2B"</span>,<span class="string">"3C"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span>A</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span>B</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>[(<span class="variable">$book</span>.Count-<span class="number">1</span>)]</span><br><span class="line"><span class="number">3</span>C</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>[-<span class="number">1</span>]</span><br><span class="line"><span class="number">3</span>C</span><br></pre></td></tr></table></figure><h5 id="从数组中选择多个元素"><a href="#从数组中选择多个元素" class="headerlink" title="从数组中选择多个元素"></a>从数组中选择多个元素</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$result</span>=ls</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$result</span>[<span class="number">0</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">12</span>]</span><br><span class="line">    Directory: C:Powershell</span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime     Length Name</span><br><span class="line">----                -------------     ------ ----</span><br><span class="line">d----        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">23</span>     <span class="number">17</span>:<span class="number">25</span>            ABC</span><br><span class="line">-a---        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">20</span>:<span class="number">04</span>      <span class="number">26384</span> a.txt</span><br><span class="line">-a---        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">20</span>:<span class="number">27</span>      <span class="number">12060</span> alias.ps1</span><br><span class="line">-a---        <span class="number">2011</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">17</span>:<span class="number">37</span>       <span class="number">7420</span> name.html</span><br></pre></td></tr></table></figure><h5 id="给数组添加元素"><a href="#给数组添加元素" class="headerlink" title="给数组添加元素"></a>给数组添加元素</h5><p>因为PowerShell数组在内存中是顺序存储的，所以数组的大小必须是确定的，这样才方便分配存储空间，所以给数组增加元素其实相当于创建一个新的数组，只不过之后会把原来的副本删除。在当前数组追加元素可以使用 <code>+=</code> 操作符。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>=<span class="string">"A1"</span>,<span class="string">"B2"</span>,<span class="string">"C3"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span>+=<span class="string">"D4"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$books</span></span><br><span class="line">A1</span><br><span class="line">B2</span><br><span class="line">C3</span><br><span class="line">D4</span><br></pre></td></tr></table></figure><h5 id="删除指定位置元素"><a href="#删除指定位置元素" class="headerlink" title="删除指定位置元素"></a>删除指定位置元素</h5><p>采用截断重连法删除指定元素</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$num</span>=<span class="number">1</span>..<span class="number">4</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$num</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$num</span>=<span class="variable">$num</span>[<span class="number">0</span>..<span class="number">1</span>]+<span class="variable">$num</span>[<span class="number">3</span>] <span class="comment">#相当于删掉了第三项</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$num</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="复制数组"><a href="#复制数组" class="headerlink" title="复制数组"></a>复制数组</h4><p>数组属于引用类型，使用默认的的赋值运算符在两个变量之间赋值只是复制了一个引用，两个变量共享同一份数据。这样的模式有一个弊病如果其中一个改变也会株连到另外一个。所以复制数组最好使用 <code>Clone()</code> 方法( <code>System.Array</code> 类的成员函数)，除非有特殊需求。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$chs</span>=@(<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>)</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chsBak</span>=<span class="variable">$chs</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chsBak</span>[<span class="number">1</span>]=<span class="string">"H"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chs</span></span><br><span class="line">A</span><br><span class="line">H</span><br><span class="line">C</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chs</span>.Equals(<span class="variable">$chsBak</span>)</span><br><span class="line">True</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chsNew</span>=<span class="variable">$chs</span>.Clone()</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chsNew</span>[<span class="number">1</span>]=<span class="string">"Good"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chs</span>.Equals(<span class="variable">$chsNew</span>)</span><br><span class="line">False</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$chs</span></span><br><span class="line">A</span><br><span class="line">H</span><br><span class="line">C</span><br></pre></td></tr></table></figure><h4 id="强类型数组"><a href="#强类型数组" class="headerlink" title="强类型数组"></a>强类型数组</h4><p><code>PowerShell</code> 数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常，这样的数组被称为强类型数组<br>定义方法<code>[类型[]]$数组名=初值</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; [int[]] <span class="variable">$nums</span>=@()</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="number">2012</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="number">12.3</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="string">"999"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$nums</span>+=<span class="string">"can not convert"</span></span><br><span class="line">Cannot convert value <span class="string">"can not convert"</span> to type <span class="string">"System.Int32"</span>. Error: <span class="string">"Input string was not in a correct format."</span></span><br><span class="line">At line:<span class="number">1</span> char:<span class="number">6</span></span><br><span class="line">+ <span class="variable">$nums</span> &lt;&lt;&lt;&lt; +=<span class="string">"can not convert"</span></span><br><span class="line">    + CategoryInfo          : MetadataError: (:) [], ArgumentTransformationMetadataException</span><br><span class="line">    + FullyQualifiedErrorId : RuntimeException</span><br></pre></td></tr></table></figure><h4 id="命令返回数组"><a href="#命令返回数组" class="headerlink" title="命令返回数组"></a>命令返回数组</h4><p>当我们把一个命令的执行结果保存到一个变量中，可能会认为变量存放的是纯文本。<br>但是，事实上 <code>PowerShell</code> 会把文本按每一行作为元素存为数组。如果一个命令的返回值不止一个结果时， <code>PowerShell</code> 也会自动把结果存储为数组</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$IPcfg</span>=ipconfig</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$IPcfg</span></span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Windows IP 配置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以太网适配器 以太网:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . : lan</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无线局域网适配器 本地连接* 1:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   媒体状态  . . . . . . . . . . . . : 媒体已断开连接</span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无线局域网适配器 本地连接* 2:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . :</span></span><br><span class="line"><span class="comment">   本地链接 IPv6 地址. . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   IPv4 地址 . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   子网掩码  . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   默认网关. . . . . . . . . . . . . :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">以太网适配器 VMware Network Adapter VMnet8:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . :</span></span><br><span class="line"><span class="comment">   本地链接 IPv6 地址. . . . . . . . : fe80::f88d:cd97:5343:9713%16</span></span><br><span class="line"><span class="comment">   IPv4 地址 . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   子网掩码  . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   默认网关. . . . . . . . . . . . . :</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">无线局域网适配器 WLAN:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   连接特定的 DNS 后缀 . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   本地链接 IPv6 地址. . . . . . . . : fe80::954:3964:3731:997e%18</span></span><br><span class="line"><span class="comment">   IPv4 地址 . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   子网掩码  . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">   默认网关. . . . . . . . . . . . . : ****</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$IPcfg</span>.Count</span><br><span class="line"><span class="number">37</span></span><br></pre></td></tr></table></figure><h5 id="使用数组存储结果"><a href="#使用数组存储结果" class="headerlink" title="使用数组存储结果"></a>使用数组存储结果</h5><p>判断一个变量是否为数组</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:/Powershell&gt; <span class="variable">$ip</span>=ipconfig</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$ip</span> -is [array]</span><br><span class="line">True</span><br><span class="line">PS C:/Powershell&gt; <span class="string">"abac"</span> -is [array]</span><br><span class="line">False</span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$str</span>=<span class="string">"字符串"</span></span><br><span class="line">PS C:/Powershell&gt; <span class="variable">$str</span>.ToCharArray() -is [array] <span class="comment">#转换为字符数组</span></span><br><span class="line">True</span><br></pre></td></tr></table></figure><h5 id="使用真实的对象操作"><a href="#使用真实的对象操作" class="headerlink" title="使用真实的对象操作"></a>使用真实的对象操作</h5><p>为什么不愿把IPconfig返回的结果称为对象，因为它不是真正Cmdlet命令(事实上ipconfig是一个单独的程序)，真正的 <code>PowerShell</code> 命令返回的数组元素可不止一个字符串，它是一个内容丰富的对象。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">PS D:/test&gt; <span class="variable">$list</span>=ls</span><br><span class="line">PS D:/test&gt; <span class="variable">$list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    目录: D:/test</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">-a----       <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span>     <span class="number">12</span>:<span class="number">52</span>            <span class="number">136</span> <span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">-a----        <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span>     <span class="number">15</span>:<span class="number">13</span>             <span class="number">65</span> anapple.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:/test&gt; <span class="variable">$list</span>.gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     Object[]                                 System.Array</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PS D:/test&gt; <span class="keyword">foreach</span>(<span class="variable">$i</span> <span class="keyword">in</span> <span class="variable">$list</span>)&#123;<span class="variable">$i</span>.name&#125;</span><br><span class="line"><span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">anapple.txt</span><br><span class="line"></span><br><span class="line">PS D:/test&gt; <span class="variable">$list</span>[<span class="number">0</span>].gettype()</span><br><span class="line"></span><br><span class="line">IsPublic IsSerial Name                                     BaseType</span><br><span class="line">-------- -------- ----                                     --------</span><br><span class="line">True     True     FileInfo                                 System.IO.FileSystemInfo</span><br></pre></td></tr></table></figure><p>上面的例子中数组的每一个元素存放的是一个 <code>System.IO.DirectoryInfo</code> 对象。<br>当我们输出这些对象时，<code>PowerShell</code> 会自动帮我们把它转换成友好的文本格式。<br>对于任何一个对象都可以使用 <code>Format-List *</code> 来查看它所有的属性和方法。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">PS D:/test&gt; <span class="variable">$list</span>[<span class="number">0</span>]|fl * </span><br><span class="line"><span class="comment"># "|"符号是管道符，将左边返回结果做参数发送到右侧，fl是Format-List的简称</span></span><br><span class="line"></span><br><span class="line">PSPath            : Microsoft.PowerShell.Core\FileSystem::D:test\<span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">PSParentPath      : Microsoft.PowerShell.Core\FileSystem::D:\test</span><br><span class="line">PSChildName       : <span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">PSDrive           : D</span><br><span class="line">PSProvider        : Microsoft.PowerShell.Core\FileSystem</span><br><span class="line">PSIsContainer     : False</span><br><span class="line">Mode              : -a----</span><br><span class="line">VersionInfo       : File:             D:\test\<span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">                    InternalName:</span><br><span class="line">                    OriginalFilename:</span><br><span class="line">                    FileVersion:</span><br><span class="line">                    FileDescription:</span><br><span class="line">                    Product:</span><br><span class="line">                    ProductVersion:</span><br><span class="line">                    Debug:            False</span><br><span class="line">                    Patched:          False</span><br><span class="line">                    PreRelease:       False</span><br><span class="line">                    PrivateBuild:     False</span><br><span class="line">                    SpecialBuild:     False</span><br><span class="line">                    Language:</span><br><span class="line"></span><br><span class="line">BaseName          : <span class="number">4</span>-<span class="number">3</span></span><br><span class="line">Target            : &#123;&#125;</span><br><span class="line">LinkType          :</span><br><span class="line">Name              : <span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">Length            : <span class="number">136</span></span><br><span class="line">DirectoryName     : D:\test</span><br><span class="line">Directory         : D:\test</span><br><span class="line">IsReadOnly        : False</span><br><span class="line">Exists            : True</span><br><span class="line">FullName          : D:\test\<span class="number">4</span>-<span class="number">3</span>.cpp</span><br><span class="line">Extension         : .cpp</span><br><span class="line">CreationTime      : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">CreationTimeUtc   : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">7</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">LastAccessTime    : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">15</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">LastAccessTimeUtc : <span class="number">2019</span>/<span class="number">3</span>/<span class="number">27</span> <span class="number">7</span>:<span class="number">07</span>:<span class="number">32</span></span><br><span class="line">LastWriteTime     : <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span> <span class="number">12</span>:<span class="number">52</span>:<span class="number">28</span></span><br><span class="line">LastWriteTimeUtc  : <span class="number">2017</span>/<span class="number">11</span>/<span class="number">24</span> <span class="number">4</span>:<span class="number">52</span>:<span class="number">28</span></span><br><span class="line">Attributes        : Archive</span><br></pre></td></tr></table></figure><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是自定义的 <code>Powershell</code> 代码，有三个原则：  </p><ul><li><strong>简短</strong>：函数名简短，并且显而易见。  </li><li><strong>聚合</strong>：函数可以完成多个操作。  </li><li><strong>封装和扩展</strong>：将一批 <code>Powershell</code> 语句进行封装，实现全新的功能需求。<br>函数的结构由三部分组成：函数名，参数，函数体</li></ul><h4 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h4><h5 id="脚本中函数的定义方法"><a href="#脚本中函数的定义方法" class="headerlink" title="脚本中函数的定义方法"></a>脚本中函数的定义方法</h5><p>函数可以在文本编辑器上编写，写完以后复制进 <code>PowerShell</code> 控制台即可。如果控制台设置为快速编辑模式，从记事本复制后，直接在控制台鼠标右键即可完成粘贴(Windows 10默认开启了快速编辑模式)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> FuncName(args[]) <span class="comment">#括号可省略</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">&lt;#代码段#&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="控制台上多行输入定义函数"><a href="#控制台上多行输入定义函数" class="headerlink" title="控制台上多行输入定义函数"></a>控制台上多行输入定义函数</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS C:/PowerShell&gt; <span class="keyword">function</span> MyPing</span><br><span class="line">&gt;&gt; &#123;</span><br><span class="line">&gt;&gt; PING.EXE  -n <span class="number">1</span> <span class="variable">$args</span></span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line">PS C:/PowerShell&gt;</span><br></pre></td></tr></table></figure><h5 id="把函数精简成一行"><a href="#把函数精简成一行" class="headerlink" title="把函数精简成一行"></a>把函数精简成一行</h5><p>我们可以将一个函数定义在一行上，但是这样阅读和理解起来就不方便，所以要在每条命令后加分号进行分割(最后一句可以不写<code>;</code>)</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:/PowerShell&gt; <span class="keyword">function</span> cd...&#123; cd.. ; cd.. &#125;</span><br><span class="line">PS C:/PowerShell&gt; cd...</span><br></pre></td></tr></table></figure><h5 id="使用函数作为别名"><a href="#使用函数作为别名" class="headerlink" title="使用函数作为别名"></a>使用函数作为别名</h5><p>假如 <code>PowerShell</code> 不支持 <code>Get-SystemVersion</code> 命令，你可以通过定义函数实现这个功能：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> get-systemversion</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$psversiontable</span>.BuildVersion</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Get-SystemVersion</span><br><span class="line"></span><br><span class="line">Major  Minor  Build  Revision</span><br><span class="line">-----  -----  -----  --------</span><br><span class="line"><span class="number">10</span>     <span class="number">0</span>      <span class="number">17134</span>  <span class="number">590</span></span><br></pre></td></tr></table></figure><h5 id="更新函数"><a href="#更新函数" class="headerlink" title="更新函数"></a>更新函数</h5><p>如果要更新已经定义好的函数，简单的方法是重新定义，这样新的定义会覆盖旧的定义。但是如果函数代码没有保存副本，可以先将函数定义导出到ps文件，然后就可以编辑了。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PS C:/PowerShell&gt; <span class="keyword">function</span> MyPing</span><br><span class="line">&gt;&gt; &#123;</span><br><span class="line">&gt;&gt; PING.EXE  -n <span class="number">1</span> <span class="variable">$args</span></span><br><span class="line">&gt;&gt; &#125;</span><br><span class="line"></span><br><span class="line">PS C:/PowerShell&gt; <span class="variable">$function:MyPing</span> | <span class="built_in">Out-File</span> myPing.ps1</span><br><span class="line">PS C:/PowerShell&gt; <span class="variable">$function:MyPing</span></span><br><span class="line"></span><br><span class="line">PING.EXE  -n <span class="number">1</span> <span class="variable">$args</span></span><br><span class="line"></span><br><span class="line">PS C:/PowerShell&gt; <span class="variable">$function:MyPing</span> | <span class="built_in">Out-File</span> myPing.ps1</span><br><span class="line">PS C:/PowerShell&gt; .myPing.ps1</span><br><span class="line">必须指定 IP 地址。</span><br><span class="line">PS C:/PowerShell&gt; notepad.exe $$</span><br></pre></td></tr></table></figure><h5 id="删除函数"><a href="#删除函数" class="headerlink" title="删除函数"></a>删除函数</h5><p>控制台定义的函数只会在当前会话生效，一旦控制台退出，会自动消失。在不关闭控制台的条件下删除一个已经定义好的函数，可是使用虚拟驱动器的方法：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> cc&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">PS C:/&gt; cc</span><br><span class="line">hello</span><br><span class="line">PS C:/&gt; del <span class="keyword">function</span>:cc</span><br><span class="line">PS C:/&gt; cc</span><br><span class="line">cc : 无法将“cc”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">1</span></span><br><span class="line">+ cc</span><br><span class="line">+ ~~</span><br><span class="line">    + CategoryInfo          : ObjectNotFound: (cc:String) [], CommandNotFoundException</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br></pre></td></tr></table></figure><h4 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h4><p>用于脚本文件的编写</p><h5 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h5><p>PowerShell提供了 <code>Read-Host</code> 命令，可以接收返回用户在控制台输入的字符</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span>=<span class="built_in">read-host</span> <span class="string">"请输入你的名字"</span> </span><br><span class="line"><span class="comment">#会把提示信息打印到PS控制台，也可以不写提示信息</span></span><br><span class="line"><span class="comment">&lt;#执行+输入 结果:</span></span><br><span class="line"><span class="comment">请输入你的名字: Nougat </span></span><br><span class="line"><span class="comment">#&gt;</span></span><br><span class="line"><span class="variable">$name</span></span><br><span class="line">Nougat</span><br></pre></td></tr></table></figure><p>注意到</p><ol><li>提示信息(如果有)后面自动加了个冒号；</li><li>用户键入任何信息都被作为该命令的返回结果；</li><li>可以把键入的信息传递给一个变量；</li></ol><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><p>有两种输出命令<br><code>Write-Host</code>和<code>Write-Output</code><br>若输出字符串不包含空白字符可以不加引号</p><h6 id="Write-Host"><a href="#Write-Host" class="headerlink" title="Write-Host"></a><code>Write-Host</code></h6><p>当需要展示一个特定信息，比如使用其他颜色来吸引人们的注意力的时候，可使用 <code>Write-Host</code> 命令<br> <code>Write-Host</code> 和其他Cmdlets一样使用管道，但是它不放置任何数据道管道中。反而会直接写到宿主应用程序的界面。正如此，可以使用<code>-ForegroundColor</code> 和 <code>-BackgroundColor</code> 参数将前景和背景设置为其他颜色：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write-host</span> <span class="string">"啊哈"</span> -ForegroundColor White -BackgroundColor Red</span><br><span class="line">啊哈</span><br></pre></td></tr></table></figure><p>注：<strong>不是每个使用PowerShell的应用程序都支持其他颜色，也并不是每个应用程序都支持所有颜色</strong>。该输出方法<strong>不适用于常规的输出结果</strong>，因为 <code>Write-Host</code> 命令输出到屏幕的任何东西都无法被捕捉。若执行远程命令或无人值守命令(纯自动化)， <code>Write-Host</code> 可能不会按照你的预期工作。因此，此命令仅仅用于与人进行直接交互。</p><h6 id="Write-Output"><a href="#Write-Output" class="headerlink" title="Write-Output"></a><code>Write-Output</code></h6><p><code>Write-Output</code>命令会将对象发送给管道。由于它不会直接发送到显示界面，所以不允许你指定其他任何的颜色。</p><p>它是<code>PowerShell</code>默认使用的一个Cmdlets，默认输出方式即使用该命令，即使你没有指定，<code>PowerShell</code>会在底层将信息传递给<code>Write-Output</code>命令(就是一行直接写一个变量就能直接输出的情况)，另外这个命令还有两个别名 <code>write</code> 和 <code>echo</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write-host</span> ACB <span class="comment">#无空白字符可以不写引号 </span></span><br><span class="line">ACB</span><br><span class="line">write <span class="string">"ABC"</span></span><br><span class="line">ABC</span><br><span class="line">echo <span class="string">"ABD"</span></span><br><span class="line">ABD</span><br></pre></td></tr></table></figure><p><code>Write-Output</code>输出基本过程为：</p><blockquote><ol><li><code>Write-Output</code>命令将<code>string</code>类型的对象<code>Hello World!</code>放入管道中；</li><li>管道中只有这个<code>string</code>对象，其会直接到达管道的末端，也就是<code>Out-Default</code>命令；</li><li><code>Out-Default</code>命令将对象传递给<code>Out-Host</code>命令；</li><li><code>Out-Host</code>命令要求<code>PowerShell</code>的格式化系统格式化该对象。</li><li><code>Out-Host</code>将格式化的结果集放在显示界面上</li></ol></blockquote><p>还有一点，在输出多个对象时，<code>Write-Host</code>会以空格隔开各对象<br><code>Write-Output</code>会以换行隔开各对象</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write-host</span> <span class="string">"ABC"</span> <span class="string">"23232"</span></span><br><span class="line">ABC <span class="number">23232</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">write-output</span> <span class="string">"ABC"</span> <span class="string">"23232"</span></span><br><span class="line">ABC </span><br><span class="line"><span class="number">23232</span></span><br></pre></td></tr></table></figure><h6 id="其他的输出方式"><a href="#其他的输出方式" class="headerlink" title="其他的输出方式"></a>其他的输出方式</h6><p><code>Write-Warning/Verbose/Debug/Error</code></p><p>具体参考：<a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.utility/write-debug?view=powershell-3.0" target="_blank" rel="noopener">微软官方文档</a></p><h4 id="处理函数参数"><a href="#处理函数参数" class="headerlink" title="处理函数参数"></a>处理函数参数</h4><p><code>PowerShell</code> 函数可以接受参数，并对参数进行处理。函数的参数有3个特性：</p><ol><li>任意参数：内部变量<code>$args</code> 接受函数调用时接受的参数，<code>$args</code>是一个数组类型；</li><li>命名参数：函数的每一个参数可以分配一个名称，在调用时通过名称指定对应的参数；</li><li>预定义参数：函数在定义参数时可以指定默认值，如果调用时没有专门指定参数的值，就会保持默认值；</li></ol><h5 id="args-万能参数"><a href="#args-万能参数" class="headerlink" title="$args 万能参数"></a>$args 万能参数</h5><p>给一个函数定义参数最简单的是使用<code>$args</code>这个内置的参数。它可以识别任意个参数。尤其适用那些参数可有可无的函数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> sayHello</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$args</span>.Count <span class="nomarkup">-eq</span> <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"No argument!"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$args</span> | <span class="keyword">foreach</span> &#123;<span class="string">"Hello,$(<span class="variable">$_</span>)"</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#无参调用</span></span><br><span class="line">sayhello</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">No argument!</span><br><span class="line"></span><br><span class="line"><span class="comment">#一参调用</span></span><br><span class="line">sayhello <span class="string">"World!"</span> <span class="comment">#也可以写成sayhello("World!")</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">Hello,World!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#多参数调用</span></span><br><span class="line"><span class="variable">$str</span>=<span class="string">"it's me."</span></span><br><span class="line">sayhello <span class="number">123</span> <span class="string">"aha"</span> <span class="variable">$str</span> <span class="comment">#如果字符串不包含空白字符(比如空格)，引号可以不写</span></span><br><span class="line"><span class="comment">&lt;#输出</span></span><br><span class="line"><span class="comment">Hello,123</span></span><br><span class="line"><span class="comment">Hello,aha</span></span><br><span class="line"><span class="comment">Hello,it's me.</span></span><br><span class="line"><span class="comment">#&gt;</span></span><br></pre></td></tr></table></figure><p>因为 <code>$arg</code> 是一个数组,可以用它很方便的写出求和函数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Add</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$sum</span>=<span class="number">0</span></span><br><span class="line"><span class="variable">$args</span> | <span class="keyword">foreach</span> &#123;<span class="variable">$sum</span>=<span class="variable">$sum</span>+<span class="variable">$_</span>&#125;</span><br><span class="line"><span class="variable">$sum</span></span><br><span class="line">&#125;</span><br><span class="line">Add <span class="number">10</span> <span class="number">7</span> <span class="number">3</span> <span class="number">100</span></span><br><span class="line"><span class="comment">#120</span></span><br></pre></td></tr></table></figure><h5 id="使用固定参数"><a href="#使用固定参数" class="headerlink" title="使用固定参数"></a>使用固定参数</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> StringContact(<span class="variable">$str1</span>,<span class="variable">$str2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str1</span>+<span class="variable">$str2</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">StringContact LN P</span><br><span class="line"><span class="comment">#StringContact -str1 word -str2 press</span></span><br><span class="line"><span class="comment">#StringContact("word","press")</span></span><br><span class="line">LNP</span><br><span class="line">wordpress</span><br></pre></td></tr></table></figure><h5 id="给参数定义默认值"><a href="#给参数定义默认值" class="headerlink" title="给参数定义默认值"></a>给参数定义默认值</h5><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> stringContact(<span class="variable">$str1</span>=<span class="string">"LN"</span>,<span class="variable">$str2</span>=<span class="string">"P"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$str1</span>+<span class="variable">$str2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stringContact</span><br><span class="line">LNP</span><br></pre></td></tr></table></figure><h5 id="使用强类型参数"><a href="#使用强类型参数" class="headerlink" title="使用强类型参数"></a>使用强类型参数</h5><p>通过之前的例子发现将用户的参数传递给函数显得比较混乱。罪魁祸首就是<code>PowerShell</code>的参数解释器，它可以自动处理和分配参数给函数。<br>函数的参数解释器比较傲慢，它对你提供的参数的信息完全不关心。它只会粗略地将参数进行分割，并且最大限度的进行自动类型转换。事实上，这种类型转换很多时候并不完美。所以<strong>最好提前能够对参数进行强类型限制</strong></p><h5 id="限制数字类型"><a href="#限制数字类型" class="headerlink" title="限制数字类型"></a>限制数字类型</h5><p>下面的函数执行后，会抛出异常<br>因为 <code>subtract</code> 的参数定义了强类型，参数的类型可能引起函数的处理结果改变。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> subtract([int]<span class="variable">$value1</span>,[int]<span class="variable">$value2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$value1</span>-<span class="variable">$value2</span></span><br><span class="line">&#125;</span><br><span class="line">subtract LN P</span><br><span class="line"><span class="comment">#执行结果报错</span></span><br><span class="line">subtract : 无法处理对参数“value1”的参数转换。无法将值“LN”转换为类型“System.Int32”。错误:“输入字符串的格式不正确。”</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">10</span></span><br><span class="line">+ subtract LN P</span><br><span class="line">+          ~~</span><br><span class="line">    + CategoryInfo          : InvalidData: (:) [subtract]，ParameterBindingArgumentTransformationException</span><br><span class="line">    + FullyQualifiedErrorId : ParameterArgumentTransformationError,subtract</span><br><span class="line"></span><br><span class="line">subtract <span class="number">8.1</span> <span class="number">7.9</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="comment">&lt;#结果为0，这是因为PowerShell对结果整型化时进行了四舍五入</span></span><br><span class="line"><span class="comment">但是如果将上面的函数的参数定义为Double型#&gt;</span></span><br><span class="line"><span class="keyword">function</span> subtract([double]<span class="variable">$value1</span>,[double]<span class="variable">$value2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$value1</span>-<span class="variable">$value2</span></span><br><span class="line">&#125;</span><br><span class="line">subtract <span class="number">8.1</span>  <span class="number">7.9</span></span><br><span class="line"><span class="number">0.199999999999999</span></span><br><span class="line"><span class="comment">&lt;#输出 0.199999999999999的原因就是 .NET使用IEEE754标准存储浮点数，</span></span><br><span class="line"><span class="comment">由于这些小数转化二进制会无限循环，会根据一定精度截取尾数，</span></span><br><span class="line"><span class="comment">这个问题引发了这种奇怪的结果，</span></span><br><span class="line"><span class="comment">其实著名的0.1+0.2!=0.3也是这个原因导致的#&gt;</span></span><br></pre></td></tr></table></figure><h5 id="限制日期类型"><a href="#限制日期类型" class="headerlink" title="限制日期类型"></a>限制日期类型</h5><p>函数的参数解释器会自动尝试将字符串转换成日期类型，如果转换失败就是抛出异常<br>看下面的例子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> DayOfWeek([datetime]<span class="variable">$date</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>  <span class="variable">$date</span>.DayOfWeek</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DayofWeek <span class="string">'1927-8-1'</span></span><br><span class="line">Monday</span><br><span class="line"></span><br><span class="line">DayofWeek <span class="number">2008</span>-<span class="number">8</span>-<span class="number">1</span></span><br><span class="line">Friday</span><br><span class="line"></span><br><span class="line">DayofWeek <span class="string">'abc'</span></span><br><span class="line">DayOfWeek : 无法处理对参数“date”的参数转换。无法将值“abc”转换为类型“System.DateTime”。错误:“该字符串未被识别为有效的 DateTime。有一个未知单词(从索引 <span class="number">0</span> 处开始)。”</span><br><span class="line">所在位置 行:<span class="number">1</span> 字符: <span class="number">12</span></span><br><span class="line">+  DayofWeek <span class="string">'abc'</span></span><br><span class="line">+            ~~~~~</span><br><span class="line">    + CategoryInfo          : InvalidData: (:) [DayOfWeek]，ParameterBindingArgumentTransformationException</span><br><span class="line">    + FullyQualifiedErrorId : ParameterArgumentTransformationError,DayOfWeek</span><br></pre></td></tr></table></figure><h5 id="Switch-参数"><a href="#Switch-参数" class="headerlink" title="Switch 参数"></a>Switch 参数</h5><p><code>Powershell</code> 函数最简单的参数类型为布尔类型，除了使用 <code>Bool</code> 类型，也可以使用 <code>Switch</code> 关键字。<br>下面的函数逆转字符串，但是可以通过 <code>$try</code> 参数进行控制，如果没有指定 <code>$try</code> 的值，默认值为 <code>$false</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>  tryReverse( [switch]<span class="variable">$try</span> , [string]<span class="variable">$source</span> ) </span><br><span class="line"><span class="comment">#此处switch完全可以换成bool</span></span><br><span class="line">&#123;</span><br><span class="line">    [string]<span class="variable">$target</span>=<span class="string">""</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$try</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( [int]<span class="variable">$i</span> = <span class="variable">$source</span>.length -<span class="number">1</span>; <span class="variable">$i</span> <span class="nomarkup">-ge</span> <span class="number">0</span> ;<span class="variable">$i</span>--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="variable">$target</span> += <span class="variable">$source</span>[<span class="variable">$i</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$target</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$source</span></span><br><span class="line">&#125;</span><br><span class="line">tryReverse -source www.google.com</span><br><span class="line">tryReverse -try <span class="literal">$true</span> -source www.google.com</span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line">www.google.com</span><br><span class="line">moc.eloog.www</span><br></pre></td></tr></table></figure><h4 id="指定函数的返回值"><a href="#指定函数的返回值" class="headerlink" title="指定函数的返回值"></a>指定函数的返回值</h4><h5 id="一个或多个返回值"><a href="#一个或多个返回值" class="headerlink" title="一个或多个返回值"></a>一个或多个返回值</h5><p><code>PowerShell</code> 不像其它的编程语言，它的函数可以有多个返回值。如果你直接调用函数，返回值会在控制台输出。当然你也可以将结果存储在一个变量中进一步处理<br>下面的例子演示返回一个值：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Square([double]<span class="variable">$num</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$num</span>*<span class="variable">$num</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在控制台输出结果</span></span><br><span class="line">Square <span class="number">9.87</span></span><br><span class="line"><span class="number">97.4169</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#将结果赋值给变量</span></span><br><span class="line"><span class="variable">$value</span>=Square <span class="number">9.87</span></span><br><span class="line"><span class="variable">$value</span></span><br><span class="line"><span class="number">97.4169</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#返回值为Double类型</span></span><br><span class="line"><span class="variable">$value</span>.GetType().FullName</span><br><span class="line">System.Double</span><br></pre></td></tr></table></figure><p>下面的例子演示返回多个值</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> gbMeasure(<span class="variable">$amount</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"<span class="variable">$amount</span> GB=$(<span class="variable">$amount</span>) GB"</span></span><br><span class="line">    <span class="string">"<span class="variable">$amount</span> GB=$(<span class="variable">$amount</span>*1gb/1mb) MB"</span></span><br><span class="line">    <span class="string">"<span class="variable">$amount</span> GB=$(<span class="variable">$amount</span>*1gb/1kb) KB"</span></span><br><span class="line">    <span class="string">"<span class="variable">$amount</span> GB=$(<span class="variable">$amount</span>*1gb) B"</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#函数返回4个值</span></span><br><span class="line">gbMeasure <span class="number">1</span></span><br><span class="line"><span class="number">1</span> GB=<span class="number">1</span> GB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1048576</span> KB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1073741824</span> B</span><br><span class="line"> </span><br><span class="line"><span class="comment">#将所有的返回值存储在一个变量中</span></span><br><span class="line"><span class="variable">$result</span>=gbMeasure <span class="number">1</span></span><br><span class="line"><span class="variable">$result</span></span><br><span class="line"> </span><br><span class="line"><span class="number">1</span> GB=<span class="number">1</span> GB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1048576</span> KB</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1073741824</span> B</span><br><span class="line"> </span><br><span class="line"><span class="comment">#所有的返回值会自动存储在一个数组中</span></span><br><span class="line"><span class="variable">$result</span>=gbMeasure <span class="number">1</span></span><br><span class="line"><span class="variable">$result</span>.GetType().Name</span><br><span class="line">Object[]</span><br><span class="line"> </span><br><span class="line"><span class="comment">#通过索引访问每个返回值</span></span><br><span class="line"><span class="variable">$result</span>=gbMeasure <span class="number">1</span></span><br><span class="line"><span class="variable">$result</span>[<span class="number">3</span>]</span><br><span class="line"><span class="number">1</span> GB=<span class="number">1073741824</span> B</span><br></pre></td></tr></table></figure><p>总结一下，如果一个函数返回一个值，像其它编程语言一样，这个值包括它的类型信息会直接返回。但是如果遇到多个返回值，PowerShell会将所有的返回值自动构造成一个对象数组。<br>可以通过索引访问数组</p><h5 id="Return语句"><a href="#Return语句" class="headerlink" title="Return语句"></a>Return语句</h5><p><code>Powershell</code> 会将函数中所有的输出作为返回值，但是也可以通过return语句指定具体的返回值。<br>Return 语句会将指定的值返回，同时也会中断函数的执行，<strong>return后面的语句会被忽略</strong></p><p>看一个例子</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> test(<span class="variable">$num</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">    <span class="number">9</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">    <span class="number">4</span></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment">&lt;# 1 和 9 作为输出会返回</span></span><br><span class="line"><span class="comment">return语句中的10 也会返回</span></span><br><span class="line"><span class="comment">return 语句后的4和6会被忽略#&gt;</span></span><br></pre></td></tr></table></figure><h5 id="访问返回值"><a href="#访问返回值" class="headerlink" title="访问返回值"></a>访问返回值</h5><p>一个函数返回了一个值还是多个值，是可以验证的。下面的例子会产生随机数，如果没有指定个数，默认会返回一个随机数，否则会返回指定个数的随机数</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> lottery([int]<span class="variable">$number</span>=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$rand</span> = <span class="built_in">New-Object</span> system.random</span><br><span class="line">    <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">1</span>; <span class="variable">$i</span> <span class="nomarkup">-le</span> <span class="variable">$number</span>; <span class="variable">$i</span>++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$rand</span>.next(<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数为空时，返回值不是数组:</span></span><br><span class="line"><span class="variable">$result</span> = lottery</span><br><span class="line"><span class="variable">$result</span> -is [array]</span><br><span class="line">False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果指定多个随机数时，返回值是数组类型:</span></span><br><span class="line"><span class="variable">$result</span> = lottery <span class="number">10</span></span><br><span class="line"><span class="variable">$result</span> -is [array]</span><br><span class="line">True</span><br><span class="line"><span class="variable">$result</span>.count</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><h5 id="从函数的返回值中消除输出"><a href="#从函数的返回值中消除输出" class="headerlink" title="从函数的返回值中消除输出"></a>从函数的返回值中消除输出</h5><p>函数默认会将函数中的所有输出作为函数的返回值返回，这样很方便。但有时可能会将不必要的输出误以为返回值。写脚本程序时，可能需要自定义一些函数，这个函数可能只需要一个返回值，但是为了提高函数的可读性，可能会在函数增加一些注释输出行，或者使用<code>write-host</code></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> Test()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"Try to calculate."</span></span><br><span class="line">    <span class="string">"3.1415926"</span></span><br><span class="line">    <span class="string">"Done."</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">#保存在变量中输出,</span></span><br><span class="line"><span class="variable">$value</span>=Test</span><br><span class="line"><span class="variable">$value</span></span><br><span class="line"><span class="comment">#输出</span></span><br><span class="line"><span class="keyword">Try</span> to calculate.</span><br><span class="line"><span class="number">3.1415926</span></span><br><span class="line">Done.</span><br><span class="line"> </span><br><span class="line"><span class="comment">#如果要过滤注释，只输出，不作为返回值，</span></span><br><span class="line"><span class="comment">#可以使用Write-Host命令</span></span><br><span class="line"><span class="keyword">function</span> Test()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">"Try to calculate."</span></span><br><span class="line">    <span class="string">"3.1415926"</span></span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="string">"Done."</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在变量值中保存返回值，在控制台输出注释行</span></span><br><span class="line"><span class="variable">$value</span>=Test</span><br><span class="line"><span class="comment">#控制台输出</span></span><br><span class="line"><span class="keyword">Try</span> to calculate.</span><br><span class="line">Done.</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试返回值</span></span><br><span class="line"><span class="variable">$value</span></span><br><span class="line"><span class="number">3.1415926</span></span><br></pre></td></tr></table></figure><p>恭喜你！到此 <code>PowerShell</code> 基础入门算是完成了！<br>之后将介绍 <code>PowerShell</code> 的进阶使用</p><h4 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h4><h5 id="PowerShell-Math类常用函数表"><a href="#PowerShell-Math类常用函数表" class="headerlink" title="PowerShell Math类常用函数表"></a>PowerShell Math类常用函数表</h5><table><thead><tr><th>函数名</th><th>调用写法</th><th>所在类</th><th>重载</th><th>描述</th><th>参数</th></tr></thead><tbody><tr><td>sin</td><td>[math]::sin(x)</td><td>System.Math</td><td>1</td><td>返回x弧度的正弦值</td><td>double</td></tr><tr><td>cos</td><td>[math]::cos(x)</td><td>System.Math</td><td>1</td><td>返回x弧度的余弦值</td><td>double</td></tr><tr><td>abs</td><td>[math]::abs(x)</td><td>System.Math</td><td>7</td><td>返回x的绝对值</td><td>所有数值型</td></tr><tr><td>sqrt</td><td>[math]::sqrt(x)</td><td>System.Math</td><td>1</td><td>返回x的平方根</td><td>double</td></tr><tr><td>pow</td><td>[math]::pow(x,n)</td><td>System.Math</td><td>1</td><td>返回x的n次幂</td><td>两参数都是double</td></tr><tr><td>log</td><td>[math]::log(x)</td><td>System.Math</td><td>1</td><td>返回x的自然对数</td><td>double</td></tr><tr><td>log</td><td>[math]::log(x,n)</td><td>System.Math</td><td>1</td><td>返回x的以n为底的对数</td><td>double</td></tr><tr><td>min</td><td>[math]::min(x,y)</td><td>System.Math</td><td>11</td><td>返回x，y中的最小值</td><td>所有数值型</td></tr><tr><td>max</td><td>[math]::max(x,y)</td><td>System.Math</td><td>11</td><td>返回x，y中的最大值</td><td>所有数值型</td></tr><tr><td>floor</td><td>[math]::ceiling(x)</td><td>System.Math</td><td>2</td><td>返回x向下取整的结果</td><td>double、decimal</td></tr><tr><td>ceiling</td><td>[math]::ceiling(x)</td><td>System.Math</td><td>2</td><td>返回x向上取整的结果</td><td>double、decimal</td></tr><tr><td><code>math</code> 类其他函数及详细用法参见微软文档: <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.math?view=netframework-4.7.2#%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">Math类</a></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PowerShell入门指南-三-·一门新的编程语言&quot;&gt;&lt;a href=&quot;#PowerShell入门指南-三-·一门新的编程语言&quot; class=&quot;headerlink&quot; title=&quot;PowerShell入门指南(三)·一门新的编程语言&quot;&gt;&lt;/a&gt;PowerShell入门指南(三)·一门新的编程语言&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;作为独立的编程语言&quot;&gt;&lt;a href=&quot;#作为独立的编程语言&quot; class=&quot;headerlink&quot; title=&quot;作为独立的编程语言&quot;&gt;&lt;/a&gt;作为独立的编程语言&lt;/h4&gt;&lt;p&gt;作为一门独立的语言来说，&lt;code&gt;PowerShell&lt;/code&gt; 是非常地Powerful，我们先来了解一下它的特点:&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://lollipopnougat.github.io/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>记一次express后端的搭建</title>
    <link href="https://lollipopnougat.github.io/2019/04/30/%E8%AE%B0%E4%B8%80%E6%AC%A1express%E5%90%8E%E7%AB%AF%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://lollipopnougat.github.io/2019/04/30/记一次express后端的搭建/</id>
    <published>2019-04-30T12:21:25.000Z</published>
    <updated>2020-02-28T15:35:54.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h3><p>作为网工人怎么能不会搭后端呢？<br>今天就拿 Node.js 下的 Express 搭一个后端</p><a id="more"></a><h2 id="Node-js-是什么东西"><a href="#Node-js-是什么东西" class="headerlink" title="Node.js 是什么东西"></a>Node.js 是什么东西</h2><p>你可能没听说过 <code>Node.js</code>，但是应该听说过 <code>JavaScript</code>，你也应该知道 <code>Chrome</code>(谷歌浏览器) 吧</p><blockquote><ul><li><code>Node.js</code> 是一个基于 <code>Chrome V8</code> 引擎的 <code>JavaScript</code> 运行环境(Runtime，即运行时)。<br></li><li><code>Node.js</code> 使用了一个事件驱动、非阻塞式 <code>I/O</code> 的模型，使其轻量又高效。</li></ul></blockquote><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Node</code> 是一个让 <code>JavaScript</code> 运行在服务端的开发平台，它让 <code>JavaScript</code> 成为与<code>PHP</code>、<code>Python</code>、<code>Perl</code>、<code>Ruby</code> 等服务端语言平起平坐的脚本语言。它发布于 2009 年 5 月，由 Ryan Dahl 开发，实质是对 Chrome V8 引擎进行了封装(底层调用 C/C++的相关库)。<br><br>Node 对一些特殊用例进行优化，提供替代的 API，使得 V8 在非浏览器环境下运行得更好。V8 引擎执行 Javascript 的速度非常快，性能非常好。常用于用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用事件驱动， 非阻塞 I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。</p><h2 id="Express-js"><a href="#Express-js" class="headerlink" title="Express.js"></a>Express.js</h2><p>这是一个基于 <code>Node.js</code> 平台，快速、开放、极简的 Web 开发框架，为 Web 和移动应用程序提供一组强大的功能。其实就是一个 node 下很完善的一个后端框架，在众多 js 后端框架中 Express 是做到大而全的。</p><h2 id="为什么选择-Express"><a href="#为什么选择-Express" class="headerlink" title="为什么选择 Express"></a>为什么选择 Express</h2><p>首先是因为<code>node</code> 相比 <code>java</code> 下的 <code>spring</code>，<code>python</code> 下的 <code>django</code> 之类开发效率高。<code>node</code> 平台编程语言还是 <code>js</code>，对于前端也很友好，即使想要面向对象也有 <code>ECMA6</code> 和 <code>Typescript</code> 可选；还有完善的包管理工具 <code>npm</code> 或者 <code>yarn</code>;<br><br>express 框架非常易于使用，即使没有使用经验也能很快上手。而且其大而全的特性也是功能强大的表现，相关需求的插件很多，使用文档和教程也是不计其数，可以说是各种流行后端框架中最高效最轻量的一个了。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先假定你已经安装了 <code>Node.js</code>，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir myapp</span><br><span class="line"><span class="built_in">cd</span> myapp</span><br></pre></td></tr></table></figure><p>通过 <code>npm init</code> 命令为你的应用创建一个 <code>package.json</code> 文件。 欲了解 <code>package.json</code> 是如何起作用的，请参考 <a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">Specifics of npm’s package.json handling</a>.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受大部分默认设置即可，下面这个除外：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry point: (index.js)</span><br></pre></td></tr></table></figure><p>键入 app.js 或者你所希望的名称，这是当前应用的入口文件。如果你希望采用默认的 index.js 文件名，只需按“回车”键即可。<br></p><p>接下来在 myapp 目录下安装 Express 并将其保存到依赖列表中。如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --save</span><br></pre></td></tr></table></figure><p>如果只是临时安装 Express，不想将它添加到依赖列表中，可执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express --no-save</span><br></pre></td></tr></table></figure><blockquote><p>npm 5.0+ 版本在默认情况下会将安装的模块添加到 <code>package.json</code> 文件中的 <code>dependencies</code> 列表中。对于较老的 npm 版本，你就必须指定 <code>--save</code> 参数。然后，照旧执行 <code>npm install</code> 命令即可自动安装依赖列表中所列出的所有模块。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="最简单的示例"><a href="#最简单的示例" class="headerlink" title="最简单的示例"></a>最简单的示例</h3><h4 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line"><span class="keyword">var</span> port = <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">'Hello World'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(port, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> host = server.address().address</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'应用实例，访问地址为 http://%s:%s'</span>, host, port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="甚至可以这样写-需要ES-6"><a href="#甚至可以这样写-需要ES-6" class="headerlink" title="甚至可以这样写(需要ES 6)"></a>甚至可以这样写(需要ES 6)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ECMAScript 6 支持了 let, const 关键字、类 class、lambda 表达式、字符串模板(`$&#123;&#125;`)、异步关键字async, await、解构赋值、模块的导入(import)和导出(export default/export)、Promise (异步的同步代码)、set和map的实现等好多特性，有时间我会更一期文章讲这个</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>, (req, res) =&gt; res.send(<span class="string">'Hello World!'</span>));</span><br><span class="line"><span class="comment">// 采用了lambda表达式的写法非常简洁不是吗</span></span><br><span class="line"></span><br><span class="line">app.listen(port, () =&gt; <span class="built_in">console</span>.log(<span class="string">`Example app listening on port <span class="subst">$&#123;port&#125;</span>!`</span>));</span><br></pre></td></tr></table></figure><p>通过 <code>npm 文件名</code> 就可以启动。</p><h3 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h3><p><code>Express</code> 应用使用回调函数的参数： <code>request</code> 和 <code>response</code> 对象来处理请求和响应的数据。<br></p><h4 id="处理-GET-请求示例"><a href="#处理-GET-请求示例" class="headerlink" title="处理 GET 请求示例"></a>处理 GET 请求示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理访问'/'目录的回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设用户访问的是 /?name=string 执行结果就是输出 string</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'您通过query指定的参数是 %s'</span>, req.query.name)</span><br><span class="line">  <span class="comment">// 返回json响应</span></span><br><span class="line">  res.json(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="处理-POST-请求示例"><a href="#处理-POST-请求示例" class="headerlink" title="处理 POST 请求示例"></a>处理 POST 请求示例</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 为了省事，函数我用lambda表达式表示了</span></span><br><span class="line">  <span class="comment">// 假设用户向 '/' POST 一个 &#123; name: 'string' &#125;</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'您提交的name字段值是 %s'</span>, req.body.name) <span class="comment">// 返回结果就是 string</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用命令行生成器"><a href="#使用命令行生成器" class="headerlink" title="使用命令行生成器"></a>使用命令行生成器</h3><p>通过应用生成器工具 <code>express-generator</code> 可以快速创建一个应用的基本框架。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要求 node.js 版本在 8.2.0 及以上</span></span><br><span class="line">npx express-generator</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果低于 8.2.0 可以使用</span></span><br><span class="line">npm install -g express-generator</span><br><span class="line"><span class="comment"># 安装完成后再执行</span></span><br><span class="line">express</span><br></pre></td></tr></table></figure><p>详细信息请看<a href="https://www.expressjs.com.cn/starter/generator.html" target="_blank" rel="noopener">教程</a></p><h3 id="使用路由功能"><a href="#使用路由功能" class="headerlink" title="使用路由功能"></a>使用路由功能</h3><p><a href="https://www.expressjs.com.cn/starter/basic-routing.html" target="_blank" rel="noopener">教程</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Node-js&quot;&gt;&lt;a href=&quot;#Node-js&quot; class=&quot;headerlink&quot; title=&quot;Node.js&quot;&gt;&lt;/a&gt;Node.js&lt;/h3&gt;&lt;p&gt;作为网工人怎么能不会搭后端呢？&lt;br&gt;今天就拿 Node.js 下的 Express 搭一个后端&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node.js" scheme="https://lollipopnougat.github.io/tags/Node-js/"/>
    
      <category term="Express" scheme="https://lollipopnougat.github.io/tags/Express/"/>
    
      <category term="后端" scheme="https://lollipopnougat.github.io/tags/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="网站搭建" scheme="https://lollipopnougat.github.io/tags/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(2)</title>
    <link href="https://lollipopnougat.github.io/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(2)/"/>
    <id>https://lollipopnougat.github.io/2019/03/29/PowerShell入门指南(2)/</id>
    <published>2019-03-29T06:41:14.000Z</published>
    <updated>2020-02-25T12:17:39.406Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PowerShell入门指南-二-·挑战CMD和Bash的PowerShell"><a href="#PowerShell入门指南-二-·挑战CMD和Bash的PowerShell" class="headerlink" title="PowerShell入门指南(二)·挑战CMD和Bash的PowerShell"></a>PowerShell入门指南(二)·挑战CMD和Bash的PowerShell</h3><h4 id="作为CMD-Bash的代替使用"><a href="#作为CMD-Bash的代替使用" class="headerlink" title="作为CMD/Bash的代替使用"></a>作为CMD/Bash的代替使用</h4><p>如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用</p><a id="more"></a><hr><table><thead><tr><th>PowerShell 命令</th><th>PowerShell 简称</th><th>CMD 命令</th><th>UNIX 命令</th><th>描述</th></tr></thead><tbody><tr><td>Get-ChildItem</td><td>gci,dir,ls</td><td>dir</td><td>ls</td><td>显示当前目录下的所有文件和文件夹</td></tr><tr><td>Test-Connection</td><td>ping</td><td>ping</td><td>ping</td><td>向目标站点发送一个ICMP接受响应，检查网络连通性</td></tr><tr><td>Get-Content</td><td>gc,type,cat</td><td>type</td><td>cat</td><td>获取文件内容</td></tr><tr><td>Get-Command</td><td>gcm</td><td>help</td><td>type, which, compgen</td><td>列出可用的命令</td></tr><tr><td>Get-Help</td><td>help,man</td><td>help</td><td>apropos,man</td><td>在控制台列出命令的使用文档</td></tr><tr><td>Clear-Host</td><td>cls,clear</td><td>cls</td><td>clear</td><td>清除屏幕内容</td></tr><tr><td>Copy-Item</td><td>cpi,copy,cp</td><td>copy,xcopy,robocopy</td><td>cp</td><td>拷贝文件/文件夹到指定位置</td></tr><tr><td>Move-Item</td><td>mi,move,mv</td><td>move</td><td>mv</td><td>移动文件/文件夹到新位置</td></tr><tr><td>Remove-Item</td><td>ri,del,erase,rmdir,rd,rm</td><td>del,erase,rmdir,rd</td><td>rm,rmdir</td><td>删除文件/文件夹</td></tr><tr><td>Rename-Item</td><td>rni,ren,mv</td><td>ren,rename</td><td>mv</td><td>重命名文件/文件夹</td></tr><tr><td>Get-Location</td><td>gl,cd,pwd</td><td>cd</td><td>pwd</td><td>显示当前工作目录</td></tr><tr><td>Pop-Location</td><td>popd</td><td>popd</td><td>popd</td><td>将工作路径更改为最近压入堆栈的位置</td></tr><tr><td>Push-Location</td><td>pushd</td><td>pushd</td><td>pushd</td><td>将工作路径存储到堆栈上</td></tr><tr><td>Set-Location</td><td>sl,cd,chdir</td><td>cd,chdir</td><td>cd</td><td>更改当前工作目录</td></tr><tr><td>Tee-Object</td><td>tee</td><td>不支持</td><td>tee</td><td>将输入通过管道传递到文件或变量</td></tr><tr><td>Write-Output</td><td>echo,write</td><td>echo</td><td>echo</td><td>将字符或其他对象输出到标准输出流上</td></tr><tr><td>Get-Process</td><td>gps,ps</td><td>tlist,tasklist</td><td>ps</td><td>列出当前全部进程</td></tr><tr><td>Stop-Process</td><td>spps,kill</td><td>kill,taskkill</td><td>kill</td><td>终止指定进程</td></tr><tr><td>Select-String</td><td>sls</td><td>findstr</td><td>find,grep</td><td>打印匹配的字符行</td></tr><tr><td>Set-Variable</td><td>sv,set</td><td>set</td><td>env,export,set,setenv</td><td>创建或更改环境变量的内容</td></tr><tr><td>Invoke-WebRequest</td><td>iwr,<del>curl,wget</del>[^1]</td><td>不支持</td><td>wget,curl</td><td>从Internet上的网页获取内容</td></tr><tr><td>***</td><td></td><td></td><td></td><td></td></tr><tr><td>[^1]:curl和wget不在PowerShell Core中，因此不会干扰调用非Windows操作系统的同名组件。</td><td></td><td></td><td></td><td></td></tr></tbody></table><hr><h2 id="功能键和快捷键"><a href="#功能键和快捷键" class="headerlink" title="功能键和快捷键"></a>功能键和快捷键</h2><h4 id="先来了解一下功能键和快捷键"><a href="#先来了解一下功能键和快捷键" class="headerlink" title="先来了解一下功能键和快捷键"></a>先来了解一下功能键和快捷键</h4><ul><li><kbd>ALT</kbd>+<kbd>F7</kbd>    清除命令的历史记录</li><li><kbd>PgUp</kbd> <kbd>PgDn</kbd>    显示当前会话的第一个命令和最后一个命令</li><li><kbd>Enter</kbd>    执行当前命令</li><li><kbd>End</kbd>    将光标移至当前命令的末尾</li><li><kbd>Del</kbd>    从右开始删除输入的命令字符</li><li><kbd>Esc</kbd>    清空当前命令行</li><li><kbd>F2</kbd>    自动补充历史命令至指定字符<br>(例如历史记录中存在Get-Process，按<kbd>F2</kbd>，提示”Enter char to copy up to”，键入 <kbd>S</kbd>，自动补齐命令:Get-Proce)</li><li><kbd>F4</kbd>    删除命令行至光标右边指定字符处</li><li><kbd>F7</kbd>    对话框显示命令行历史记录</li><li><kbd>F8</kbd>    检索包含指定字符的命令行历史记录</li><li><kbd>F9</kbd>    根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看</li><li><kbd>←</kbd>/<kbd>→</kbd>    左右移动光标</li><li><kbd>↑</kbd>/<kbd>↓</kbd>    切换命令行的历史记录</li><li><kbd>Home</kbd>    光标移至命令行最左端</li><li><kbd>Backspace</kbd>    从右删除命令行字符</li><li><kbd>Ctrl</kbd>+<kbd>C</kbd>    取消正在执行的命令</li><li><kbd>Ctrl</kbd>+<kbd>←</kbd>/<kbd>→</kbd>    在单词之间移动光标</li><li><kbd>Ctrl</kbd>+<kbd>Home</kbd>    删除光标最左端的所有字符</li><li><kbd>Tab</kbd>    自动补齐命令或者文件名<h2 id="数值计算"><a href="#数值计算" class="headerlink" title="数值计算"></a>数值计算</h2>我们可以把powershell当成一个计算器。象键入命令行那样输入数学表达式，回车，powershell会自动计算并把结果输出。常用的加减乘除模（+,-,*,/,%）运算和小括号表达式都支持。</li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:/pstest&gt; <span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">0</span>xABCD</span><br><span class="line"><span class="number">43981</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">3.14</span>*<span class="number">10</span>*<span class="number">10</span></span><br><span class="line"><span class="number">314</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>+<span class="number">3</span>-(<span class="number">2.4</span>-<span class="number">5</span>)*(<span class="number">7.899</span>-<span class="number">4.444</span>)</span><br><span class="line"><span class="number">12.983</span></span><br></pre></td></tr></table></figure><p>PowerShell也能自动识别计算机容量单位,包括KB，MB，GB，TB，PB</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PS C:/pstest&gt; <span class="number">1</span>pb/<span class="number">1</span>tb</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>tb/<span class="number">1</span>gb</span><br><span class="line"><span class="number">1024</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>gb/<span class="number">1</span>kb</span><br><span class="line"><span class="number">1048576</span></span><br><span class="line">PS C:/pstest&gt; <span class="number">1</span>gb/<span class="number">20</span>mb*<span class="number">10</span>kb</span><br><span class="line"><span class="number">524288</span></span><br></pre></td></tr></table></figure><p>假如一个网站的每天人均PV操作为5，页面大小为80Kb，主机提供商限制的总流量为10G，那平均每天的最大访客数为：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PS C:/pstest&gt; <span class="number">10</span>GB/(<span class="number">80</span>KB*<span class="number">5</span>)/<span class="number">30</span></span><br><span class="line"><span class="number">873.813333333333</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;PowerShell入门指南-二-·挑战CMD和Bash的PowerShell&quot;&gt;&lt;a href=&quot;#PowerShell入门指南-二-·挑战CMD和Bash的PowerShell&quot; class=&quot;headerlink&quot; title=&quot;PowerShell入门指南(二)·挑战CMD和Bash的PowerShell&quot;&gt;&lt;/a&gt;PowerShell入门指南(二)·挑战CMD和Bash的PowerShell&lt;/h3&gt;&lt;h4 id=&quot;作为CMD-Bash的代替使用&quot;&gt;&lt;a href=&quot;#作为CMD-Bash的代替使用&quot; class=&quot;headerlink&quot; title=&quot;作为CMD/Bash的代替使用&quot;&gt;&lt;/a&gt;作为CMD/Bash的代替使用&lt;/h4&gt;&lt;p&gt;如果你想把PowerShell当作原来的CMD命令行使用是完全可以的，甚至还有部分Bash的语法可以使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://lollipopnougat.github.io/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell入门指南(1)</title>
    <link href="https://lollipopnougat.github.io/2019/03/29/PowerShell%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%971/"/>
    <id>https://lollipopnougat.github.io/2019/03/29/PowerShell入门指南1/</id>
    <published>2019-03-29T06:32:58.000Z</published>
    <updated>2020-02-25T05:39:20.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Powershell入门指南-一-·PowerShell及CLI发展"><a href="#Powershell入门指南-一-·PowerShell及CLI发展" class="headerlink" title="Powershell入门指南(一)·PowerShell及CLI发展"></a>Powershell入门指南(一)·PowerShell及CLI发展</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png" alt="PowerShell"></p><p>不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。</p><a id="more"></a><hr><p>也许你也曾经打开过它，但是不知道它有什么用;<br>或者你了解一些CMD命令，但是你发现在这个PowerShell里面有些命令好像不能执行了。<br>而且这个PowerShell相比CMD启动也不算快，<strong>微软为什么要拿这个替换CMD呢</strong>？这要从早期的Windows的命令行背景说起：</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>用于个人计算机的每个Windows版本都包含一个用于管理操作系统的命令行解释程序(CLI)；Windows系统的前身，即MS-DOS，完全依赖CLI支持。在MS-DOS和Windows9x系列系统里面提供CLI功能的程序是<code>COMMAND.COM</code>，在Windows NT以及之后的各种系统是<code>CMD.exe</code>提供CLI支持的。这两者都支持一些内部命令。<br>它们还包括基本的脚本语言(batch file)支持，这些脚本可以完成多种自动化工作，但是对于用户交互界面(GUI)的自动化工作，它们就完全无能为力了。这是因为对GUI这些操作对应脚本的等价操作来说是受限的，毕竟这是最基本的脚本环境，支持的功能不全。到了Windows Sever 2003发布的时候，这一情况有所改善，但是仍令人不满意。</p><p>其实Microsoft在1998年就试图通过对Windows 98引入Windows脚本宿主(WSH)来解决其中一些缺点，这个程序在系统中名叫<code>cscript.exe</code>，它集成了Active script[^1]脚本引擎，可以使用兼容的<code>VBscript</code>和<code>JScript</code>来编写，调用其他应用程序的API或者COM。然而，它有其自身的不足之处：<br>的文档不是很容易获得，并且在几个有名的计算机病毒利用其安全协议中的弱点之后，迅速获得了作为脆弱的系统漏洞荣誉(大雾)。不同版本的Windows提供了各种专用命令行解释器（例如netsh和WMIC）及其只适用自己的命令，但它们之间不可互操作。</p><hr><h3 id="开发人员的设想"><a href="#开发人员的设想" class="headerlink" title="开发人员的设想"></a>开发人员的设想</h3><p>在9月13日发表的一次采访中，Jeffrey Snover(PowerShell之父)解释了开发该项目的动机:</p><blockquote><p>“我一直推动管理的变更，然后我开始把一些UNIX工具适配到Windows平台，结果它们却不能工作，对吧？因为Windows 和Linux的核心架构有很大区别。在Linux上，一切都是ASCII文本文件，因此所有支持这种文件的软件都可以作为管理软件。想想看，使用AWK(文本处理工具)、grep(文本搜索工具)、sed(类似于AWK)管理你的系统是多么美好的事请！<br>我把这些工具移植到Windows，结果它们对于系统的管理没有任何作用，因为所有的API返回的都是结构化的数据，因此那些UNIX软件没什么帮助。<br>……<br>我突然有了就是现在powershell这样子的想法，告诉别人说：‘嘿！没准我们可以把这个做得更好！’”</p></blockquote><hr><h2 id="开发历程"><a href="#开发历程" class="headerlink" title="开发历程"></a>开发历程</h2><ul><li><p>2002年，微软开始开发一种新的命令行管理方法，名为Monad（也称为Microsoft Shell或MSH）的CLI。其背后的想法于2002年8月发表在一份名为Monad Manifesto的白皮书中。Monad将成为一个新的可扩展CLI，其设计新颖，能够自动执行各种核心管理任务。</p></li><li><p>微软于2003年10月在洛杉矶举行的专业发展大会上首次展示Monad。几个月后开始私人测试计划，最终推出公共测试计划。</p></li><li><p>Microsoft 于2005年6月17日发布了第一个Monad公共测试版，</p></li><li><p>2005年9月11日发布了Beta 2</p></li><li><p>2006年1月10日发布了Beta 3。</p></li><li><p>不久之后，2006年4月25日，Microsoft正式宣布Monad已重命名为Windows PowerShell，将其定位为其管理技术产品的重要组成部分。 名称更改和RC的一个重要方面是，它现在是Windows的一个组件，而不是附加产品。</p></li><li><p>PowerShell版本1的候选版本2于2006年9月26日发布，最终发布于2006年11月14日，并在TechEd Barcelona上发布。</p></li><li><p>早期版本的Windows PowerShell于2007年1月30日发布。</p></li><li><p>PowerShell v2.0开发在PowerShell v1.0发布之前就开始了。在开发过程中，Microsoft发布了三个社区技术预览（CTP）。Microsoft向公众提供了这些版本。</p></li><li><p>Windows PowerShell v2.0的最后一个CTP版本于2008年12月推出。</p></li><li><p>适用于Ubuntu 14.04 x64 上的Linux 6.0 Alpha 9的PowerShell</p></li><li><p>PowerShell v2.0已于2009年8月完成并发布，作为Windows 7和Windows Server 2008 R2的组成部分。适用于Windows XP，Windows Server 2003，Windows Vista和Windows Server 2008的PowerShell版本于2009年10月发布，可供32位和64位平台下载。</p></li><li><p>Windows 10提供了PowerShell的测试框架</p></li><li><p>2016年8月18日，微软宣布他们开发了PowerShell开源和跨平台，支持Windows，macOS，CentOS和Ubuntu。源代码发布在GitHub上。转向开源创建了PowerShell的第二个版本，称为“PowerShell Core”，它运行在 .NET Core上。它与“Windows PowerShell”不同，后者在完整的 .NET Framework上运行。</p></li><li><p>从版本5.1开始，PowerShell Core与Windows Server 2016 Nano Server捆绑在一起</p></li></ul><hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>PowerShell是Microsoft的<strong>任务自动化和配置管理框架</strong>，由命令行shell和相关的脚本语言组成。最初只是一个Windows组件，称为Windows PowerShell，它于2016年8月18日通过PowerShell Core的推出而成为开源和跨平台。前者构建于 .NET Framework上，后者构建于 .NET Core上。</p><p>在PowerShell中，管理任务通常由<code>cmdlet</code>（发音为command-lets）执行，<strong>cmdlet是实现特定操作的专用 .NET 类</strong>。这些工作通过访问不同数据存储中的数据（如文件系统或注册表），这些数据存储通过提供程序提供给PowerShell 。第三方开发人员可以向PowerShell添加cmdlet和提供程序。自定义的脚本可以使用Cmdlet ，还可以打包成模块作为新的Cmdlet使用。</p><p>PowerShell提供对COM和WMI的完全访问，使管理员能够在本地和远程Windows系统以及WS-Management和CIM上执行管理任务，从而实现远程对Linux系统和网络设备的管理。PowerShell还提供了一个托管API，PowerShell运行时可以使用该API嵌入到其他应用程序中。然后，这些应用程序可以使用PowerShell功能来实现某些操作，包括通过图形界面公开的操作。Microsoft Exchange Server 2007 使用此功能将其管理功能公开为PowerShell指令和提供程序并实现作为PowerShell主机的图形管理工具，可通过调用必要的cmdlet来使用Exchange Sever 2007。其他Microsoft应用程序（包括Microsoft SQL Server 2008）也通过PowerShell cmdlet公开其管理界面。</p><p>PowerShell含有广泛的，基于控制台的自身帮助（类似于手册页在Unix外壳）通过键入<code>Get-Help</code>命令即可轻松获取使用方法。你可以通过<code>Update-Help</code> cmdlet 从Internet升级本地帮助内容，还能通过<code>Get-Help &lt;命令名&gt; -online</code>获取来自网络的帮助。</p><hr><blockquote><p>以上内容来自<a href="https://en.wikipedia.org/wiki/PowerShell#Background" target="_blank" rel="noopener">PowerShell - Wikipedia</a>，背景和开发人员设想部分为笔者翻译(翻译如有问题欢迎指出)，开发历程和简介由Google提供翻译服务，笔者进行了校对。</p></blockquote><hr><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><blockquote><p>了解更多请参考： <a href="https://en.wikipedia.org/w/index.php?title=PowerShell#Versions" target="_blank" rel="noopener">PowerShell - Wikipedia</a></p></blockquote><p>最初使用代号“Monad”，PowerShell于2003年9月首次在专业开发者大会上公开展示。所有主要版本仍然受支持，并且每个主要版本都具有与先前版本的向后兼容性。</p><h5 id="PowerShell-1-0"><a href="#PowerShell-1-0" class="headerlink" title="PowerShell 1.0"></a>PowerShell 1.0</h5><p>PowerShell 1.0于2006年11月发布，适用于Windows XP SP2，Windows Server 2003 SP1和Windows Vista。它还是Windows Server 2008的可选组件。</p><h5 id="PowerShell-2-0"><a href="#PowerShell-2-0" class="headerlink" title="PowerShell 2.0"></a>PowerShell 2.0</h5><p>PowerShell 2.0与Windows 7和Windows Server 2008 R2集成，适用于Windows XP Service Pack 3，Windows Server 2003 Service Pack 2和Windows Vista Service Pack 1. </p><p>PowerShell v2除了包含240多个新cmdlet之外，还包括对脚本语言和托管API的更改。</p><h5 id="PowerShell-3-0"><a href="#PowerShell-3-0" class="headerlink" title="PowerShell 3.0"></a>PowerShell 3.0</h5><p>PowerShell 3.0与Windows 8和Windows Server 2012集成在一起。Microsoft还为Windows 7 Service Pack 1，Windows Server 2008 Service Pack 1和Windows Server 2008 R2 Service Pack 1 提供了PowerShell 3.0 。</p><p>PowerShell 3.0是更大的软件包Windows Management Framework 3.0（WMF3）的一部分，它还包含支持远程处理的WinRM服务。Windows Management Framework 3.0的早期社区技术预览2（CTP 2）版本于2011年12月2日发布。 Windows Management Framework 3.0于2012年12月发布，并默认包含在Windows 8和Windows Server 2012中。</p><h5 id="PowerShell-4-0"><a href="#PowerShell-4-0" class="headerlink" title="PowerShell 4.0"></a>PowerShell 4.0</h5><p>PowerShell 4.0与Windows 8.1和Windows Server 2012 R2集成在一起。Microsoft还为Windows 7 SP1，Windows Server 2008 R2 SP1和Windows Server 2012提供了PowerShell 4.0。</p><h5 id="PowerShell-5-0"><a href="#PowerShell-5-0" class="headerlink" title="PowerShell 5.0"></a>PowerShell 5.0</h5><p>包含PowerShell 5.0的Windows Management Framework（WMF）5.0 RTM于2016年2月24日在发布严重错误的初始版本后重新发布到Web。主要功能包括OneGet PowerShell cmdlet，支持Chocolatey基于存储库的包管理，并将对交换机管理的支持扩展到第2层网络交换机。</p><h5 id="PowerShell-5-1"><a href="#PowerShell-5-1" class="headerlink" title="PowerShell 5.1"></a>PowerShell 5.1</h5><p>它与2016年8月2日的Windows 10 周年更新以及Windows Server 2016一起发布。PackageManagement现在支持代理，PSReadLine现在支持ViMode，并添加了两个新的cmdlet：Get-TimeZone和Set-TimeZone。LocalAccounts模块允许添加/删除本地用户帐户。 PowerShell 5.1的预览版已于2016年7月16日针对Windows 7，Windows Server 2008，Windows Server 2008 R2，Windows Server 2012和Windows Server 2012 R2 发布，并于2017年1月19日发布正式版。</p><p>PowerShell 5.1是第一个有两个版本的PowerShell，包括“桌面”和“核心”版本。“桌面”版本是在完整的 .NET Framework堆栈上运行的传统Windows PowerShell的延续。“Core”版本在 .NET Core上运行，并与Windows Server 2016 Nano Server捆绑在一起。为了减少占用空间，后者缺少一些功能，例如用于管理剪贴板的cmdlet或将计算机加入域，WMI版本1 cmdlet，事件日志cmdlet和配置文件。这是专为Windows制作的PowerShell的最终版本。</p><h5 id="PowerShell-6-0"><a href="#PowerShell-6-0" class="headerlink" title="PowerShell 6.0"></a>PowerShell 6.0</h5><p>PowerShell Core 6.0于2016年8月18日首次发布，当时微软公布了PowerShell Core并决定使该产品跨平台，独立于Windows，而且是免费和开源的。<br>它于2018年1月10日实现了Windows，macOS和Linux的普遍可用性。它有自己的支持生命周期，并遵循Windows 10引入的Microsoft生命周期策略：仅支持最新版本的PowerShell Core。微软希望每六个月为PowerShell Core 6.0发布一个次要版本。</p><p>此版本PowerShell中最重要的变化是扩展到其他平台。对于Windows管理员，此版本的PowerShell没有任何主要的新功能。在2018年1月11日的社区访谈中，PowerShell团队被要求列出将从Windows PowerShell 5.1迁移到PowerShell Core 6.0的Windows IT专业人员可能发生的十大最令人兴奋的事情。作为回应，微软的Angel Calvo只能说出两个：跨平台和开源(这两个就足够了)。</p><h6 id="目前Windows-10-上自带的最新版本是5-1"><a href="#目前Windows-10-上自带的最新版本是5-1" class="headerlink" title="目前Windows 10 上自带的最新版本是5.1"></a>目前Windows 10 上自带的最新版本是5.1</h6><p>[^1]:一种可以采用各种语言以及固定格式等实现、并能与其他 ActiveX 控件(可以理解为一种互联网插件)交互的脚本</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Powershell入门指南-一-·PowerShell及CLI发展&quot;&gt;&lt;a href=&quot;#Powershell入门指南-一-·PowerShell及CLI发展&quot; class=&quot;headerlink&quot; title=&quot;Powershell入门指南(一)·PowerShell及CLI发展&quot;&gt;&lt;/a&gt;Powershell入门指南(一)·PowerShell及CLI发展&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png&quot; alt=&quot;PowerShell&quot;&gt;&lt;/p&gt;
&lt;p&gt;不知各位有没有注意，从Windows 10开始，在开始按钮上右键，菜单里面的CMD不见了，取而代之的是一个叫PowerShell的东西。&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://lollipopnougat.github.io/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>春节快乐</title>
    <link href="https://lollipopnougat.github.io/2019/02/04/%E6%98%A5%E8%8A%82%E5%BF%AB%E4%B9%90/"/>
    <id>https://lollipopnougat.github.io/2019/02/04/春节快乐/</id>
    <published>2019-02-04T12:38:56.000Z</published>
    <updated>2020-02-25T05:39:38.634Z</updated>
    
    <content type="html"><![CDATA[<h3 id="春节快乐"><a href="#春节快乐" class="headerlink" title="春节快乐"></a>春节快乐</h3><p>祝各位春节快乐,新的一年大家也要继续努力鸭!笔者还准备了礼物送给大家，点击下面的阅读全文查看</p><a id="more"></a><h2 id="献上笔者绘制的Peppa-Pig-社会猪佩奇"><a href="#献上笔者绘制的Peppa-Pig-社会猪佩奇" class="headerlink" title="献上笔者绘制的Peppa Pig(社会猪佩奇)"></a>献上笔者绘制的Peppa Pig(社会猪佩奇)</h2><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/SpF.png" alt="Happy New Year!"></p><h2 id="送上猪年祝福语"><a href="#送上猪年祝福语" class="headerlink" title="送上猪年祝福语"></a>送上猪年祝福语</h2><ul><li>春风初度到猪年，欢歌声声震云天。千家万户乐翩翩，迎福纳财笑开颜。我有祝福在心田，悄悄送到你身边。愿你猪年爱情甜，合家快乐福无边。</li><li>朝霞映满天，盛世耀猪年。歌美舞翩翩，快乐太平年。瑞雪一片片，幸福绕猪年。春风暖心田，欢度团圆年。猪年到了，愿你快乐绵绵！</li><li>猪年好，猪年妙，猪年的歌声满天飘；猪年灿，猪年暖，猪年的幸福享不完；猪年旺，猪年香，猪年的祝福分外长。愿你猪年心飞扬，万事皆顺畅！</li><li>除夕到来菩萨忙，各路神仙送吉祥：财神送你金元宝，寿星保你身安康，文殊给你大智慧，观音佑你幸福长，弥勒让你乐不断，福星伴你走四方！春节快乐！</li><li>春风叩开猪年的门扉，对联贴满猪年的庭院，欢畅陶醉猪年的日子，幸福温暖猪年的时光，情意铺满猪年的道路。猪年到了，愿你的生活灿烂美满。</li><li>猪年就要到了，新春祝福提前到。祝你有人缘，事业顺利不心烦；祝你有情缘，爱情甜蜜心也甜；祝你有财源，腰包鼓鼓金钱花不完。最后祝你猪年大吉！</li><li>一张圆桌，合家团座笑呵呵；一顿晚餐，美味家肴喜庆多；一杯美酒，装满幸福和快乐；一个除夕，张灯结彩好喜气；一条祝福，愿你多财又多福；新年到，愿你全家幸福乐逍遥！</li><li>春节到处乐洋洋，祝福语先到身旁，心意情意都献上，愿您接纳永收藏，愿您事业财源广，愿您暖和体安康，愿您烦恼忧愁散，愿您春节安康！</li></ul><h3 id="绘制佩奇使用的是PS的钢笔"><a href="#绘制佩奇使用的是PS的钢笔" class="headerlink" title="绘制佩奇使用的是PS的钢笔"></a>绘制佩奇使用的是PS的钢笔</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/PeppaPig1.jpg" alt="Happy New Year!"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;春节快乐&quot;&gt;&lt;a href=&quot;#春节快乐&quot; class=&quot;headerlink&quot; title=&quot;春节快乐&quot;&gt;&lt;/a&gt;春节快乐&lt;/h3&gt;&lt;p&gt;祝各位春节快乐,新的一年大家也要继续努力鸭!
笔者还准备了礼物送给大家，点击下面的阅读全文查看&lt;/p&gt;
    
    </summary>
    
    
      <category term="节日祝福" scheme="https://lollipopnougat.github.io/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="春节" scheme="https://lollipopnougat.github.io/tags/%E6%98%A5%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>HTML (一)</title>
    <link href="https://lollipopnougat.github.io/2019/01/25/HTML%20(%E4%B8%80)/"/>
    <id>https://lollipopnougat.github.io/2019/01/25/HTML (一)/</id>
    <published>2019-01-25T13:36:08.000Z</published>
    <updated>2020-02-25T05:38:04.256Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><p>HTML 指超文本标记语言</p><blockquote><p>HTML 是通向 WEB 技术世界的钥匙。</p></blockquote><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>HTML是现在世界通用的超文本标记语言，通过它，可以实现图片、链接、音乐以及程序等等多种元素。<br>现如今，HTML已经是程序员必须掌握的一项基本功。</p><h2 id="HTML发展史"><a href="#HTML发展史" class="headerlink" title="HTML发展史"></a>HTML发展史</h2><p>HTML没有1.0，因为关于它的初版存在争议，1995年HTML 2.0面世，<br>1997年由国际官方组织W3C推出了HTML 3.2以及HTML 4.0标准，<br>后面W3C(万维网联盟)也渐渐变成Web技术领域的权威，经过漫长的演变，2014年，HTML 5标准最终面世。</p><blockquote><p>*HTML 2.0——1995年11月，RFC 1866发布<br>*HTML 3.2——1997年1月14日，W3C发布推荐标准<br>*HTML 4.0——1997年12月18日，W3C发布推荐标准<br>*HTML 4.01——1999年12月24日，W3C发布推荐标准<br>*HTML 5——2014年10月28日，W3C发布推荐标准</p></blockquote><h2 id="HTML5编辑规范"><a href="#HTML5编辑规范" class="headerlink" title="HTML5编辑规范"></a>HTML5编辑规范</h2><ol><li>文件拓展名默认使用htm或者html，便于操作系统或者程序辨认文件，而图片则基本上存为gif或jpg</li><li>浏览器默认忽视回车符，不过为了方便阅览，人们还是会习惯地在写完一段代码后进行回车</li><li>标记符号用尖括号括起来，带斜杠的元素表示该标记说明结束，大多数标记符必须成对使用，用以说明起始和结束。</li><li>必须使用半角而不是全角字符</li><li>HTML注释<code>&lt;!--注释内容--&gt;</code>的内容不给予显示。</li></ol><h2 id="这是笔者写的较为详细的一个入门页面"><a href="#这是笔者写的较为详细的一个入门页面" class="headerlink" title="这是笔者写的较为详细的一个入门页面"></a>这是笔者写的较为详细的一个入门页面</h2><p><a href="https://lollipopnougat.github.io/website-calculator/html/HTML1.html">HTML入门·一</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;HTML&quot;&gt;&lt;a href=&quot;#HTML&quot; class=&quot;headerlink&quot; title=&quot;HTML&quot;&gt;&lt;/a&gt;HTML&lt;/h3&gt;&lt;p&gt;HTML 指超文本标记语言&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML 是通向 WEB 技术世界的钥匙。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="HTML" scheme="https://lollipopnougat.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>PowerShell (一)</title>
    <link href="https://lollipopnougat.github.io/2019/01/17/PowerShell%20(%E4%B8%80)/"/>
    <id>https://lollipopnougat.github.io/2019/01/17/PowerShell (一)/</id>
    <published>2019-01-17T11:48:41.000Z</published>
    <updated>2020-02-25T12:38:29.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h3><p>PowerShell 是一种命令行外壳程序和脚本环境，<br>使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。</p><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png" alt="PowerShell"></p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>PowerShell是运行在Windows操作系统上实现对系统以及应用程序进行管理自动化的命令行脚本环境，<br>PowerShell需要.NET环境的支持，借助 <strong>.NET Framework</strong>平台强大的类库，几乎让一切都成为可能。<br>微软起“PowerShell”这个名字并不是夸夸其谈，它完全支持对象，其可读性，易用性，毫不夸张的说可以居所有Shell之首。</p><h2 id="受众"><a href="#受众" class="headerlink" title="受众"></a>受众</h2><p>Windows PowerShell 入门主要面向IT 专业人员、程序员和高级用户。</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>通过解决长期存在的问题并添加一些新的功能，Windows PowerShell 旨在改进命令行和脚本环境。<br>PowerShell以 <strong>.NET Framework</strong>为平台，接收和返回.NET对象，此举为管理和配置微软系统带来了新的方法和工具。<br>PowerShell推出了一个功能强大的命令叫做<code>cmdlet</code>,所有的cmdlet命令都遵循动词-名词这样语法结构。<br>如<code>Get-Command</code>, <code>Get-Process</code>等，<br>即使从来没有接触过PowerShell，也很容易能够明白命令的作用。<br>如<code>Get-Process</code>命令的意思就是获取所有的进程。</p><h2 id="新的脚本语言"><a href="#新的脚本语言" class="headerlink" title="新的脚本语言"></a>新的脚本语言</h2><p>由于以下原因，Windows PowerShell 使用它自己的语言，而不是重用现有的语言：<br>Windows PowerShell 需要用于管理.NET 对象的语言。该语言需要为使用cmdlet 提供一致的环境。<br>该语言需要支持复杂的任务，而不会使简单的任务变得更复杂。 该语言需要与在.NET编程中使用的高级语言（如C#）一致。</p><ol><li><p>PS1文件<br>一个PowerShell脚本其实就是一个简单的文本文件，这个文件包含了一系列PowerShell命令，<br>每个命令显示为独立的一行，对于被视为PowerShell脚本的文本文件，它的文件名需要使用.PS1扩展。</p></li><li><p>执行权限<br>为防止恶意脚本的执行，PowerShell有一个执行策略，默认情况下，这个执行策略被设为受限的（<code>Restricted</code>），<br>意味着PowerShell脚本无法执行，你可以使用下面的cmdlet命令确定当前的执行策略：</p><blockquote><ul><li><code>Get-ExecutionPolicy</code>你可以选择使用的执行策略有：</li><li><code>Restricted</code> -脚本不能运行。 </li><li><code>RemoteSigned</code> - 本地创建的脚本可以运行，但网上下载的脚本不能运行（除非它们拥有由受信任的发布者签署的数字签名）。 </li><li><code>AllSigned</code> – 仅当脚本由受信任的发布者签名才能运行。 </li><li><code>Unrestricted</code> –脚本执行不受限制，不管来自哪里，也不管它们是否有签名。</li></ul></blockquote></li></ol><p>你可以使用下面的cmdlet命令设置PowerShell的执行策略：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> &lt;policy name&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>运行脚本<br>如果你想从命令行运行一个可执行文件，多年来一个永恒不变的方法是，<br>在命令行转到该执行文件所在的位置，然后键入该执行文件的名称，<br>但这个古老的方法现在却不能适用于PowerShell可执行脚本了。<br>如果你想执行一个PowerShell脚本，通常必须键入完整的路径和文件名，<br>例如，假设你要运行一个名为a.ps1的脚本，你可以键入：<br><code>C:\Scripts\aps1</code><br>最大的例外是，如果PowerShell脚本文件刚好位于你的系统目录中，<br>那么你可以直接在命令提示符后键入脚本文件名即可运行，如：<br><code>.\a.ps1</code> 注意前面需要加上<code>.\</code>，这和Linux下执行Shell脚本的方法如出一辙。</p></li><li><p>管道<br>管道的作用是将一个命令的输出作为另一个命令的输入，两个命令（或cmdlet）之间只需要用管道符号（<code>|</code>）连接即可。<br>为了帮助你了解管道是如何工作的，我们以一个例子进行说明，假设你想创建运行在服务器上的进程列表，并按进程的ID号进行排序，<br>可以使用<code>Get-Process</code> cmdlet命令获得进程列表，但默认情况下列表不会排序，<br>如果将这个cmdlet命令的输出用管道输送给<code>Sort-Object ID</code>命令，进程列表将会按进程ID号进行排序，如：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> ID</span><br></pre></td></tr></table></figure></li><li><p>变量<br>虽然可以使用管道将一个命令的输出输送给另一个命令，<br>但管道本身也是有限制的，当你用管道从一个命令向另一个命令传递输出结果时，输出结果立即被使用，<br>但有时候，你可能需要保存输出结果一段时间，以便以后可以使用（或重用），这个时候管道就应该下场，轮到变量上场了。<br>人们很容易将变量想象成一个仓库，但在PowerShell中，变量可以保存命令的完整输出，<br>例如，假设你想保存服务器处于运行中的进程列表，你可以将它赋给一个变量，如：<br><code>$a = Get-Process</code><br>在这里，变量被命名为$a，如果你想使用这个变量，只需要简单地调用它的名称即可，<br>例如，键入$a便可在屏幕上打印变量的内容。<br>你可以将多个用管道连接的命令的最终输出赋给一个变量，只需要用一对小括号将命令括起来即可，<br>例如，假设你想按进程ID对运行中的进程进行排序，然后将结果输出给一个变量，你可以使用下面这个命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = (<span class="built_in">Get-Process</span> | <span class="built_in">Sort-Object</span> ID)</span><br></pre></td></tr></table></figure></li><li><p>@符号<br>通过使用@符号，你可以将列表内容转换成一个数组，<br>例如，下面的代码创建了一个名为$Procs的变量，它包含多行文本内容（一个数组）：<br><code>$procs = @{name=&quot;explorer&quot;,&quot;svchost&quot;}</code><br>使用变量时你也可以使用@符号，为了确保它作为数组而不是单个值处理，<br>例如，下面的代码将在我前面定义的变量上运行<code>Get-Process</code> cmdlet命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Get-Process</span> @procsWindows</span><br></pre></td></tr></table></figure></li></ol><p>将显示Windows资源管理器和Svchost使用的所有进程，注意变量前使用的<code>@</code>符号，而不是常见的<code>$</code>符号。</p><ol start="7"><li><p>Split<br>Split操作符根据你指定的字符拆分一个文本字符串，例如，假设你想将一个句子拆分成一个单词组成的一个数组，你可以使用下面的命令做到：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"This is a test"</span> -split <span class="string">" "</span></span><br></pre></td></tr></table></figure><p>拆分后的结果如下：<br><code>This is a test</code></p></li><li><p>Join<br>就像Split可以将一个文本字符串拆分成多块一样，Join的操作则是逆向的，将多个独立的块连接成一个整体，<br>例如，下面这行代码将会创建一个文本字符串，由我的名字和姓氏组成：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Brien"</span>,<span class="string">"Posey"</span> -join <span class="string">" "</span></span><br></pre></td></tr></table></figure><p>命令末尾双引号之间的空格告诉Windows在两个文本字符串之间插入一个空格。</p></li><li><p>断点<br>运行一个新创建的PowerShell脚本时，如果脚本有Bug，会遇到意想不到的后果，<br>保护自己的一个方法是在脚本的关键位置插入断点，这样你就可以确保脚本正常运行先，然后再处理可能存在的问题。<br>插入断点最简单的方法是根据行号插入，例如，假设你要在第10行插入一个断点，可以使用下面的命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">New-PSBreakpoint -Script C:\Scripts\a.ps1 -Line <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#你也可以将断点绑定到变量上，如果你希望你的脚本任何时候都可以修改a$的内容，可以使用下面的命令：</span></span><br><span class="line">New-PSBreakpoint -Script C:\scripts\a.ps1 -variables a </span><br><span class="line"><span class="comment">#注意，在变量名后并没有包括美元符号。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#可以和`PSBreakpoint`一起使用的动词包括`New`，`Get`，`Enable`，`Disable`和`Remove`。</span></span><br></pre></td></tr></table></figure></li><li><p>Step<br>调试一个脚本时，有时可能需要逐行运行脚本，这时你可以使用<code>Step-Into</code> cmdlet命令，它会使脚本一行一行地执行，不管有没有设置断点，如果你想从这种步进式运行模式退出来，使用<code>Step-Out</code> cmdlet命令即可，<br>但需要注意的是，使用<code>Step-Out</code> cmdlet命令后，断点仍然有效。<br>顺便说一句，如果你的脚本使用了函数，你可能对<code>Step-Out</code> cmdlet更感兴趣，<code>Step-Out</code> 的工作方式和<code>Step-Into</code> 一样，不过，如果调用了一个函数，Windows不会逐步执行，整个函数将会一次性执行。</p></li></ol><h3 id="因此PowerShell实际是一门独立的脚本语言了"><a href="#因此PowerShell实际是一门独立的脚本语言了" class="headerlink" title="因此PowerShell实际是一门独立的脚本语言了"></a>因此PowerShell实际是一门独立的脚本语言了</h3><h2 id="PowerShell能干什么？"><a href="#PowerShell能干什么？" class="headerlink" title="PowerShell能干什么？"></a>PowerShell能干什么？</h2><h3 id="PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，"><a href="#PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，" class="headerlink" title="PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，"></a>PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，</h3><p>为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。</p><p>PowerShell能做下面这些事:</p><blockquote><p>.NET/.NET CORE编程, Registry, COM, WMI, ADSI. Exchange, Sharepoint,<br> Systems Center, Hyper-V, SQL. VMware vCenter, Cisco UCS,<br> Citrix XenApp and XenDesktop.，Azure, Excel 和 Office applications.<br> 基本上所有的微软产品都提供PowerShell接口。</p></blockquote><h4 id="1、管理进程"><a href="#1、管理进程" class="headerlink" title="1、管理进程"></a>1、管理进程</h4><p>前面已经提过管理系统进程的命令，管理进程常用命令就是<code>get-process</code>和<code>stop-process</code>，<code>get-process</code>获取进程之后可以直接用管道发送给<code>stop-process</code>结束进程。<br>比如，关闭打开的记事本，可以使用下面的命令很方便的关闭记事本。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-process</span> -Name notepad | <span class="built_in">stop-process</span></span><br></pre></td></tr></table></figure><h4 id="2、处理文件和文件夹"><a href="#2、处理文件和文件夹" class="headerlink" title="2、处理文件和文件夹"></a>2、处理文件和文件夹</h4><p>PowerShell使用<code>Get-ChildItem</code>获取文件夹中直接包含的所有项，<br>它有系统内置别名<code>dir</code>和<code>ls</code>，使用CMD和BASH的用户均可以轻松上手。<br>如果想查看<code>C:</code>中的文件夹和文件，直接使用<code>dir c:</code>，PowerShell立刻就会列出<code>C:</code>中的文件和文件夹。<br>其它处理文件和文件夹的命令有<code>Copy-Item</code>、<code>New-Item</code>、<code>Remove-Item</code>等，<br>具体用法可以使用<code>get-help</code>然后跟命令名称即可查询。</p><h4 id="3、处理系统服务"><a href="#3、处理系统服务" class="headerlink" title="3、处理系统服务"></a>3、处理系统服务</h4><p>可以像管理进程一样管理系统服务，</p><ul><li><code>Get-Service</code>命令获取服务列表，</li><li><code>Stop-Service</code>命令停止服务，</li><li><code>Start-Service</code>命令启动服务，</li><li><code>Suspend-Service</code>命令挂起服务，</li><li><code>Restart-Service</code>命令重启服务，</li><li><code>Set-Service</code>服务设置服务属性。<br>如果想一次性启动已经停止的服务，可以使用以下命令：<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-service</span> | <span class="built_in">where-object</span> &#123;<span class="variable">$_</span>.Status <span class="nomarkup">-eq</span> <span class="string">"Stopped"</span>&#125; -exclude</span><br></pre></td></tr></table></figure></li></ul><p><strong>下面这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。</strong><br><code>wisvc | start-service</code></p><h4 id="4、处理注册表"><a href="#4、处理注册表" class="headerlink" title="4、处理注册表"></a>4、处理注册表</h4><p>PowerShell可以非常方便的处理注册表项目，<br>与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，<br>这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。<br>由于注册表对系统<strong>非常重要</strong>，<strong>错误处理注册表也许会导致系统出问题</strong>，处理注册表，特别是删除注册表项目要<strong>非常小心</strong>，最好能在处理注册表项目之前先<strong>备份</strong>要处理的项目。<strong>没有管理员权限也能处理部分注册表项目</strong>，这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。</p><h4 id="5、处理其它任务"><a href="#5、处理其它任务" class="headerlink" title="5、处理其它任务"></a>5、处理其它任务</h4><p>PowerShell还可以处理证书、防火墙、appx应用、打印机等任务，篇幅所限，不具体举例。大家可以使用get-command命令查找相关命令。</p><h4 id="6、编写脚本程序"><a href="#6、编写脚本程序" class="headerlink" title="6、编写脚本程序"></a>6、编写脚本程序</h4><p>借助于.Net/.Net Core 实际上来说其他的编程语言能干什么，<br>PowerShell都可以做到，PowerShell能够充分利用.Net类型和COM对象，<br>来简单地与各种系统交互，完成各种复杂的、自动化的操作，因此PowerShell现在也是很不错的编程语言了，<br>有人还做出了ps1 to exe的脚本，可以将PowerShell编写的脚本文件编译成exe可执行文件。</p><h2 id="一个有趣的例子"><a href="#一个有趣的例子" class="headerlink" title="一个有趣的例子"></a>一个有趣的例子</h2><p>这是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。<br>有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建新的excel com对象</span></span><br><span class="line"><span class="variable">$objExcel</span> = <span class="built_in">New-Object</span> -comobject Excel.Application</span><br><span class="line"><span class="variable">$objExcel</span>.Visible = <span class="literal">$True</span></span><br><span class="line"><span class="variable">$objWorkbook</span> = <span class="variable">$objExcel</span>.Workbooks.Add()</span><br><span class="line"><span class="variable">$objWorksheet</span> = <span class="variable">$objWorkbook</span>.Worksheets.Item(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把信息写入excel</span></span><br><span class="line"><span class="variable">$i</span> = <span class="number">0</span></span><br><span class="line"><span class="variable">$first10</span> = (ps | sort ws -Descending | select -first <span class="number">10</span>)</span><br><span class="line"><span class="variable">$first10</span> | <span class="keyword">foreach</span> -Process &#123;<span class="variable">$i</span>++; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="variable">$i</span>,<span class="number">1</span>) = <span class="variable">$_</span>.name; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="variable">$i</span>,<span class="number">2</span>) = <span class="variable">$_</span>.ws&#125;</span><br><span class="line"><span class="variable">$otherMem</span> = (ps | measure ws -s).Sum - (<span class="variable">$first10</span> | measure ws -s).Sum</span><br><span class="line"><span class="variable">$objWorksheet</span>.Cells.Item(<span class="number">11</span>,<span class="number">1</span>) = <span class="string">"Others"</span>; <span class="variable">$objWorksheet</span>.Cells.Item(<span class="number">11</span>,<span class="number">2</span>) = <span class="variable">$otherMem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 画饼图</span></span><br><span class="line"><span class="variable">$objCharts</span> = <span class="variable">$objWorksheet</span>.ChartObjects()</span><br><span class="line"><span class="variable">$objChart</span> = <span class="variable">$objCharts</span>.Add(<span class="number">0</span>, <span class="number">0</span>, <span class="number">500</span>, <span class="number">300</span>)</span><br><span class="line"><span class="variable">$objChart</span>.Chart.SetSourceData(<span class="variable">$objWorksheet</span>.range(<span class="string">"A1:B11"</span>), <span class="number">2</span>)</span><br><span class="line"><span class="variable">$objChart</span>.Chart.ChartType = <span class="number">70</span></span><br><span class="line"><span class="variable">$objChart</span>.Chart.ApplyDataLabels(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#暂停</span></span><br><span class="line">pause</span><br><span class="line"><span class="variable">$objExcel</span>.Quit()</span><br><span class="line"><span class="variable">$objExcel</span> = <span class="literal">$null</span></span><br><span class="line">[GC]::Collect()</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果:"></a>执行结果:</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/screenshot.png" alt="执行结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Powershell&quot;&gt;&lt;a href=&quot;#Powershell&quot; class=&quot;headerlink&quot; title=&quot;Powershell&quot;&gt;&lt;/a&gt;Powershell&lt;/h3&gt;&lt;p&gt;PowerShell 是一种命令行外壳程序和脚本环境，&lt;br&gt;使命令行用户和脚本编写者可以方便地使用 .NET Framework的强大功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/powershell.png&quot; alt=&quot;PowerShell&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="PowerShell" scheme="https://lollipopnougat.github.io/tags/PowerShell/"/>
    
  </entry>
  
  <entry>
    <title>元旦快乐</title>
    <link href="https://lollipopnougat.github.io/2019/01/01/%E5%85%83%E6%97%A6%E5%BF%AB%E4%B9%90/"/>
    <id>https://lollipopnougat.github.io/2019/01/01/元旦快乐/</id>
    <published>2018-12-31T16:12:12.000Z</published>
    <updated>2020-02-25T05:44:05.679Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019元旦快乐"><a href="#2019元旦快乐" class="headerlink" title="2019元旦快乐"></a>2019元旦快乐</h3><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/newyear.gif" alt="Happy New Year!"></p><a id="more"></a><h4 id="相逢是首悠扬的歌，相识是杯醇香的酒，"><a href="#相逢是首悠扬的歌，相识是杯醇香的酒，" class="headerlink" title="相逢是首悠扬的歌，相识是杯醇香的酒，"></a>相逢是首悠扬的歌，相识是杯醇香的酒，</h4><h4 id="相处是那南飞的雁，相知是根古老的藤。"><a href="#相处是那南飞的雁，相知是根古老的藤。" class="headerlink" title="相处是那南飞的雁，相知是根古老的藤。"></a>相处是那南飞的雁，相知是根古老的藤。</h4><h4 id="健康是最佳的礼物，知足是最大的财富，"><a href="#健康是最佳的礼物，知足是最大的财富，" class="headerlink" title="健康是最佳的礼物，知足是最大的财富，"></a>健康是最佳的礼物，知足是最大的财富，</h4><h4 id="信心是最可贵的品德，关心是最真挚的问候，"><a href="#信心是最可贵的品德，关心是最真挚的问候，" class="headerlink" title="信心是最可贵的品德，关心是最真挚的问候，"></a>信心是最可贵的品德，关心是最真挚的问候，</h4><h4 id="牵挂是最无私的思念，祝福是最美好的话语！"><a href="#牵挂是最无私的思念，祝福是最美好的话语！" class="headerlink" title="牵挂是最无私的思念，祝福是最美好的话语！"></a>牵挂是最无私的思念，祝福是最美好的话语！</h4><p><img src="https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/HappyNewYear.jpg" alt="Happy New Year!"></p><h1 id="在此献上最美好的祝福"><a href="#在此献上最美好的祝福" class="headerlink" title="在此献上最美好的祝福"></a>在此献上最美好的祝福</h1><h2 id="祝各位朋友们2019年新年快乐！平安幸福！"><a href="#祝各位朋友们2019年新年快乐！平安幸福！" class="headerlink" title="祝各位朋友们2019年新年快乐！平安幸福！"></a>祝各位朋友们2019年新年快乐！平安幸福！</h2>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;2019元旦快乐&quot;&gt;&lt;a href=&quot;#2019元旦快乐&quot; class=&quot;headerlink&quot; title=&quot;2019元旦快乐&quot;&gt;&lt;/a&gt;2019元旦快乐&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/lollipopnougat/website-calculator/img/newyear.gif&quot; alt=&quot;Happy New Year!&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="节日祝福" scheme="https://lollipopnougat.github.io/tags/%E8%8A%82%E6%97%A5%E7%A5%9D%E7%A6%8F/"/>
    
      <category term="元旦" scheme="https://lollipopnougat.github.io/tags/%E5%85%83%E6%97%A6/"/>
    
  </entry>
  
  <entry>
    <title>面向对象的程序设计</title>
    <link href="https://lollipopnougat.github.io/2018/12/30/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://lollipopnougat.github.io/2018/12/30/面向对象的程序设计/</id>
    <published>2018-12-30T07:06:15.000Z</published>
    <updated>2020-02-25T05:40:44.723Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象的程序设计"><a href="#面向对象的程序设计" class="headerlink" title="面向对象的程序设计"></a>面向对象的程序设计</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。<br>对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据<strong>封装</strong>其中，以提高软件的<strong>重用性</strong>、<strong>灵活性</strong>和<strong>扩展性</strong>。面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，<br>传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。</p><a id="more"></a><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>面向对象程序设计中的每一个对象都应该能够接受数据、处理数据并将数据传达给其它对象，因此它们都可以被看作一个个体，即对象。<br>目前已经被证实的是，面向对象程序设计推广了程序的<strong>灵活性</strong>和<strong>可维护性</strong>，并且在大型项目设计中广为应用。<br>此外，面向对象程序设计要比以往的做法更加便于学习，因为它能够让人们更简单地设计并维护程序，使得程序更加便于分析、设计、理解。</p><h2 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h2><p>面向对象是在结构化设计方法出现很多问题的情况下应运而生的。</p><p>结构化设计方法求解问题的基本策略是从功能的角度审视问题域。<br>它将应用程序看成实现某些特定任务的功能模块，其中子过程是实现某项具体操作的底层功能模块。<br>在每个功能模块中，用数据结构描述待处理数据的组织形式，用算法描述具体的操作过程。<br>面对日趋复杂的应用系统，这种开发思路在下面几个方面逐渐暴露了一些弱点。</p><h4 id="1-审视问题域的视角"><a href="#1-审视问题域的视角" class="headerlink" title="1. 审视问题域的视角"></a>1. 审视问题域的视角</h4><blockquote><p>在现实世界中存在的客体是问题域中的主角，所谓客体是指客观存在的对象实体和主观抽象的概念，他是人类观察问题和解决问题的主要目标。例如，对于一个学校学生管理系统来说，无论是简单还是复杂，始终是围绕学生和老师这两个客体实施。在自然界，每个客体都具有一些属性和行为，例如学生有学号、姓名、性别等属性，以及上课、考试、做实验等行为。因此，每个个体都可以用属性和行为来描述。<br>通常人类观察问题的视角是这些客体，客体的属性反应客体在某一时刻的状态，客体的行为反映客体能从事的操作。这些操作附在客体之上并能用来设置、改变和获取客体的状态。任何问题域都有一系列的客体，因此解决问题的基本方式是让这些客体之间相互驱动、相互作用，最终使每个客体按照设计者的意愿改变其属性状态。<br>结构化设计方法所采用的设计思路不是将客体作为一个整体，而是将依附于客体之上的行为抽取出来，以功能为目标来设计构造应用系统。这种做法导致在进行程序设计的时候，不得不将客体所构成的现实世界映射到由功能模块组成的解空间中，这种变换过程，不仅增加了程序设计的复杂程度，而且背离了人们观察问题和解决问题的基本思路。另外，再仔细思考会发现，在任何一个问题域中，客体是稳定的，而行为是不稳定的。例如，不管是国家图书馆，还是学校图书馆，还是国际图书馆，都会含有图书这个客体，但管理图书的方法可能是截然不同的。结构化设计方法将审视问题的视角定位于不稳定的操作之上，并将描述客体的属性和行为分开，使得应用程序的日后维护和扩展相当困难，甚至一个微小的变动，都会波及到整个系统。面对问题规模的日趋扩大、环境的日趋复杂、需求变化的日趋加快，将利用计算机解决问题的基本方法统一到人类解决问题的习惯方法之上，彻底改变软件设计方法与人类解决问题的常规方式扭曲的现象迫在眉睫，这是提出面向对象的首要原因。</p></blockquote><h4 id="2-抽象级别"><a href="#2-抽象级别" class="headerlink" title="2. 抽象级别"></a>2. 抽象级别</h4><blockquote><p>抽象是人类解决问题的基本法宝。良好的抽象策略可以控制问题的复杂程度，增强系统的通用性和可扩展性。抽象主要包括过程抽象和数据抽象。结构化设计方法应用的是过程抽象。所谓过程抽象是将问题域中具有明确功能定义的操作抽取出来，并将其作为一个实体看待。这种抽象级别对于软件系统结构的设计显得有些武断，并且稳定性差，导致很难准确无误地设计出系统的每一个操作环节。一旦某个客体属性的表示方式发生了变化，就有可能牵扯到已有系统的很多部分。而数据抽象是较过程抽象更高级别的抽象方式，将描述客体的属性和行为绑定在一起，实现统一的抽象，从而达到对现实世界客体的真正模拟。</p></blockquote><h4 id="3-封装体"><a href="#3-封装体" class="headerlink" title="3. 封装体"></a>3. 封装体</h4><blockquote><p>封装是指将现实世界中存在的某个客体的属性与行为绑定在一起，并放置在一个逻辑单元内。该逻辑单元负责将所描述的属性隐藏起来，外界对客体内部属性的所有访问只能通过提供的用户接口实现。这样做既可以实现对客体属性的保护作用，又可以提高软件系统的可维护性。只要用户接口不改变，任何封装体内部的改变都不会对软件系统的其他部分造成影响。结构化设计方法没有做到客体的整体封装，只是封装了各个功能模块，而每个功能模块可以随意地对没有保护能力客体属性实施操作，并且由于描述属性的数据与行为被分割开来，所以一旦某个客体属性的表达方式发生了变化，或某个行为效果发生了改变，就有可能对整个系统产生影响。</p></blockquote><h4 id="4-可重用性"><a href="#4-可重用性" class="headerlink" title="4. 可重用性"></a>4. 可重用性</h4><blockquote><p>可重用性标识着软件产品的可复用能力，是衡量一个软件产品成功与否的重要标志。当今的软件开发行业，人们越来越追求开发更多的、更有通用性的可重用构件，从而使软件开发过程彻底改善，即从过去的语句级编写发展到现在的构件组装，从而提高软件开发效率，推动应用领域迅速扩展。然而，结构化程序设计方法的基本单位是模块，每个模块只是实现特定功能的过程描述，因此，它的可重用单位只能是模块。例如，在C语言编写程序时使用大量的标准函数。但对于今天的软件开发来说，这样的重用力度显得微不足道，而且当参与操作的某些数据类型发生变化时，就不能够再使用那些函数了。因此，渴望更大力度的可重用构件是如今应用领域对软件开发提出的新需求。</p></blockquote><p>上述弱点驱使人们寻求一种新的程序设计方法，以适应现代社会对软件开发的更高要求，面向对象由此产生。</p><p>面向对象程序设计从80年代以后成为了一种主导思想，这主要归功于C++在编写图形界面的应用。<br>在图形用户界面（GUI）日渐崛起的情况下，面向对象程序设计很好地<em>适应了潮流</em>。面向对象程序设计的思想也使<strong>事件处理式</strong>的程序设计更加广泛被应用</p><h2 id="抽象的示例"><a href="#抽象的示例" class="headerlink" title="抽象的示例"></a>抽象的示例</h2><p>假如我们要写一个程序模拟一只羊，使用C语言面向过程的方法，<br>首先想到的是开一个结构体，然后定义几个变量:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sheep</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sheep Jeff; <span class="comment">//定义一只叫Jeff的羊</span></span><br></pre></td></tr></table></figure><p>很容易，现在Jeff要跑，怎么办？<br>于是就用一个run函数，把Jeff作为一个参数传递来实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(Sheep sheep)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(Jeff);</span><br></pre></td></tr></table></figure><p>也很容易是吧，现在我们的Jeff遇到了羊大侠，羊大侠是站着跑的，怎么描述羊大侠站着跑呢？<br>再写一个函数，站着跑？那假如又遇到穿鞋跑的怎么办？</p><p>这时候如果使用面向对象的方法，将跑步作为对象的成员函数，把跑步的方法作为参数传递；<br>这样，所有的羊都有了一种叫跑步的方法，就方便多了:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="built_in">string</span> method=<span class="string">"default"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mie</span><span class="params">()</span></span>;<span class="comment">//咩</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">double</span> height,weight;</span><br><span class="line">&#125;;<span class="comment">//定义一个Sheep类</span></span><br><span class="line"></span><br><span class="line">Sheep Jeff;</span><br><span class="line">Jeff.run(); <span class="comment">//Jeff使用默认的方法跑步</span></span><br><span class="line"></span><br><span class="line">Sheep YangDaXia;</span><br><span class="line">YangDaXia.run(<span class="string">"onFoot"</span>); <span class="comment">//羊大侠站着跑</span></span><br><span class="line"></span><br><span class="line">Sheep XiYangYang;</span><br><span class="line">XiYangYang.run(<span class="string">"shoes"</span>); <span class="comment">//喜羊羊穿鞋跑</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;面向对象的程序设计&quot;&gt;&lt;a href=&quot;#面向对象的程序设计&quot; class=&quot;headerlink&quot; title=&quot;面向对象的程序设计&quot;&gt;&lt;/a&gt;面向对象的程序设计&lt;/h3&gt;&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;面向对象程序设计（英语：Object-oriented programming，abbr：OOP）是一种程序设计范型，同时也是一种程序开发的方法。&lt;br&gt;对象指的是类的实例。它将对象作为程序的基本单元，将程序和数据&lt;strong&gt;封装&lt;/strong&gt;其中，以提高软件的&lt;strong&gt;重用性&lt;/strong&gt;、&lt;strong&gt;灵活性&lt;/strong&gt;和&lt;strong&gt;扩展性&lt;/strong&gt;。
面向对象程序设计可以看作一种在程序中包含各种独立而又互相调用的对象的思想，这与传统的思想刚好相反，&lt;br&gt;传统的程序设计主张将程序看作一系列函数的集合，或者直接就是一系列对电脑下达的指令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="面向对象" scheme="https://lollipopnougat.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="C/C++" scheme="https://lollipopnougat.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>The first one</title>
    <link href="https://lollipopnougat.github.io/2018/12/30/The-first-one/"/>
    <id>https://lollipopnougat.github.io/2018/12/30/The-first-one/</id>
    <published>2018-12-30T03:44:32.000Z</published>
    <updated>2020-02-25T05:39:30.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="测试用页面"><a href="#测试用页面" class="headerlink" title="测试用页面"></a>测试用页面</h3><a id="more"></a><p>第一个第一个第一个哈哈哈哈哈哈哈哈哈哈![^1]<br>[^1]: 这是脚注</p><h1 id="这是1级标题"><a href="#这是1级标题" class="headerlink" title="这是1级标题"></a>这是1级标题</h1><p><em>这是斜体</em><br><strong>这是加粗</strong><br><strong><em>这是斜体加粗</em></strong></p><p><del>这是删除</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello,world!"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这是代码段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="这是2级标题"><a href="#这是2级标题" class="headerlink" title="这是2级标题"></a>这是2级标题</h2><p><code>这是代码块</code></p><h3 id="这是3级标题"><a href="#这是3级标题" class="headerlink" title="这是3级标题"></a>这是3级标题</h3><blockquote><p>这是引述</p><blockquote><p>这是引述嵌套</p></blockquote></blockquote><p><img src="https://www.baidu.com/img/dong_418ce2c6c5171fb4cb0d4d1edb4fab68.gif" alt="这是图片"> </p><hr><h4 id="这是4级标题"><a href="#这是4级标题" class="headerlink" title="这是4级标题"></a>这是4级标题</h4><p><a href="http://www.baidu.com" target="_blank" rel="noopener">这是百度一下</a></p><p>-[x] 选项一<br>-[ ] 选项二<br>-[ ] 选项三</p><hr><h5 id="这是5级标题"><a href="#这是5级标题" class="headerlink" title="这是5级标题"></a>这是5级标题</h5><ul><li>这是无序列表</li><li>这是无序列表</li><li>这是无序列表</li></ul><ol><li>这是有序列表</li><li>这是有序列表</li><li>这是有序列表</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;测试用页面&quot;&gt;&lt;a href=&quot;#测试用页面&quot; class=&quot;headerlink&quot; title=&quot;测试用页面&quot;&gt;&lt;/a&gt;测试用页面&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
